/*
Package ocygot is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.12/genutil/names.go
using the following YANG input files:
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/aft/openconfig-aft-network-instance.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/defined-sets/openconfig-defined-sets.yang
  - public/release/models/ethernet-segments/openconfig-ethernet-segments.yang
  - public/release/models/flex-algo/openconfig-flexalgo.yang
  - public/release/models/gribi/openconfig-gribi.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ethernet-ext.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/keychain/openconfig-keychain.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/macsec/openconfig-macsec.yang
  - public/release/models/mpls/openconfig-mpls.yang
  - public/release/models/multicast/openconfig-igmp.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/optical-transport/openconfig-optical-amplifier.yang
  - public/release/models/optical-transport/openconfig-terminal-device.yang
  - public/release/models/optical-transport/openconfig-transport-line-protection.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/ospf/openconfig-ospf-policy.yang
  - public/release/models/pcep/openconfig-pcep.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-routing-policy.yang
  - public/release/models/probes/openconfig-probes.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/relay-agent/openconfig-relay-agent.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/sampling/openconfig-sampling.yang
  - public/release/models/segment-routing/openconfig-segment-routing.yang
  - public/release/models/stp/openconfig-spanning-tree.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/telemetry/openconfig-telemetry.yang
  - public/release/models/vlan/openconfig-vlan.yang

Imported modules were sourced from:
  - public/...
*/
package ocygot

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct {
	ΛMetadata   []ygot.Annotation                                                            `path:"@" ygotAnnotation:"true"`
	Evi         *uint32                                                                      `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEvi        []ygot.Annotation                                                            `path:"state/@evi" ygotAnnotation:"true"`
	HostIp      *string                                                                      `path:"state/host-ip|host-ip" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛHostIp     []ygot.Annotation                                                            `path:"state/@host-ip|@host-ip" ygotAnnotation:"true"`
	L2Vni       *uint32                                                                      `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL2Vni      []ygot.Annotation                                                            `path:"state/@l2-vni" ygotAnnotation:"true"`
	L3Vni       *uint32                                                                      `path:"state/l3-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL3Vni      []ygot.Annotation                                                            `path:"state/@l3-vni" ygotAnnotation:"true"`
	MacAddress  *string                                                                      `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛMacAddress []ygot.Annotation                                                            `path:"state/@mac-address|@mac-address" ygotAnnotation:"true"`
	Producer    map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProducer   []ygot.Annotation                                                            `path:"producers/@producer" ygotAnnotation:"true"`
	Vlan        *uint16                                                                      `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVlan       []ygot.Annotation                                                            `path:"state/@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetHostIp retrieves the value of the leaf HostIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostIp is set, it can
// safely use t.GetHostIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetHostIp() string {
	if t == nil || t.HostIp == nil {
		return ""
	}
	return *t.HostIp
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetL3Vni retrieves the value of the leaf L3Vni from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3Vni is set, it can
// safely use t.GetL3Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetL3Vni() uint32 {
	if t == nil || t.L3Vni == nil {
		return 0
	}
	return *t.L3Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HostIp == nil {
		return nil, fmt.Errorf("nil value for key HostIp")
	}

	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"host-ip":     *t.HostIp,
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct {
	ΛMetadata      []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	Esi            *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi           []ygot.Annotation        `path:"state/@esi" ygotAnnotation:"true"`
	MobilityState  E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMobilityState []ygot.Annotation        `path:"state/@mobility-state" ygotAnnotation:"true"`
	NextHop        *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop       []ygot.Annotation        `path:"state/@next-hop" ygotAnnotation:"true"`
	NextHopGroup   []uint64                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup  []ygot.Annotation        `path:"state/@next-hop-group" ygotAnnotation:"true"`
	Producer       E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛProducer      []ygot.Annotation        `path:"state/@producer|@producer" ygotAnnotation:"true"`
	SeqNumber      *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSeqNumber     []ygot.Annotation        `path:"state/@seq-number" ygotAnnotation:"true"`
	Sticky         *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSticky        []ygot.Annotation        `path:"state/@sticky" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetNextHopGroup() []uint64 {
	if t == nil || t.NextHopGroup == nil {
		return nil
	}
	return t.NextHopGroup
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Esi           *string           `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi          []ygot.Annotation `path:"state/@esi" ygotAnnotation:"true"`
	Index         *uint64           `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex        []ygot.Annotation `path:"state/@index|@index" ygotAnnotation:"true"`
	Interface     *string           `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"state/@interface" ygotAnnotation:"true"`
	Label         *uint32           `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLabel        []ygot.Annotation `path:"state/@label" ygotAnnotation:"true"`
	PeerIp        *string           `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPeerIp       []ygot.Annotation `path:"state/@peer-ip" ygotAnnotation:"true"`
	Resolved      *bool             `path:"state/resolved" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛResolved     []ygot.Annotation `path:"state/@resolved" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"state/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetResolved retrieves the value of the leaf Resolved from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Resolved is set, it can
// safely use t.GetResolved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Resolved == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetResolved() bool {
	if t == nil || t.Resolved == nil {
		return false
	}
	return *t.Resolved
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct {
	ΛMetadata []ygot.Annotation                                                     `path:"@" ygotAnnotation:"true"`
	Esi       *string                                                               `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi      []ygot.Annotation                                                     `path:"state/@esi" ygotAnnotation:"true"`
	Id        *uint64                                                               `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId       []ygot.Annotation                                                     `path:"state/@id|@id" ygotAnnotation:"true"`
	NextHop   map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop  []ygot.Annotation                                                     `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	Type      E_NextHopGroup_Type                                                   `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛType     []ygot.Annotation                                                     `path:"state/@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) IsYANGGoStruct() {}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) GetType() E_NextHopGroup_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Index     *uint64           `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex    []ygot.Annotation `path:"state/@index|@index" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable struct {
	ΛMetadata     []ygot.Annotation                                           `path:"@" ygotAnnotation:"true"`
	Entry         map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry        `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntry        []ygot.Annotation                                           `path:"entries/@entry" ygotAnnotation:"true"`
	NextHop       map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop      `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop      []ygot.Annotation                                           `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	NextHopGroup  map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup []ygot.Annotation                                           `path:"next-hop-groups/@next-hop-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewEntry(MacAddress string) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry{
		MacAddress: &MacAddress,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameEntry(oldK, newK string) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	key := MacAddress

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetEntry(MacAddress string) *NetworkInstance_Fdb_L2Rib_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteEntry(MacAddress string) {
	key := MacAddress

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[string]*NetworkInstance_Fdb_L2Rib_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Fdb_L2Rib_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) NewNextHopGroup(Id uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Fdb_L2Rib_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Fdb_L2Rib_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) GetNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Fdb_L2Rib_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) AppendNextHopGroup(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable.
func (*NetworkInstance_Fdb_L2Rib_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry struct {
	ΛMetadata   []ygot.Annotation                                                          `path:"@" ygotAnnotation:"true"`
	Evi         *uint32                                                                    `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEvi        []ygot.Annotation                                                          `path:"state/@evi" ygotAnnotation:"true"`
	L2Vni       *uint32                                                                    `path:"state/l2-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL2Vni      []ygot.Annotation                                                          `path:"state/@l2-vni" ygotAnnotation:"true"`
	MacAddress  *string                                                                    `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛMacAddress []ygot.Annotation                                                          `path:"state/@mac-address|@mac-address" ygotAnnotation:"true"`
	Producer    map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer `path:"producers/producer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProducer   []ygot.Annotation                                                          `path:"producers/@producer" ygotAnnotation:"true"`
	Vlan        *uint16                                                                    `path:"state/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVlan       []ygot.Annotation                                                          `path:"state/@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) IsYANGGoStruct() {}

// NewProducer creates a new entry in the Producer list of the
// NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) NewProducer(Producer E_Producer_Producer) (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	key := Producer

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Producer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Producer", key)
	}

	t.Producer[key] = &NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer{
		Producer: Producer,
	}

	return t.Producer[key], nil
}

// RenameProducer renames an entry in the list Producer within
// the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) RenameProducer(oldK, newK E_Producer_Producer) error {
	if _, ok := t.Producer[newK]; ok {
		return fmt.Errorf("key %v already exists in Producer", newK)
	}

	e, ok := t.Producer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Producer", oldK)
	}
	e.Producer = newK

	t.Producer[newK] = e
	delete(t.Producer, oldK)
	return nil
}

// GetOrCreateProducer retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetOrCreateProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	key := Producer

	if v, ok := t.Producer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProducer(Producer)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProducer got unexpected error: %v", err))
	}
	return v
}

// GetProducer retrieves the value with the specified key from
// the Producer map field of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetProducer(Producer E_Producer_Producer) *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer {

	if t == nil {
		return nil
	}

	key := Producer

	if lm, ok := t.Producer[key]; ok {
		return lm
	}
	return nil
}

// DeleteProducer deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_Entry. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) DeleteProducer(Producer E_Producer_Producer) {
	key := Producer

	delete(t.Producer, key)
}

// AppendProducer appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct to the
// list Producer of NetworkInstance_Fdb_L2Rib_MacTable_Entry. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) AppendProducer(v *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) error {
	key := v.Producer

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Producer == nil {
		t.Producer = make(map[E_Producer_Producer]*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer)
	}

	if _, ok := t.Producer[key]; ok {
		return fmt.Errorf("duplicate key for list Producer %v", key)
	}

	t.Producer[key] = v
	return nil
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetL2Vni retrieves the value of the leaf L2Vni from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Vni is set, it can
// safely use t.GetL2Vni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetL2Vni() uint32 {
	if t == nil || t.L2Vni == nil {
		return 0
	}
	return *t.L2Vni
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Producer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/entries/entry/producers/producer YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct {
	ΛMetadata         []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	DerivedFromMacIp  *bool                    `path:"state/derived-from-mac-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDerivedFromMacIp []ygot.Annotation        `path:"state/@derived-from-mac-ip" ygotAnnotation:"true"`
	DirectlyReceived  *bool                    `path:"state/directly-received" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDirectlyReceived []ygot.Annotation        `path:"state/@directly-received" ygotAnnotation:"true"`
	Esi               *string                  `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi              []ygot.Annotation        `path:"state/@esi" ygotAnnotation:"true"`
	MobilityState     E_Producer_MobilityState `path:"state/mobility-state" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMobilityState    []ygot.Annotation        `path:"state/@mobility-state" ygotAnnotation:"true"`
	NextHop           *uint64                  `path:"state/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop          []ygot.Annotation        `path:"state/@next-hop" ygotAnnotation:"true"`
	NextHopGroup      []uint64                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup     []ygot.Annotation        `path:"state/@next-hop-group" ygotAnnotation:"true"`
	Producer          E_Producer_Producer      `path:"state/producer|producer" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛProducer         []ygot.Annotation        `path:"state/@producer|@producer" ygotAnnotation:"true"`
	SeqNumber         *uint32                  `path:"state/seq-number" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSeqNumber        []ygot.Annotation        `path:"state/@seq-number" ygotAnnotation:"true"`
	Sticky            *bool                    `path:"state/sticky" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSticky           []ygot.Annotation        `path:"state/@sticky" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) IsYANGGoStruct() {}

// GetDerivedFromMacIp retrieves the value of the leaf DerivedFromMacIp from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DerivedFromMacIp is set, it can
// safely use t.GetDerivedFromMacIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DerivedFromMacIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDerivedFromMacIp() bool {
	if t == nil || t.DerivedFromMacIp == nil {
		return false
	}
	return *t.DerivedFromMacIp
}

// GetDirectlyReceived retrieves the value of the leaf DirectlyReceived from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DirectlyReceived is set, it can
// safely use t.GetDirectlyReceived() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DirectlyReceived == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetDirectlyReceived() bool {
	if t == nil || t.DirectlyReceived == nil {
		return false
	}
	return *t.DirectlyReceived
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMobilityState retrieves the value of the leaf MobilityState from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MobilityState is set, it can
// safely use t.GetMobilityState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MobilityState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetMobilityState() E_Producer_MobilityState {
	if t == nil || t.MobilityState == 0 {
		return 0
	}
	return t.MobilityState
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHop() uint64 {
	if t == nil || t.NextHop == nil {
		return 0
	}
	return *t.NextHop
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetNextHopGroup() []uint64 {
	if t == nil || t.NextHopGroup == nil {
		return nil
	}
	return t.NextHopGroup
}

// GetProducer retrieves the value of the leaf Producer from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Producer is set, it can
// safely use t.GetProducer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Producer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetProducer() E_Producer_Producer {
	if t == nil || t.Producer == 0 {
		return 0
	}
	return t.Producer
}

// GetSeqNumber retrieves the value of the leaf SeqNumber from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SeqNumber is set, it can
// safely use t.GetSeqNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SeqNumber == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSeqNumber() uint32 {
	if t == nil || t.SeqNumber == nil {
		return 0
	}
	return *t.SeqNumber
}

// GetSticky retrieves the value of the leaf Sticky from the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sticky is set, it can
// safely use t.GetSticky() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sticky == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) GetSticky() bool {
	if t == nil || t.Sticky == nil {
		return false
	}
	return *t.Sticky
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"producer": t.Producer,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer.
func (*NetworkInstance_Fdb_L2Rib_MacTable_Entry_Producer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Esi           *string           `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi          []ygot.Annotation `path:"state/@esi" ygotAnnotation:"true"`
	Index         *uint64           `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex        []ygot.Annotation `path:"state/@index|@index" ygotAnnotation:"true"`
	Interface     *string           `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"state/@interface" ygotAnnotation:"true"`
	Label         *uint32           `path:"state/label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLabel        []ygot.Annotation `path:"state/@label" ygotAnnotation:"true"`
	PeerIp        *string           `path:"state/peer-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPeerIp       []ygot.Annotation `path:"state/@peer-ip" ygotAnnotation:"true"`
	Resolved      *bool             `path:"state/resolved" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛResolved     []ygot.Annotation `path:"state/@resolved" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"state/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) IsYANGGoStruct() {}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetLabel() uint32 {
	if t == nil || t.Label == nil {
		return 0
	}
	return *t.Label
}

// GetPeerIp retrieves the value of the leaf PeerIp from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIp is set, it can
// safely use t.GetPeerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetPeerIp() string {
	if t == nil || t.PeerIp == nil {
		return ""
	}
	return *t.PeerIp
}

// GetResolved retrieves the value of the leaf Resolved from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Resolved is set, it can
// safely use t.GetResolved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Resolved == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetResolved() bool {
	if t == nil || t.Resolved == nil {
		return false
	}
	return *t.Resolved
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct {
	ΛMetadata []ygot.Annotation                                                   `path:"@" ygotAnnotation:"true"`
	Esi       *string                                                             `path:"state/esi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEsi      []ygot.Annotation                                                   `path:"state/@esi" ygotAnnotation:"true"`
	Id        *uint64                                                             `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId       []ygot.Annotation                                                   `path:"state/@id|@id" ygotAnnotation:"true"`
	NextHop   map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop  []ygot.Annotation                                                   `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	Type      E_NextHopGroup_Type                                                 `path:"state/type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛType     []ygot.Annotation                                                   `path:"state/@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) IsYANGGoStruct() {}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetEsi retrieves the value of the leaf Esi from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) GetType() E_NextHopGroup_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-table/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Index     *uint64           `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex    []ygot.Annotation `path:"state/@index|@index" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop.
func (*NetworkInstance_Fdb_L2Rib_MacTable_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacMobility represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-mobility YANG schema element.
type NetworkInstance_Fdb_MacMobility struct {
	ΛMetadata                     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	DuplicateIpDetectionInterval  *uint16           `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDuplicateIpDetectionInterval []ygot.Annotation `path:"config/@duplicate-ip-detection-interval" ygotAnnotation:"true"`
	IpMobilityThreshold           *uint16           `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpMobilityThreshold          []ygot.Annotation `path:"config/@ip-mobility-threshold" ygotAnnotation:"true"`
	MacMobility                   *bool             `path:"config/mac-mobility" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacMobility                  []ygot.Annotation `path:"config/@mac-mobility" ygotAnnotation:"true"`
	MacMobilityThreshold          *uint8            `path:"config/mac-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacMobilityThreshold         []ygot.Annotation `path:"config/@mac-mobility-threshold" ygotAnnotation:"true"`
	MacMobilityWindow             *uint16           `path:"config/mac-mobility-window" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacMobilityWindow            []ygot.Annotation `path:"config/@mac-mobility-window" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacMobility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacMobility) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetMacMobility retrieves the value of the leaf MacMobility from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobility is set, it can
// safely use t.GetMacMobility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobility == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobility() bool {
	if t == nil || t.MacMobility == nil {
		return false
	}
	return *t.MacMobility
}

// GetMacMobilityThreshold retrieves the value of the leaf MacMobilityThreshold from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityThreshold is set, it can
// safely use t.GetMacMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityThreshold() uint8 {
	if t == nil || t.MacMobilityThreshold == nil {
		return 5
	}
	return *t.MacMobilityThreshold
}

// GetMacMobilityWindow retrieves the value of the leaf MacMobilityWindow from the NetworkInstance_Fdb_MacMobility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacMobilityWindow is set, it can
// safely use t.GetMacMobilityWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacMobilityWindow == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacMobility) GetMacMobilityWindow() uint16 {
	if t == nil || t.MacMobilityWindow == nil {
		return 180
	}
	return *t.MacMobilityWindow
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacMobility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacMobility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MacMobilityThreshold == nil {
		var v uint8 = 5
		t.MacMobilityThreshold = &v
	}
	if t.MacMobilityWindow == nil {
		var v uint16 = 180
		t.MacMobilityWindow = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacMobility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacMobility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacMobility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacMobility.
func (*NetworkInstance_Fdb_MacMobility) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table YANG schema element.
type NetworkInstance_Fdb_MacTable struct {
	ΛMetadata []ygot.Annotation                                                              `path:"@" ygotAnnotation:"true"`
	Entry     map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntry    []ygot.Annotation                                                              `path:"entries/@entry" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_MacTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/mac-table.
type NetworkInstance_Fdb_MacTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	Vlan       uint16 `path:"vlan"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Fdb_MacTable_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Fdb_MacTable_Entry_Key key struct.
func (t NetworkInstance_Fdb_MacTable_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mac-address": t.MacAddress,
		"vlan":        t.Vlan,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_MacTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_MacTable) NewEntry(MacAddress string, Vlan uint16) (*NetworkInstance_Fdb_MacTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_MacTable_Entry{
		MacAddress: &MacAddress,
		Vlan:       &Vlan,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_MacTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_MacTable) RenameEntry(oldK, newK NetworkInstance_Fdb_MacTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.Vlan = &newK.Vlan

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_MacTable) GetOrCreateEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, Vlan)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_MacTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_MacTable) GetEntry(MacAddress string, Vlan uint16) *NetworkInstance_Fdb_MacTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_MacTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_MacTable) DeleteEntry(MacAddress string, Vlan uint16) {
	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: MacAddress,
		Vlan:       Vlan,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_MacTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_MacTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_MacTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_MacTable) AppendEntry(v *NetworkInstance_Fdb_MacTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.Vlan == nil {
		return fmt.Errorf("invalid nil key for Vlan")
	}

	key := NetworkInstance_Fdb_MacTable_Entry_Key{
		MacAddress: *v.MacAddress,
		Vlan:       *v.Vlan,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_MacTable_Entry_Key]*NetworkInstance_Fdb_MacTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable.
func (*NetworkInstance_Fdb_MacTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry struct {
	ΛMetadata   []ygot.Annotation                             `path:"@" ygotAnnotation:"true"`
	Age         *uint64                                       `path:"state/age" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAge        []ygot.Annotation                             `path:"state/@age" ygotAnnotation:"true"`
	EntryType   E_Entry_EntryType                             `path:"state/entry-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryType  []ygot.Annotation                             `path:"state/@entry-type" ygotAnnotation:"true"`
	Evi         *uint32                                       `path:"state/evi" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEvi        []ygot.Annotation                             `path:"state/@evi" ygotAnnotation:"true"`
	Interface   *NetworkInstance_Fdb_MacTable_Entry_Interface `path:"interface" module:"openconfig-network-instance"`
	ΛInterface  []ygot.Annotation                             `path:"@interface" ygotAnnotation:"true"`
	MacAddress  *string                                       `path:"config/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛMacAddress []ygot.Annotation                             `path:"config/@mac-address|@mac-address" ygotAnnotation:"true"`
	Vlan        *uint16                                       `path:"config/vlan|vlan" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛVlan       []ygot.Annotation                             `path:"config/@vlan|@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry) IsYANGGoStruct() {}

// GetOrCreateInterface retrieves the value of the Interface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetOrCreateInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t.Interface != nil {
		return t.Interface
	}
	t.Interface = &NetworkInstance_Fdb_MacTable_Entry_Interface{}
	return t.Interface
}

// GetInterface returns the value of the Interface struct pointer
// from NetworkInstance_Fdb_MacTable_Entry. If the receiver or the field Interface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetInterface() *NetworkInstance_Fdb_MacTable_Entry_Interface {
	if t != nil && t.Interface != nil {
		return t.Interface
	}
	return nil
}

// GetAge retrieves the value of the leaf Age from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetEntryType retrieves the value of the leaf EntryType from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryType is set, it can
// safely use t.GetEntryType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEntryType() E_Entry_EntryType {
	if t == nil || t.EntryType == 0 {
		return 0
	}
	return t.EntryType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetEvi() uint32 {
	if t == nil || t.Evi == nil {
		return 0
	}
	return *t.Evi
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetVlan retrieves the value of the leaf Vlan from the NetworkInstance_Fdb_MacTable_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry) GetVlan() uint16 {
	if t == nil || t.Vlan == nil {
		return 0
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Interface.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Fdb_MacTable_Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	if t.Vlan == nil {
		return nil, fmt.Errorf("nil value for key Vlan")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
		"vlan":        *t.Vlan,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry.
func (*NetworkInstance_Fdb_MacTable_Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface struct {
	ΛMetadata     []ygot.Annotation                                          `path:"@" ygotAnnotation:"true"`
	InterfaceRef  *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
	ΛInterfaceRef []ygot.Annotation                                          `path:"@interface-ref" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Fdb_MacTable_Entry_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) GetInterfaceRef() *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/fdb/mac-table/entries/entry/interface/interface-ref YANG schema element.
type NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef.
func (*NetworkInstance_Fdb_MacTable_Entry_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_NdProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/nd-proxy YANG schema element.
type NetworkInstance_Fdb_NdProxy struct {
	ΛMetadata                     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	DuplicateIpDetectionInterval  *uint16           `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDuplicateIpDetectionInterval []ygot.Annotation `path:"config/@duplicate-ip-detection-interval" ygotAnnotation:"true"`
	Enable                        *bool             `path:"config/enable" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnable                       []ygot.Annotation `path:"config/@enable" ygotAnnotation:"true"`
	IpMobilityThreshold           *uint16           `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpMobilityThreshold          []ygot.Annotation `path:"config/@ip-mobility-threshold" ygotAnnotation:"true"`
	NdSuppression                 *bool             `path:"config/nd-suppression" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNdSuppression                []ygot.Annotation `path:"config/@nd-suppression" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_NdProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_NdProxy) IsYANGGoStruct() {}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// GetNdSuppression retrieves the value of the leaf NdSuppression from the NetworkInstance_Fdb_NdProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NdSuppression is set, it can
// safely use t.GetNdSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NdSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_NdProxy) GetNdSuppression() bool {
	if t == nil || t.NdSuppression == nil {
		return false
	}
	return *t.NdSuppression
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_NdProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_NdProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
	if t.NdSuppression == nil {
		var v bool = false
		t.NdSuppression = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_NdProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_NdProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_NdProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_NdProxy.
func (*NetworkInstance_Fdb_NdProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_FlexAlgorithm represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm YANG schema element.
type NetworkInstance_FlexAlgorithm struct {
	ΛMetadata                 []ygot.Annotation                                       `path:"@" ygotAnnotation:"true"`
	Algorithm                 map[uint8]*NetworkInstance_FlexAlgorithm_Algorithm      `path:"flex-algorithm-definition/algorithm" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛAlgorithm                []ygot.Annotation                                       `path:"flex-algorithm-definition/@algorithm" ygotAnnotation:"true"`
	FlexAlgoGlobalAttributes  *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes `path:"flex-algo-global-attributes" module:"openconfig-flexalgo"`
	ΛFlexAlgoGlobalAttributes []ygot.Annotation                                       `path:"@flex-algo-global-attributes" ygotAnnotation:"true"`
	Interface                 map[string]*NetworkInstance_FlexAlgorithm_Interface     `path:"flex-algo-interface-attributes/interface" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛInterface                []ygot.Annotation                                       `path:"flex-algo-interface-attributes/@interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm) IsYANGGoStruct() {}

// NewAlgorithm creates a new entry in the Algorithm list of the
// NetworkInstance_FlexAlgorithm struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_FlexAlgorithm) NewAlgorithm(FlexAlgoId uint8) (*NetworkInstance_FlexAlgorithm_Algorithm, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Algorithm == nil {
		t.Algorithm = make(map[uint8]*NetworkInstance_FlexAlgorithm_Algorithm)
	}

	key := FlexAlgoId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Algorithm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Algorithm", key)
	}

	t.Algorithm[key] = &NetworkInstance_FlexAlgorithm_Algorithm{
		FlexAlgoId: &FlexAlgoId,
	}

	return t.Algorithm[key], nil
}

// RenameAlgorithm renames an entry in the list Algorithm within
// the NetworkInstance_FlexAlgorithm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_FlexAlgorithm) RenameAlgorithm(oldK, newK uint8) error {
	if _, ok := t.Algorithm[newK]; ok {
		return fmt.Errorf("key %v already exists in Algorithm", newK)
	}

	e, ok := t.Algorithm[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Algorithm", oldK)
	}
	e.FlexAlgoId = &newK

	t.Algorithm[newK] = e
	delete(t.Algorithm, oldK)
	return nil
}

// GetOrCreateAlgorithm retrieves the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_FlexAlgorithm) GetOrCreateAlgorithm(FlexAlgoId uint8) *NetworkInstance_FlexAlgorithm_Algorithm {

	key := FlexAlgoId

	if v, ok := t.Algorithm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAlgorithm(FlexAlgoId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAlgorithm got unexpected error: %v", err))
	}
	return v
}

// GetAlgorithm retrieves the value with the specified key from
// the Algorithm map field of NetworkInstance_FlexAlgorithm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_FlexAlgorithm) GetAlgorithm(FlexAlgoId uint8) *NetworkInstance_FlexAlgorithm_Algorithm {

	if t == nil {
		return nil
	}

	key := FlexAlgoId

	if lm, ok := t.Algorithm[key]; ok {
		return lm
	}
	return nil
}

// DeleteAlgorithm deletes the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_FlexAlgorithm) DeleteAlgorithm(FlexAlgoId uint8) {
	key := FlexAlgoId

	delete(t.Algorithm, key)
}

// AppendAlgorithm appends the supplied NetworkInstance_FlexAlgorithm_Algorithm struct to the
// list Algorithm of NetworkInstance_FlexAlgorithm. If the key value(s) specified in
// the supplied NetworkInstance_FlexAlgorithm_Algorithm already exist in the list, an error is
// returned.
func (t *NetworkInstance_FlexAlgorithm) AppendAlgorithm(v *NetworkInstance_FlexAlgorithm_Algorithm) error {
	if v.FlexAlgoId == nil {
		return fmt.Errorf("invalid nil key received for FlexAlgoId")
	}

	key := *v.FlexAlgoId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Algorithm == nil {
		t.Algorithm = make(map[uint8]*NetworkInstance_FlexAlgorithm_Algorithm)
	}

	if _, ok := t.Algorithm[key]; ok {
		return fmt.Errorf("duplicate key for list Algorithm %v", key)
	}

	t.Algorithm[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_FlexAlgorithm struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_FlexAlgorithm) NewInterface(InterfaceId string) (*NetworkInstance_FlexAlgorithm_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_FlexAlgorithm_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_FlexAlgorithm_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_FlexAlgorithm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_FlexAlgorithm) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_FlexAlgorithm) GetOrCreateInterface(InterfaceId string) *NetworkInstance_FlexAlgorithm_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_FlexAlgorithm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_FlexAlgorithm) GetInterface(InterfaceId string) *NetworkInstance_FlexAlgorithm_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_FlexAlgorithm) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_FlexAlgorithm_Interface struct to the
// list Interface of NetworkInstance_FlexAlgorithm. If the key value(s) specified in
// the supplied NetworkInstance_FlexAlgorithm_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_FlexAlgorithm) AppendInterface(v *NetworkInstance_FlexAlgorithm_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_FlexAlgorithm_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateFlexAlgoGlobalAttributes retrieves the value of the FlexAlgoGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_FlexAlgorithm) GetOrCreateFlexAlgoGlobalAttributes() *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes {
	if t.FlexAlgoGlobalAttributes != nil {
		return t.FlexAlgoGlobalAttributes
	}
	t.FlexAlgoGlobalAttributes = &NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes{}
	return t.FlexAlgoGlobalAttributes
}

// GetFlexAlgoGlobalAttributes returns the value of the FlexAlgoGlobalAttributes struct pointer
// from NetworkInstance_FlexAlgorithm. If the receiver or the field FlexAlgoGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_FlexAlgorithm) GetFlexAlgoGlobalAttributes() *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes {
	if t != nil && t.FlexAlgoGlobalAttributes != nil {
		return t.FlexAlgoGlobalAttributes
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FlexAlgoGlobalAttributes.PopulateDefaults()
	for _, e := range t.Algorithm {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm.
func (*NetworkInstance_FlexAlgorithm) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_FlexAlgorithm_Algorithm represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm/flex-algorithm-definition/algorithm YANG schema element.
type NetworkInstance_FlexAlgorithm_Algorithm struct {
	ΛMetadata            []ygot.Annotation             `path:"@" ygotAnnotation:"true"`
	AlgoFlags            *bool                         `path:"config/algo-flags" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛAlgoFlags           []ygot.Annotation             `path:"config/@algo-flags" ygotAnnotation:"true"`
	CalcType             *uint8                        `path:"config/calc-type" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛCalcType            []ygot.Annotation             `path:"config/@calc-type" ygotAnnotation:"true"`
	Exclude              []string                      `path:"config/exclude" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛExclude             []ygot.Annotation             `path:"config/@exclude" ygotAnnotation:"true"`
	FlexAlgoDescription  *string                       `path:"config/flex-algo-description" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛFlexAlgoDescription []ygot.Annotation             `path:"config/@flex-algo-description" ygotAnnotation:"true"`
	FlexAlgoId           *uint8                        `path:"config/flex-algo-id|flex-algo-id" module:"openconfig-flexalgo/openconfig-flexalgo|openconfig-flexalgo"`
	ΛFlexAlgoId          []ygot.Annotation             `path:"config/@flex-algo-id|@flex-algo-id" ygotAnnotation:"true"`
	FlexAlgoName         *string                       `path:"config/flex-algo-name" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛFlexAlgoName        []ygot.Annotation             `path:"config/@flex-algo-name" ygotAnnotation:"true"`
	IncludeAll           []string                      `path:"config/include-all" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛIncludeAll          []ygot.Annotation             `path:"config/@include-all" ygotAnnotation:"true"`
	IncludeAny           []string                      `path:"config/include-any" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛIncludeAny          []ygot.Annotation             `path:"config/@include-any" ygotAnnotation:"true"`
	MetricType           E_Flexalgo_FlexAlgoMetricType `path:"config/metric-type" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛMetricType          []ygot.Annotation             `path:"config/@metric-type" ygotAnnotation:"true"`
	Priority             *uint8                        `path:"config/priority" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛPriority            []ygot.Annotation             `path:"config/@priority" ygotAnnotation:"true"`
	SrlgExclude          []string                      `path:"config/srlg-exclude" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛSrlgExclude         []ygot.Annotation             `path:"config/@srlg-exclude" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm_Algorithm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm_Algorithm) IsYANGGoStruct() {}

// GetAlgoFlags retrieves the value of the leaf AlgoFlags from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AlgoFlags is set, it can
// safely use t.GetAlgoFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AlgoFlags == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetAlgoFlags() bool {
	if t == nil || t.AlgoFlags == nil {
		return false
	}
	return *t.AlgoFlags
}

// GetCalcType retrieves the value of the leaf CalcType from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CalcType is set, it can
// safely use t.GetCalcType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CalcType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetCalcType() uint8 {
	if t == nil || t.CalcType == nil {
		return 0
	}
	return *t.CalcType
}

// GetExclude retrieves the value of the leaf Exclude from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Exclude is set, it can
// safely use t.GetExclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Exclude == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetExclude() []string {
	if t == nil || t.Exclude == nil {
		return nil
	}
	return t.Exclude
}

// GetFlexAlgoDescription retrieves the value of the leaf FlexAlgoDescription from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlexAlgoDescription is set, it can
// safely use t.GetFlexAlgoDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlexAlgoDescription == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetFlexAlgoDescription() string {
	if t == nil || t.FlexAlgoDescription == nil {
		return ""
	}
	return *t.FlexAlgoDescription
}

// GetFlexAlgoId retrieves the value of the leaf FlexAlgoId from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlexAlgoId is set, it can
// safely use t.GetFlexAlgoId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlexAlgoId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetFlexAlgoId() uint8 {
	if t == nil || t.FlexAlgoId == nil {
		return 0
	}
	return *t.FlexAlgoId
}

// GetFlexAlgoName retrieves the value of the leaf FlexAlgoName from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlexAlgoName is set, it can
// safely use t.GetFlexAlgoName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlexAlgoName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetFlexAlgoName() string {
	if t == nil || t.FlexAlgoName == nil {
		return ""
	}
	return *t.FlexAlgoName
}

// GetIncludeAll retrieves the value of the leaf IncludeAll from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAll is set, it can
// safely use t.GetIncludeAll() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAll == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetIncludeAll() []string {
	if t == nil || t.IncludeAll == nil {
		return nil
	}
	return t.IncludeAll
}

// GetIncludeAny retrieves the value of the leaf IncludeAny from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAny is set, it can
// safely use t.GetIncludeAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAny == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetIncludeAny() []string {
	if t == nil || t.IncludeAny == nil {
		return nil
	}
	return t.IncludeAny
}

// GetMetricType retrieves the value of the leaf MetricType from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricType is set, it can
// safely use t.GetMetricType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetMetricType() E_Flexalgo_FlexAlgoMetricType {
	if t == nil || t.MetricType == 0 {
		return Flexalgo_FlexAlgoMetricType_IGP
	}
	return t.MetricType
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 237
	}
	return *t.Priority
}

// GetSrlgExclude retrieves the value of the leaf SrlgExclude from the NetworkInstance_FlexAlgorithm_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgExclude is set, it can
// safely use t.GetSrlgExclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgExclude == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) GetSrlgExclude() []string {
	if t == nil || t.SrlgExclude == nil {
		return nil
	}
	return t.SrlgExclude
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm_Algorithm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CalcType == nil {
		var v uint8 = 0
		t.CalcType = &v
	}
	if t.MetricType == 0 {
		t.MetricType = Flexalgo_FlexAlgoMetricType_IGP
	}
	if t.Priority == nil {
		var v uint8 = 237
		t.Priority = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_FlexAlgorithm_Algorithm struct, which is a YANG list entry.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FlexAlgoId == nil {
		return nil, fmt.Errorf("nil value for key FlexAlgoId")
	}

	return map[string]interface{}{
		"flex-algo-id": *t.FlexAlgoId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm_Algorithm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm_Algorithm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm_Algorithm.
func (*NetworkInstance_FlexAlgorithm_Algorithm) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm/flex-algo-global-attributes YANG schema element.
type NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes struct {
	ΛMetadata   []ygot.Annotation                                                             `path:"@" ygotAnnotation:"true"`
	AdminGroup  map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup `path:"flex-algo-admin-groups/admin-group" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛAdminGroup []ygot.Annotation                                                             `path:"flex-algo-admin-groups/@admin-group" ygotAnnotation:"true"`
	Srlg        map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg       `path:"srlgs/srlg" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛSrlg       []ygot.Annotation                                                             `path:"srlgs/@srlg" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) IsYANGGoStruct() {}

// NewAdminGroup creates a new entry in the AdminGroup list of the
// NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) NewAdminGroup(AdminGroupName string) (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup)
	}

	key := AdminGroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdminGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdminGroup", key)
	}

	t.AdminGroup[key] = &NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup{
		AdminGroupName: &AdminGroupName,
	}

	return t.AdminGroup[key], nil
}

// RenameAdminGroup renames an entry in the list AdminGroup within
// the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) RenameAdminGroup(oldK, newK string) error {
	if _, ok := t.AdminGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in AdminGroup", newK)
	}

	e, ok := t.AdminGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdminGroup", oldK)
	}
	e.AdminGroupName = &newK

	t.AdminGroup[newK] = e
	delete(t.AdminGroup, oldK)
	return nil
}

// GetOrCreateAdminGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) GetOrCreateAdminGroup(AdminGroupName string) *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup {

	key := AdminGroupName

	if v, ok := t.AdminGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdminGroup(AdminGroupName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdminGroup got unexpected error: %v", err))
	}
	return v
}

// GetAdminGroup retrieves the value with the specified key from
// the AdminGroup map field of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) GetAdminGroup(AdminGroupName string) *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup {

	if t == nil {
		return nil
	}

	key := AdminGroupName

	if lm, ok := t.AdminGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdminGroup deletes the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) DeleteAdminGroup(AdminGroupName string) {
	key := AdminGroupName

	delete(t.AdminGroup, key)
}

// AppendAdminGroup appends the supplied NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup struct to the
// list AdminGroup of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) AppendAdminGroup(v *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) error {
	if v.AdminGroupName == nil {
		return fmt.Errorf("invalid nil key received for AdminGroupName")
	}

	key := *v.AdminGroupName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdminGroup == nil {
		t.AdminGroup = make(map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup)
	}

	if _, ok := t.AdminGroup[key]; ok {
		return fmt.Errorf("duplicate key for list AdminGroup %v", key)
	}

	t.AdminGroup[key] = v
	return nil
}

// NewSrlg creates a new entry in the Srlg list of the
// NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) NewSrlg(Name string) (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srlg[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srlg", key)
	}

	t.Srlg[key] = &NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg{
		Name: &Name,
	}

	return t.Srlg[key], nil
}

// RenameSrlg renames an entry in the list Srlg within
// the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) RenameSrlg(oldK, newK string) error {
	if _, ok := t.Srlg[newK]; ok {
		return fmt.Errorf("key %v already exists in Srlg", newK)
	}

	e, ok := t.Srlg[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srlg", oldK)
	}
	e.Name = &newK

	t.Srlg[newK] = e
	delete(t.Srlg, oldK)
	return nil
}

// GetOrCreateSrlg retrieves the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) GetOrCreateSrlg(Name string) *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg {

	key := Name

	if v, ok := t.Srlg[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrlg(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrlg got unexpected error: %v", err))
	}
	return v
}

// GetSrlg retrieves the value with the specified key from
// the Srlg map field of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) GetSrlg(Name string) *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Srlg[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrlg deletes the value with the specified keys from
// the receiver NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) DeleteSrlg(Name string) {
	key := Name

	delete(t.Srlg, key)
}

// AppendSrlg appends the supplied NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg struct to the
// list Srlg of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes. If the key value(s) specified in
// the supplied NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg already exist in the list, an error is
// returned.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) AppendSrlg(v *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srlg == nil {
		t.Srlg = make(map[string]*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg)
	}

	if _, ok := t.Srlg[key]; ok {
		return fmt.Errorf("duplicate key for list Srlg %v", key)
	}

	t.Srlg[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AdminGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.Srlg {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm/flex-algo-global-attributes/flex-algo-admin-groups/admin-group YANG schema element.
type NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup struct {
	ΛMetadata       []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	AdminGroupName  *string           `path:"config/admin-group-name|admin-group-name" module:"openconfig-flexalgo/openconfig-flexalgo|openconfig-flexalgo"`
	ΛAdminGroupName []ygot.Annotation `path:"config/@admin-group-name|@admin-group-name" ygotAnnotation:"true"`
	BitPosition     *uint32           `path:"config/bit-position" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛBitPosition    []ygot.Annotation `path:"config/@bit-position" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) IsYANGGoStruct() {}

// GetAdminGroupName retrieves the value of the leaf AdminGroupName from the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroupName is set, it can
// safely use t.GetAdminGroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroupName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) GetAdminGroupName() string {
	if t == nil || t.AdminGroupName == nil {
		return ""
	}
	return *t.AdminGroupName
}

// GetBitPosition retrieves the value of the leaf BitPosition from the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BitPosition is set, it can
// safely use t.GetBitPosition() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BitPosition == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) GetBitPosition() uint32 {
	if t == nil || t.BitPosition == nil {
		return 0
	}
	return *t.BitPosition
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup struct, which is a YANG list entry.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AdminGroupName == nil {
		return nil, fmt.Errorf("nil value for key AdminGroupName")
	}

	return map[string]interface{}{
		"admin-group-name": *t.AdminGroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_AdminGroup) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm/flex-algo-global-attributes/srlgs/srlg YANG schema element.
type NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Name      *string           `path:"config/name|name" module:"openconfig-flexalgo/openconfig-flexalgo|openconfig-flexalgo"`
	ΛName     []ygot.Annotation `path:"config/@name|@name" ygotAnnotation:"true"`
	Value     *uint32           `path:"config/value" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛValue    []ygot.Annotation `path:"config/@value" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg struct, which is a YANG list entry.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg.
func (*NetworkInstance_FlexAlgorithm_FlexAlgoGlobalAttributes_Srlg) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_FlexAlgorithm_Interface represents the /openconfig-network-instance/network-instances/network-instance/flex-algorithm/flex-algo-interface-attributes/interface YANG schema element.
type NetworkInstance_FlexAlgorithm_Interface struct {
	ΛMetadata       []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	AdminGroup      []string          `path:"config/admin-group" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛAdminGroup     []ygot.Annotation `path:"config/@admin-group" ygotAnnotation:"true"`
	InterfaceId     *string           `path:"config/interface-id|interface-id" module:"openconfig-flexalgo/openconfig-flexalgo|openconfig-flexalgo"`
	ΛInterfaceId    []ygot.Annotation `path:"config/@interface-id|@interface-id" ygotAnnotation:"true"`
	MinDelay        *uint32           `path:"config/min-delay" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛMinDelay       []ygot.Annotation `path:"config/@min-delay" ygotAnnotation:"true"`
	SrlgMembership  []string          `path:"config/srlg-membership" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛSrlgMembership []ygot.Annotation `path:"config/@srlg-membership" ygotAnnotation:"true"`
	TeMetric        *uint32           `path:"config/te-metric" module:"openconfig-flexalgo/openconfig-flexalgo"`
	ΛTeMetric       []ygot.Annotation `path:"config/@te-metric" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_FlexAlgorithm_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_FlexAlgorithm_Interface) IsYANGGoStruct() {}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_FlexAlgorithm_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_FlexAlgorithm_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMinDelay retrieves the value of the leaf MinDelay from the NetworkInstance_FlexAlgorithm_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinDelay is set, it can
// safely use t.GetMinDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinDelay == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Interface) GetMinDelay() uint32 {
	if t == nil || t.MinDelay == nil {
		return 0
	}
	return *t.MinDelay
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the NetworkInstance_FlexAlgorithm_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the NetworkInstance_FlexAlgorithm_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_FlexAlgorithm_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_FlexAlgorithm_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_FlexAlgorithm_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_FlexAlgorithm_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_FlexAlgorithm_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_FlexAlgorithm_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_FlexAlgorithm_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_FlexAlgorithm_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_FlexAlgorithm_Interface.
func (*NetworkInstance_FlexAlgorithm_Interface) ΛBelongingModule() string {
	return "openconfig-flexalgo"
}

// NetworkInstance_InterInstancePolicies represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies YANG schema element.
type NetworkInstance_InterInstancePolicies struct {
	ΛMetadata           []ygot.Annotation                                         `path:"@" ygotAnnotation:"true"`
	ApplyPolicy         *NetworkInstance_InterInstancePolicies_ApplyPolicy        `path:"apply-policy" module:"openconfig-network-instance"`
	ΛApplyPolicy        []ygot.Annotation                                         `path:"@apply-policy" ygotAnnotation:"true"`
	ImportExportPolicy  *NetworkInstance_InterInstancePolicies_ImportExportPolicy `path:"import-export-policy" module:"openconfig-network-instance"`
	ΛImportExportPolicy []ygot.Annotation                                         `path:"@import-export-policy" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies) IsYANGGoStruct() {}

// GetOrCreateApplyPolicy retrieves the value of the ApplyPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	t.ApplyPolicy = &NetworkInstance_InterInstancePolicies_ApplyPolicy{}
	return t.ApplyPolicy
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_InterInstancePolicies) GetOrCreateImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_InterInstancePolicies_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetApplyPolicy returns the value of the ApplyPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ApplyPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetApplyPolicy() *NetworkInstance_InterInstancePolicies_ApplyPolicy {
	if t != nil && t.ApplyPolicy != nil {
		return t.ApplyPolicy
	}
	return nil
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_InterInstancePolicies. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_InterInstancePolicies) GetImportExportPolicy() *NetworkInstance_InterInstancePolicies_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ApplyPolicy.PopulateDefaults()
	t.ImportExportPolicy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies.
func (*NetworkInstance_InterInstancePolicies) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ApplyPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/apply-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ApplyPolicy struct {
	ΛMetadata            []ygot.Annotation                 `path:"@" ygotAnnotation:"true"`
	DefaultExportPolicy  E_RoutingPolicy_DefaultPolicyType `path:"config/default-export-policy" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDefaultExportPolicy []ygot.Annotation                 `path:"config/@default-export-policy" ygotAnnotation:"true"`
	DefaultImportPolicy  E_RoutingPolicy_DefaultPolicyType `path:"config/default-import-policy" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDefaultImportPolicy []ygot.Annotation                 `path:"config/@default-import-policy" ygotAnnotation:"true"`
	ExportPolicy         []string                          `path:"config/export-policy" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExportPolicy        []ygot.Annotation                 `path:"config/@export-policy" ygotAnnotation:"true"`
	ImportPolicy         []string                          `path:"config/import-policy" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛImportPolicy        []ygot.Annotation                 `path:"config/@import-policy" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ApplyPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) IsYANGGoStruct() {}

// GetDefaultExportPolicy retrieves the value of the leaf DefaultExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultExportPolicy is set, it can
// safely use t.GetDefaultExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultExportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultExportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultExportPolicy
}

// GetDefaultImportPolicy retrieves the value of the leaf DefaultImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultImportPolicy is set, it can
// safely use t.GetDefaultImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetDefaultImportPolicy() E_RoutingPolicy_DefaultPolicyType {
	if t == nil || t.DefaultImportPolicy == 0 {
		return RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	return t.DefaultImportPolicy
}

// GetExportPolicy retrieves the value of the leaf ExportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportPolicy is set, it can
// safely use t.GetExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetExportPolicy() []string {
	if t == nil || t.ExportPolicy == nil {
		return nil
	}
	return t.ExportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the NetworkInstance_InterInstancePolicies_ApplyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) GetImportPolicy() []string {
	if t == nil || t.ImportPolicy == nil {
		return nil
	}
	return t.ImportPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ApplyPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultExportPolicy == 0 {
		t.DefaultExportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
	if t.DefaultImportPolicy == 0 {
		t.DefaultImportPolicy = RoutingPolicy_DefaultPolicyType_REJECT_ROUTE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ApplyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ApplyPolicy.
func (*NetworkInstance_InterInstancePolicies_ApplyPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy YANG schema element.
type NetworkInstance_InterInstancePolicies_ImportExportPolicy struct {
	ΛMetadata          []ygot.Annotation                                                                  `path:"@" ygotAnnotation:"true"`
	ExportRouteTarget  []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union `path:"config/export-route-target" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExportRouteTarget []ygot.Annotation                                                                  `path:"config/@export-route-target" ygotAnnotation:"true"`
	ImportRouteTarget  []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union `path:"config/import-route-target" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛImportRouteTarget []ygot.Annotation                                                                  `path:"config/@import-route-target" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_InterInstancePolicies_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_InterInstancePolicies_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_InterInstancePolicies_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_InterInstancePolicies_ImportExportPolicy.
func (*NetworkInstance_InterInstancePolicies_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Interface represents the /openconfig-network-instance/network-instances/network-instance/interfaces/interface YANG schema element.
type NetworkInstance_Interface struct {
	ΛMetadata                  []ygot.Annotation             `path:"@" ygotAnnotation:"true"`
	AssociatedAddressFamilies  []E_Types_ADDRESS_FAMILY      `path:"config/associated-address-families" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAssociatedAddressFamilies []ygot.Annotation             `path:"config/@associated-address-families" ygotAnnotation:"true"`
	Id                         *string                       `path:"config/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId                        []ygot.Annotation             `path:"config/@id|@id" ygotAnnotation:"true"`
	Interface                  *string                       `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface                 []ygot.Annotation             `path:"config/@interface" ygotAnnotation:"true"`
	IrbAnycastGateway          E_Interface_IrbAnycastGateway `path:"config/irb-anycast-gateway" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIrbAnycastGateway         []ygot.Annotation             `path:"config/@irb-anycast-gateway" ygotAnnotation:"true"`
	MacPinning                 *bool                         `path:"config/mac-pinning" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacPinning                []ygot.Annotation             `path:"config/@mac-pinning" ygotAnnotation:"true"`
	Subinterface               *uint32                       `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface              []ygot.Annotation             `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Interface) IsYANGGoStruct() {}

// GetAssociatedAddressFamilies retrieves the value of the leaf AssociatedAddressFamilies from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedAddressFamilies is set, it can
// safely use t.GetAssociatedAddressFamilies() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedAddressFamilies == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetAssociatedAddressFamilies() []E_Types_ADDRESS_FAMILY {
	if t == nil || t.AssociatedAddressFamilies == nil {
		return nil
	}
	return t.AssociatedAddressFamilies
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIrbAnycastGateway retrieves the value of the leaf IrbAnycastGateway from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IrbAnycastGateway is set, it can
// safely use t.GetIrbAnycastGateway() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IrbAnycastGateway == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetIrbAnycastGateway() E_Interface_IrbAnycastGateway {
	if t == nil || t.IrbAnycastGateway == 0 {
		return 0
	}
	return t.IrbAnycastGateway
}

// GetMacPinning retrieves the value of the leaf MacPinning from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacPinning is set, it can
// safely use t.GetMacPinning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacPinning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetMacPinning() bool {
	if t == nil || t.MacPinning == nil {
		return false
	}
	return *t.MacPinning
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Interface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Interface.
func (*NetworkInstance_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls represents the /openconfig-network-instance/network-instances/network-instance/mpls YANG schema element.
type NetworkInstance_Mpls struct {
	ΛMetadata           []ygot.Annotation                          `path:"@" ygotAnnotation:"true"`
	Global              *NetworkInstance_Mpls_Global               `path:"global" module:"openconfig-network-instance"`
	ΛGlobal             []ygot.Annotation                          `path:"@global" ygotAnnotation:"true"`
	Interface           map[string]*NetworkInstance_Mpls_Interface `path:"te-interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface          []ygot.Annotation                          `path:"te-interface-attributes/@interface" ygotAnnotation:"true"`
	Lsps                *NetworkInstance_Mpls_Lsps                 `path:"lsps" module:"openconfig-network-instance"`
	ΛLsps               []ygot.Annotation                          `path:"@lsps" ygotAnnotation:"true"`
	SignalingProtocols  *NetworkInstance_Mpls_SignalingProtocols   `path:"signaling-protocols" module:"openconfig-network-instance"`
	ΛSignalingProtocols []ygot.Annotation                          `path:"@signaling-protocols" ygotAnnotation:"true"`
	TeGlobalAttributes  *NetworkInstance_Mpls_TeGlobalAttributes   `path:"te-global-attributes" module:"openconfig-network-instance"`
	ΛTeGlobalAttributes []ygot.Annotation                          `path:"@te-global-attributes" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Interface struct to the
// list Interface of NetworkInstance_Mpls. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls) AppendInterface(v *NetworkInstance_Mpls_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateGlobal() *NetworkInstance_Mpls_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_Global{}
	return t.Global
}

// GetOrCreateLsps retrieves the value of the Lsps field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateLsps() *NetworkInstance_Mpls_Lsps {
	if t.Lsps != nil {
		return t.Lsps
	}
	t.Lsps = &NetworkInstance_Mpls_Lsps{}
	return t.Lsps
}

// GetOrCreateSignalingProtocols retrieves the value of the SignalingProtocols field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	t.SignalingProtocols = &NetworkInstance_Mpls_SignalingProtocols{}
	return t.SignalingProtocols
}

// GetOrCreateTeGlobalAttributes retrieves the value of the TeGlobalAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls) GetOrCreateTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	t.TeGlobalAttributes = &NetworkInstance_Mpls_TeGlobalAttributes{}
	return t.TeGlobalAttributes
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetGlobal() *NetworkInstance_Mpls_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetLsps returns the value of the Lsps struct pointer
// from NetworkInstance_Mpls. If the receiver or the field Lsps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetLsps() *NetworkInstance_Mpls_Lsps {
	if t != nil && t.Lsps != nil {
		return t.Lsps
	}
	return nil
}

// GetSignalingProtocols returns the value of the SignalingProtocols struct pointer
// from NetworkInstance_Mpls. If the receiver or the field SignalingProtocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetSignalingProtocols() *NetworkInstance_Mpls_SignalingProtocols {
	if t != nil && t.SignalingProtocols != nil {
		return t.SignalingProtocols
	}
	return nil
}

// GetTeGlobalAttributes returns the value of the TeGlobalAttributes struct pointer
// from NetworkInstance_Mpls. If the receiver or the field TeGlobalAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls) GetTeGlobalAttributes() *NetworkInstance_Mpls_TeGlobalAttributes {
	if t != nil && t.TeGlobalAttributes != nil {
		return t.TeGlobalAttributes
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.Lsps.PopulateDefaults()
	t.SignalingProtocols.PopulateDefaults()
	t.TeGlobalAttributes.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls.
func (*NetworkInstance_Mpls) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/global YANG schema element.
type NetworkInstance_Mpls_Global struct {
	ΛMetadata           []ygot.Annotation                                          `path:"@" ygotAnnotation:"true"`
	Interface           map[string]*NetworkInstance_Mpls_Global_Interface          `path:"interface-attributes/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface          []ygot.Annotation                                          `path:"interface-attributes/@interface" ygotAnnotation:"true"`
	NullLabel           E_MplsTypes_NULL_LABEL_TYPE                                `path:"config/null-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNullLabel          []ygot.Annotation                                          `path:"config/@null-label" ygotAnnotation:"true"`
	PwEncapsulation     E_MplsTypes_PSEUDOWIRE_ENCAPSULATION                       `path:"config/pw-encapsulation" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPwEncapsulation    []ygot.Annotation                                          `path:"config/@pw-encapsulation" ygotAnnotation:"true"`
	ReservedLabelBlock  map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock `path:"reserved-label-blocks/reserved-label-block" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛReservedLabelBlock []ygot.Annotation                                          `path:"reserved-label-blocks/@reserved-label-block" ygotAnnotation:"true"`
	TtlPropagation      *bool                                                      `path:"config/ttl-propagation" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTtlPropagation     []ygot.Annotation                                          `path:"config/@ttl-propagation" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewInterface(InterfaceId string) (*NetworkInstance_Mpls_Global_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	key := InterfaceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Mpls_Global_Interface{
		InterfaceId: &InterfaceId,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceId = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	key := InterfaceId

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetInterface(InterfaceId string) *NetworkInstance_Mpls_Global_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceId

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteInterface(InterfaceId string) {
	key := InterfaceId

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Mpls_Global_Interface struct to the
// list Interface of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendInterface(v *NetworkInstance_Mpls_Global_Interface) error {
	if v.InterfaceId == nil {
		return fmt.Errorf("invalid nil key received for InterfaceId")
	}

	key := *v.InterfaceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Mpls_Global_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewReservedLabelBlock creates a new entry in the ReservedLabelBlock list of the
// NetworkInstance_Mpls_Global struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Global) NewReservedLabelBlock(LocalId string) (*NetworkInstance_Mpls_Global_ReservedLabelBlock, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	key := LocalId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ReservedLabelBlock[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ReservedLabelBlock", key)
	}

	t.ReservedLabelBlock[key] = &NetworkInstance_Mpls_Global_ReservedLabelBlock{
		LocalId: &LocalId,
	}

	return t.ReservedLabelBlock[key], nil
}

// RenameReservedLabelBlock renames an entry in the list ReservedLabelBlock within
// the NetworkInstance_Mpls_Global struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Global) RenameReservedLabelBlock(oldK, newK string) error {
	if _, ok := t.ReservedLabelBlock[newK]; ok {
		return fmt.Errorf("key %v already exists in ReservedLabelBlock", newK)
	}

	e, ok := t.ReservedLabelBlock[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ReservedLabelBlock", oldK)
	}
	e.LocalId = &newK

	t.ReservedLabelBlock[newK] = e
	delete(t.ReservedLabelBlock, oldK)
	return nil
}

// GetOrCreateReservedLabelBlock retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Global) GetOrCreateReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	key := LocalId

	if v, ok := t.ReservedLabelBlock[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewReservedLabelBlock(LocalId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateReservedLabelBlock got unexpected error: %v", err))
	}
	return v
}

// GetReservedLabelBlock retrieves the value with the specified key from
// the ReservedLabelBlock map field of NetworkInstance_Mpls_Global. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Global) GetReservedLabelBlock(LocalId string) *NetworkInstance_Mpls_Global_ReservedLabelBlock {

	if t == nil {
		return nil
	}

	key := LocalId

	if lm, ok := t.ReservedLabelBlock[key]; ok {
		return lm
	}
	return nil
}

// DeleteReservedLabelBlock deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Global. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Global) DeleteReservedLabelBlock(LocalId string) {
	key := LocalId

	delete(t.ReservedLabelBlock, key)
}

// AppendReservedLabelBlock appends the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock struct to the
// list ReservedLabelBlock of NetworkInstance_Mpls_Global. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Global_ReservedLabelBlock already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Global) AppendReservedLabelBlock(v *NetworkInstance_Mpls_Global_ReservedLabelBlock) error {
	if v.LocalId == nil {
		return fmt.Errorf("invalid nil key received for LocalId")
	}

	key := *v.LocalId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ReservedLabelBlock == nil {
		t.ReservedLabelBlock = make(map[string]*NetworkInstance_Mpls_Global_ReservedLabelBlock)
	}

	if _, ok := t.ReservedLabelBlock[key]; ok {
		return fmt.Errorf("duplicate key for list ReservedLabelBlock %v", key)
	}

	t.ReservedLabelBlock[key] = v
	return nil
}

// GetNullLabel retrieves the value of the leaf NullLabel from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NullLabel is set, it can
// safely use t.GetNullLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NullLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetNullLabel() E_MplsTypes_NULL_LABEL_TYPE {
	if t == nil || t.NullLabel == 0 {
		return MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	return t.NullLabel
}

// GetPwEncapsulation retrieves the value of the leaf PwEncapsulation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PwEncapsulation is set, it can
// safely use t.GetPwEncapsulation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PwEncapsulation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetPwEncapsulation() E_MplsTypes_PSEUDOWIRE_ENCAPSULATION {
	if t == nil || t.PwEncapsulation == 0 {
		return 0
	}
	return t.PwEncapsulation
}

// GetTtlPropagation retrieves the value of the leaf TtlPropagation from the NetworkInstance_Mpls_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TtlPropagation is set, it can
// safely use t.GetTtlPropagation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TtlPropagation == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global) GetTtlPropagation() bool {
	if t == nil || t.TtlPropagation == nil {
		return true
	}
	return *t.TtlPropagation
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NullLabel == 0 {
		t.NullLabel = MplsTypes_NULL_LABEL_TYPE_IMPLICIT
	}
	if t.TtlPropagation == nil {
		var v bool = true
		t.TtlPropagation = &v
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.ReservedLabelBlock {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global.
func (*NetworkInstance_Mpls_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Global_Interface struct {
	ΛMetadata     []ygot.Annotation                                   `path:"@" ygotAnnotation:"true"`
	InterfaceId   *string                                             `path:"config/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛInterfaceId  []ygot.Annotation                                   `path:"config/@interface-id|@interface-id" ygotAnnotation:"true"`
	InterfaceRef  *NetworkInstance_Mpls_Global_Interface_InterfaceRef `path:"interface-ref" module:"openconfig-network-instance"`
	ΛInterfaceRef []ygot.Annotation                                   `path:"@interface-ref" ygotAnnotation:"true"`
	MplsEnabled   *bool                                               `path:"config/mpls-enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMplsEnabled  []ygot.Annotation                                   `path:"config/@mpls-enabled" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Global_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Global_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Global_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Global_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetMplsEnabled retrieves the value of the leaf MplsEnabled from the NetworkInstance_Mpls_Global_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsEnabled is set, it can
// safely use t.GetMplsEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface) GetMplsEnabled() bool {
	if t == nil || t.MplsEnabled == nil {
		return false
	}
	return *t.MplsEnabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MplsEnabled == nil {
		var v bool = false
		t.MplsEnabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface.
func (*NetworkInstance_Mpls_Global_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Global_Interface_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Global_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock represents the /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block YANG schema element.
type NetworkInstance_Mpls_Global_ReservedLabelBlock struct {
	ΛMetadata   []ygot.Annotation                                               `path:"@" ygotAnnotation:"true"`
	LocalId     *string                                                         `path:"config/local-id|local-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛLocalId    []ygot.Annotation                                               `path:"config/@local-id|@local-id" ygotAnnotation:"true"`
	LowerBound  NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union `path:"config/lower-bound" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLowerBound []ygot.Annotation                                               `path:"config/@lower-bound" ygotAnnotation:"true"`
	UpperBound  NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union `path:"config/upper-bound" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUpperBound []ygot.Annotation                                               `path:"config/@upper-bound" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Global_ReservedLabelBlock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) IsYANGGoStruct() {}

// GetLocalId retrieves the value of the leaf LocalId from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalId is set, it can
// safely use t.GetLocalId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLocalId() string {
	if t == nil || t.LocalId == nil {
		return ""
	}
	return *t.LocalId
}

// GetLowerBound retrieves the value of the leaf LowerBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetLowerBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union {
	if t == nil || t.LowerBound == nil {
		return nil
	}
	return t.LowerBound
}

// GetUpperBound retrieves the value of the leaf UpperBound from the NetworkInstance_Mpls_Global_ReservedLabelBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpperBound is set, it can
// safely use t.GetUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) GetUpperBound() NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union {
	if t == nil || t.UpperBound == nil {
		return nil
	}
	return t.UpperBound
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Global_ReservedLabelBlock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Global_ReservedLabelBlock struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalId == nil {
		return nil, fmt.Errorf("nil value for key LocalId")
	}

	return map[string]interface{}{
		"local-id": *t.LocalId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Global_ReservedLabelBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Global_ReservedLabelBlock.
func (*NetworkInstance_Mpls_Global_ReservedLabelBlock) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface YANG schema element.
type NetworkInstance_Mpls_Interface struct {
	ΛMetadata             []ygot.Annotation                                    `path:"@" ygotAnnotation:"true"`
	AdminGroup            []string                                             `path:"config/admin-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAdminGroup           []ygot.Annotation                                    `path:"config/@admin-group" ygotAnnotation:"true"`
	IgpFloodingBandwidth  *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth `path:"igp-flooding-bandwidth" module:"openconfig-network-instance"`
	ΛIgpFloodingBandwidth []ygot.Annotation                                    `path:"@igp-flooding-bandwidth" ygotAnnotation:"true"`
	InterfaceId           *string                                              `path:"config/interface-id|interface-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛInterfaceId          []ygot.Annotation                                    `path:"config/@interface-id|@interface-id" ygotAnnotation:"true"`
	InterfaceRef          *NetworkInstance_Mpls_Interface_InterfaceRef         `path:"interface-ref" module:"openconfig-network-instance"`
	ΛInterfaceRef         []ygot.Annotation                                    `path:"@interface-ref" ygotAnnotation:"true"`
	SrlgMembership        []string                                             `path:"config/srlg-membership" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSrlgMembership       []ygot.Annotation                                    `path:"config/@srlg-membership" ygotAnnotation:"true"`
	TeMetric              *uint32                                              `path:"config/te-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTeMetric             []ygot.Annotation                                    `path:"config/@te-metric" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface) IsYANGGoStruct() {}

// GetOrCreateIgpFloodingBandwidth retrieves the value of the IgpFloodingBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	t.IgpFloodingBandwidth = &NetworkInstance_Mpls_Interface_IgpFloodingBandwidth{}
	return t.IgpFloodingBandwidth
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Interface) GetOrCreateInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Mpls_Interface_InterfaceRef{}
	return t.InterfaceRef
}

// GetIgpFloodingBandwidth returns the value of the IgpFloodingBandwidth struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field IgpFloodingBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetIgpFloodingBandwidth() *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth {
	if t != nil && t.IgpFloodingBandwidth != nil {
		return t.IgpFloodingBandwidth
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Mpls_Interface. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceRef() *NetworkInstance_Mpls_Interface_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceId retrieves the value of the leaf InterfaceId from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceId is set, it can
// safely use t.GetInterfaceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetInterfaceId() string {
	if t == nil || t.InterfaceId == nil {
		return ""
	}
	return *t.InterfaceId
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the NetworkInstance_Mpls_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IgpFloodingBandwidth.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Interface struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceId == nil {
		return nil, fmt.Errorf("nil value for key InterfaceId")
	}

	return map[string]interface{}{
		"interface-id": *t.InterfaceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface.
func (*NetworkInstance_Mpls_Interface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_IgpFloodingBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/igp-flooding-bandwidth YANG schema element.
type NetworkInstance_Mpls_Interface_IgpFloodingBandwidth struct {
	ΛMetadata               []ygot.Annotation                             `path:"@" ygotAnnotation:"true"`
	DeltaPercentage         *uint8                                        `path:"config/delta-percentage" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDeltaPercentage        []ygot.Annotation                             `path:"config/@delta-percentage" ygotAnnotation:"true"`
	DownThresholds          []uint8                                       `path:"config/down-thresholds" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDownThresholds         []ygot.Annotation                             `path:"config/@down-thresholds" ygotAnnotation:"true"`
	ThresholdSpecification  E_IgpFloodingBandwidth_ThresholdSpecification `path:"config/threshold-specification" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛThresholdSpecification []ygot.Annotation                             `path:"config/@threshold-specification" ygotAnnotation:"true"`
	ThresholdType           E_IgpFloodingBandwidth_ThresholdType          `path:"config/threshold-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛThresholdType          []ygot.Annotation                             `path:"config/@threshold-type" ygotAnnotation:"true"`
	UpDownThresholds        []uint8                                       `path:"config/up-down-thresholds" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUpDownThresholds       []ygot.Annotation                             `path:"config/@up-down-thresholds" ygotAnnotation:"true"`
	UpThresholds            []uint8                                       `path:"config/up-thresholds" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUpThresholds           []ygot.Annotation                             `path:"config/@up-thresholds" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_IgpFloodingBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) IsYANGGoStruct() {}

// GetDeltaPercentage retrieves the value of the leaf DeltaPercentage from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeltaPercentage is set, it can
// safely use t.GetDeltaPercentage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeltaPercentage == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDeltaPercentage() uint8 {
	if t == nil || t.DeltaPercentage == nil {
		return 0
	}
	return *t.DeltaPercentage
}

// GetDownThresholds retrieves the value of the leaf DownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DownThresholds is set, it can
// safely use t.GetDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetDownThresholds() []uint8 {
	if t == nil || t.DownThresholds == nil {
		return nil
	}
	return t.DownThresholds
}

// GetThresholdSpecification retrieves the value of the leaf ThresholdSpecification from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdSpecification is set, it can
// safely use t.GetThresholdSpecification() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdSpecification == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdSpecification() E_IgpFloodingBandwidth_ThresholdSpecification {
	if t == nil || t.ThresholdSpecification == 0 {
		return 0
	}
	return t.ThresholdSpecification
}

// GetThresholdType retrieves the value of the leaf ThresholdType from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ThresholdType is set, it can
// safely use t.GetThresholdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ThresholdType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetThresholdType() E_IgpFloodingBandwidth_ThresholdType {
	if t == nil || t.ThresholdType == 0 {
		return 0
	}
	return t.ThresholdType
}

// GetUpDownThresholds retrieves the value of the leaf UpDownThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpDownThresholds is set, it can
// safely use t.GetUpDownThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpDownThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpDownThresholds() []uint8 {
	if t == nil || t.UpDownThresholds == nil {
		return nil
	}
	return t.UpDownThresholds
}

// GetUpThresholds retrieves the value of the leaf UpThresholds from the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpThresholds is set, it can
// safely use t.GetUpThresholds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpThresholds == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) GetUpThresholds() []uint8 {
	if t == nil || t.UpThresholds == nil {
		return nil
	}
	return t.UpThresholds
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_IgpFloodingBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_IgpFloodingBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_IgpFloodingBandwidth.
func (*NetworkInstance_Mpls_Interface_IgpFloodingBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Interface_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/mpls/te-interface-attributes/interface/interface-ref YANG schema element.
type NetworkInstance_Mpls_Interface_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Interface_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Mpls_Interface_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Interface_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Interface_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Interface_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Interface_InterfaceRef.
func (*NetworkInstance_Mpls_Interface_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps YANG schema element.
type NetworkInstance_Mpls_Lsps struct {
	ΛMetadata          []ygot.Annotation                               `path:"@" ygotAnnotation:"true"`
	ConstrainedPath    *NetworkInstance_Mpls_Lsps_ConstrainedPath      `path:"constrained-path" module:"openconfig-network-instance"`
	ΛConstrainedPath   []ygot.Annotation                               `path:"@constrained-path" ygotAnnotation:"true"`
	StaticLsp          map[string]*NetworkInstance_Mpls_Lsps_StaticLsp `path:"static-lsps/static-lsp" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛStaticLsp         []ygot.Annotation                               `path:"static-lsps/@static-lsp" ygotAnnotation:"true"`
	UnconstrainedPath  *NetworkInstance_Mpls_Lsps_UnconstrainedPath    `path:"unconstrained-path" module:"openconfig-network-instance"`
	ΛUnconstrainedPath []ygot.Annotation                               `path:"@unconstrained-path" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps) IsYANGGoStruct() {}

// NewStaticLsp creates a new entry in the StaticLsp list of the
// NetworkInstance_Mpls_Lsps struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps) NewStaticLsp(Name string) (*NetworkInstance_Mpls_Lsps_StaticLsp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticLsp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticLsp", key)
	}

	t.StaticLsp[key] = &NetworkInstance_Mpls_Lsps_StaticLsp{
		Name: &Name,
	}

	return t.StaticLsp[key], nil
}

// RenameStaticLsp renames an entry in the list StaticLsp within
// the NetworkInstance_Mpls_Lsps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps) RenameStaticLsp(oldK, newK string) error {
	if _, ok := t.StaticLsp[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticLsp", newK)
	}

	e, ok := t.StaticLsp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticLsp", oldK)
	}
	e.Name = &newK

	t.StaticLsp[newK] = e
	delete(t.StaticLsp, oldK)
	return nil
}

// GetOrCreateStaticLsp retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	key := Name

	if v, ok := t.StaticLsp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticLsp(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticLsp got unexpected error: %v", err))
	}
	return v
}

// GetStaticLsp retrieves the value with the specified key from
// the StaticLsp map field of NetworkInstance_Mpls_Lsps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetStaticLsp(Name string) *NetworkInstance_Mpls_Lsps_StaticLsp {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticLsp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticLsp deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps) DeleteStaticLsp(Name string) {
	key := Name

	delete(t.StaticLsp, key)
}

// AppendStaticLsp appends the supplied NetworkInstance_Mpls_Lsps_StaticLsp struct to the
// list StaticLsp of NetworkInstance_Mpls_Lsps. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_StaticLsp already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps) AppendStaticLsp(v *NetworkInstance_Mpls_Lsps_StaticLsp) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticLsp == nil {
		t.StaticLsp = make(map[string]*NetworkInstance_Mpls_Lsps_StaticLsp)
	}

	if _, ok := t.StaticLsp[key]; ok {
		return fmt.Errorf("duplicate key for list StaticLsp %v", key)
	}

	t.StaticLsp[key] = v
	return nil
}

// GetOrCreateConstrainedPath retrieves the value of the ConstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	t.ConstrainedPath = &NetworkInstance_Mpls_Lsps_ConstrainedPath{}
	return t.ConstrainedPath
}

// GetOrCreateUnconstrainedPath retrieves the value of the UnconstrainedPath field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps) GetOrCreateUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	t.UnconstrainedPath = &NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	return t.UnconstrainedPath
}

// GetConstrainedPath returns the value of the ConstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field ConstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetConstrainedPath() *NetworkInstance_Mpls_Lsps_ConstrainedPath {
	if t != nil && t.ConstrainedPath != nil {
		return t.ConstrainedPath
	}
	return nil
}

// GetUnconstrainedPath returns the value of the UnconstrainedPath struct pointer
// from NetworkInstance_Mpls_Lsps. If the receiver or the field UnconstrainedPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps) GetUnconstrainedPath() *NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	if t != nil && t.UnconstrainedPath != nil {
		return t.UnconstrainedPath
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ConstrainedPath.PopulateDefaults()
	t.UnconstrainedPath.PopulateDefaults()
	for _, e := range t.StaticLsp {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps.
func (*NetworkInstance_Mpls_Lsps) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath struct {
	ΛMetadata          []ygot.Annotation                                                       `path:"@" ygotAnnotation:"true"`
	NamedExplicitPath  map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath `path:"named-explicit-paths/named-explicit-path" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNamedExplicitPath []ygot.Annotation                                                       `path:"named-explicit-paths/@named-explicit-path" ygotAnnotation:"true"`
	Tunnel             map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel            `path:"tunnels/tunnel" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTunnel            []ygot.Annotation                                                       `path:"tunnels/@tunnel" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) IsYANGGoStruct() {}

// NewNamedExplicitPath creates a new entry in the NamedExplicitPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewNamedExplicitPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NamedExplicitPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NamedExplicitPath", key)
	}

	t.NamedExplicitPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath{
		Name: &Name,
	}

	return t.NamedExplicitPath[key], nil
}

// RenameNamedExplicitPath renames an entry in the list NamedExplicitPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameNamedExplicitPath(oldK, newK string) error {
	if _, ok := t.NamedExplicitPath[newK]; ok {
		return fmt.Errorf("key %v already exists in NamedExplicitPath", newK)
	}

	e, ok := t.NamedExplicitPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NamedExplicitPath", oldK)
	}
	e.Name = &newK

	t.NamedExplicitPath[newK] = e
	delete(t.NamedExplicitPath, oldK)
	return nil
}

// GetOrCreateNamedExplicitPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	key := Name

	if v, ok := t.NamedExplicitPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNamedExplicitPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNamedExplicitPath got unexpected error: %v", err))
	}
	return v
}

// GetNamedExplicitPath retrieves the value with the specified key from
// the NamedExplicitPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetNamedExplicitPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NamedExplicitPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteNamedExplicitPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteNamedExplicitPath(Name string) {
	key := Name

	delete(t.NamedExplicitPath, key)
}

// AppendNamedExplicitPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct to the
// list NamedExplicitPath of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendNamedExplicitPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NamedExplicitPath == nil {
		t.NamedExplicitPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath)
	}

	if _, ok := t.NamedExplicitPath[key]; ok {
		return fmt.Errorf("duplicate key for list NamedExplicitPath %v", key)
	}

	t.NamedExplicitPath[key] = v
	return nil
}

// NewTunnel creates a new entry in the Tunnel list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) NewTunnel(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tunnel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tunnel", key)
	}

	t.Tunnel[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{
		Name: &Name,
	}

	return t.Tunnel[key], nil
}

// RenameTunnel renames an entry in the list Tunnel within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) RenameTunnel(oldK, newK string) error {
	if _, ok := t.Tunnel[newK]; ok {
		return fmt.Errorf("key %v already exists in Tunnel", newK)
	}

	e, ok := t.Tunnel[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tunnel", oldK)
	}
	e.Name = &newK

	t.Tunnel[newK] = e
	delete(t.Tunnel, oldK)
	return nil
}

// GetOrCreateTunnel retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetOrCreateTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	key := Name

	if v, ok := t.Tunnel[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnel(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnel got unexpected error: %v", err))
	}
	return v
}

// GetTunnel retrieves the value with the specified key from
// the Tunnel map field of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) GetTunnel(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Tunnel[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnel deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) DeleteTunnel(Name string) {
	key := Name

	delete(t.Tunnel, key)
}

// AppendTunnel appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct to the
// list Tunnel of NetworkInstance_Mpls_Lsps_ConstrainedPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) AppendTunnel(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tunnel == nil {
		t.Tunnel = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel)
	}

	if _, ok := t.Tunnel[key]; ok {
		return fmt.Errorf("duplicate key for list Tunnel %v", key)
	}

	t.Tunnel[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NamedExplicitPath {
		e.PopulateDefaults()
	}
	for _, e := range t.Tunnel {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct {
	ΛMetadata              []ygot.Annotation                                                                          `path:"@" ygotAnnotation:"true"`
	ExplicitRouteObject    map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject `path:"explicit-route-objects/explicit-route-object" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExplicitRouteObject   []ygot.Annotation                                                                          `path:"explicit-route-objects/@explicit-route-object" ygotAnnotation:"true"`
	Name                   *string                                                                                    `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName                  []ygot.Annotation                                                                          `path:"config/@name|@name" ygotAnnotation:"true"`
	SidProtectionRequired  *bool                                                                                      `path:"config/sid-protection-required" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSidProtectionRequired []ygot.Annotation                                                                          `path:"config/@sid-protection-required" ygotAnnotation:"true"`
	SidSelectionMode       E_NamedExplicitPath_SidSelectionMode                                                       `path:"config/sid-selection-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSidSelectionMode      []ygot.Annotation                                                                          `path:"config/@sid-selection-mode" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) IsYANGGoStruct() {}

// NewExplicitRouteObject creates a new entry in the ExplicitRouteObject list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) NewExplicitRouteObject(Index uint8) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ExplicitRouteObject[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ExplicitRouteObject", key)
	}

	t.ExplicitRouteObject[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject{
		Index: &Index,
	}

	return t.ExplicitRouteObject[key], nil
}

// RenameExplicitRouteObject renames an entry in the list ExplicitRouteObject within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) RenameExplicitRouteObject(oldK, newK uint8) error {
	if _, ok := t.ExplicitRouteObject[newK]; ok {
		return fmt.Errorf("key %v already exists in ExplicitRouteObject", newK)
	}

	e, ok := t.ExplicitRouteObject[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ExplicitRouteObject", oldK)
	}
	e.Index = &newK

	t.ExplicitRouteObject[newK] = e
	delete(t.ExplicitRouteObject, oldK)
	return nil
}

// GetOrCreateExplicitRouteObject retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetOrCreateExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	key := Index

	if v, ok := t.ExplicitRouteObject[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewExplicitRouteObject(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateExplicitRouteObject got unexpected error: %v", err))
	}
	return v
}

// GetExplicitRouteObject retrieves the value with the specified key from
// the ExplicitRouteObject map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetExplicitRouteObject(Index uint8) *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.ExplicitRouteObject[key]; ok {
		return lm
	}
	return nil
}

// DeleteExplicitRouteObject deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) DeleteExplicitRouteObject(Index uint8) {
	key := Index

	delete(t.ExplicitRouteObject, key)
}

// AppendExplicitRouteObject appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct to the
// list ExplicitRouteObject of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) AppendExplicitRouteObject(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ExplicitRouteObject == nil {
		t.ExplicitRouteObject = make(map[uint8]*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject)
	}

	if _, ok := t.ExplicitRouteObject[key]; ok {
		return fmt.Errorf("duplicate key for list ExplicitRouteObject %v", key)
	}

	t.ExplicitRouteObject[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSidProtectionRequired retrieves the value of the leaf SidProtectionRequired from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidProtectionRequired is set, it can
// safely use t.GetSidProtectionRequired() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidProtectionRequired == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidProtectionRequired() bool {
	if t == nil || t.SidProtectionRequired == nil {
		return false
	}
	return *t.SidProtectionRequired
}

// GetSidSelectionMode retrieves the value of the leaf SidSelectionMode from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidSelectionMode is set, it can
// safely use t.GetSidSelectionMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidSelectionMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) GetSidSelectionMode() E_NamedExplicitPath_SidSelectionMode {
	if t == nil || t.SidSelectionMode == 0 {
		return NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	return t.SidSelectionMode
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SidProtectionRequired == nil {
		var v bool = false
		t.SidProtectionRequired = &v
	}
	if t.SidSelectionMode == 0 {
		t.SidSelectionMode = NamedExplicitPath_SidSelectionMode_MIXED_MODE
	}
	for _, e := range t.ExplicitRouteObject {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/named-explicit-paths/named-explicit-path/explicit-route-objects/explicit-route-object YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct {
	ΛMetadata []ygot.Annotation  `path:"@" ygotAnnotation:"true"`
	Address   *string            `path:"config/address" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAddress  []ygot.Annotation  `path:"config/@address" ygotAnnotation:"true"`
	HopType   E_Mpls_MplsHopType `path:"config/hop-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛHopType  []ygot.Annotation  `path:"config/@hop-type" ygotAnnotation:"true"`
	Index     *uint8             `path:"config/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex    []ygot.Annotation  `path:"config/@index|@index" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetHopType retrieves the value of the leaf HopType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopType is set, it can
// safely use t.GetHopType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetHopType() E_Mpls_MplsHopType {
	if t == nil || t.HopType == 0 {
		return 0
	}
	return t.HopType
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_NamedExplicitPath_ExplicitRouteObject) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct {
	ΛMetadata                 []ygot.Annotation                                                     `path:"@" ygotAnnotation:"true"`
	AdminStatus               E_MplsTypes_TUNNEL_ADMIN_STATUS                                       `path:"config/admin-status" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAdminStatus              []ygot.Annotation                                                     `path:"config/@admin-status" ygotAnnotation:"true"`
	AutoGenerated             *bool                                                                 `path:"state/auto-generated" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAutoGenerated            []ygot.Annotation                                                     `path:"state/@auto-generated" ygotAnnotation:"true"`
	Bandwidth                 *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth           `path:"bandwidth" module:"openconfig-network-instance"`
	ΛBandwidth                []ygot.Annotation                                                     `path:"@bandwidth" ygotAnnotation:"true"`
	Counters                  *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters            `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                 []ygot.Annotation                                                     `path:"state/@counters" ygotAnnotation:"true"`
	Description               *string                                                               `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDescription              []ygot.Annotation                                                     `path:"config/@description" ygotAnnotation:"true"`
	HoldPriority              *uint8                                                                `path:"config/hold-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛHoldPriority             []ygot.Annotation                                                     `path:"config/@hold-priority" ygotAnnotation:"true"`
	Metric                    *int32                                                                `path:"config/metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMetric                   []ygot.Annotation                                                     `path:"config/@metric" ygotAnnotation:"true"`
	MetricType                E_MplsTypes_LSP_METRIC_TYPE                                           `path:"config/metric-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMetricType               []ygot.Annotation                                                     `path:"config/@metric-type" ygotAnnotation:"true"`
	Name                      *string                                                               `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName                     []ygot.Annotation                                                     `path:"config/@name|@name" ygotAnnotation:"true"`
	OperStatus                E_MplsTypes_LSP_OPER_STATUS                                           `path:"state/oper-status" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOperStatus               []ygot.Annotation                                                     `path:"state/@oper-status" ygotAnnotation:"true"`
	P2PTunnelAttributes       *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes `path:"p2p-tunnel-attributes" module:"openconfig-network-instance"`
	ΛP2PTunnelAttributes      []ygot.Annotation                                                     `path:"@p2p-tunnel-attributes" ygotAnnotation:"true"`
	Preference                *uint8                                                                `path:"config/preference" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPreference               []ygot.Annotation                                                     `path:"config/@preference" ygotAnnotation:"true"`
	ProtectionStyleRequested  E_MplsTypes_PROTECTION_TYPE                                           `path:"config/protection-style-requested" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProtectionStyleRequested []ygot.Annotation                                                     `path:"config/@protection-style-requested" ygotAnnotation:"true"`
	ReoptimizeTimer           *uint16                                                               `path:"config/reoptimize-timer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛReoptimizeTimer          []ygot.Annotation                                                     `path:"config/@reoptimize-timer" ygotAnnotation:"true"`
	Role                      E_MplsTypes_LSP_ROLE                                                  `path:"state/role" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRole                     []ygot.Annotation                                                     `path:"state/@role" ygotAnnotation:"true"`
	SetupPriority             *uint8                                                                `path:"config/setup-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSetupPriority            []ygot.Annotation                                                     `path:"config/@setup-priority" ygotAnnotation:"true"`
	ShortcutEligible          *bool                                                                 `path:"config/shortcut-eligible" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛShortcutEligible         []ygot.Annotation                                                     `path:"config/@shortcut-eligible" ygotAnnotation:"true"`
	SignalingProtocol         E_MplsTypes_PATH_SETUP_PROTOCOL                                       `path:"config/signaling-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSignalingProtocol        []ygot.Annotation                                                     `path:"config/@signaling-protocol" ygotAnnotation:"true"`
	SoftPreemption            *bool                                                                 `path:"config/soft-preemption" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSoftPreemption           []ygot.Annotation                                                     `path:"config/@soft-preemption" ygotAnnotation:"true"`
	Source                    *string                                                               `path:"config/source" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSource                   []ygot.Annotation                                                     `path:"config/@source" ygotAnnotation:"true"`
	Type                      E_MplsTypes_TUNNEL_TYPE                                               `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛType                     []ygot.Annotation                                                     `path:"config/@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) IsYANGGoStruct() {}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	return t.Counters
}

// GetOrCreateP2PTunnelAttributes retrieves the value of the P2PTunnelAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOrCreateP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	t.P2PTunnelAttributes = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	return t.P2PTunnelAttributes
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetCounters() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetP2PTunnelAttributes returns the value of the P2PTunnelAttributes struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel. If the receiver or the field P2PTunnelAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetP2PTunnelAttributes() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	if t != nil && t.P2PTunnelAttributes != nil {
		return t.P2PTunnelAttributes
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAdminStatus() E_MplsTypes_TUNNEL_ADMIN_STATUS {
	if t == nil || t.AdminStatus == 0 {
		return MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	return t.AdminStatus
}

// GetAutoGenerated retrieves the value of the leaf AutoGenerated from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoGenerated is set, it can
// safely use t.GetAutoGenerated() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoGenerated == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetAutoGenerated() bool {
	if t == nil || t.AutoGenerated == nil {
		return false
	}
	return *t.AutoGenerated
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetMetric retrieves the value of the leaf Metric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetric() int32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetMetricType retrieves the value of the leaf MetricType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricType is set, it can
// safely use t.GetMetricType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetMetricType() E_MplsTypes_LSP_METRIC_TYPE {
	if t == nil || t.MetricType == 0 {
		return MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	return t.MetricType
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetOperStatus() E_MplsTypes_LSP_OPER_STATUS {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetProtectionStyleRequested retrieves the value of the leaf ProtectionStyleRequested from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionStyleRequested is set, it can
// safely use t.GetProtectionStyleRequested() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionStyleRequested == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetProtectionStyleRequested() E_MplsTypes_PROTECTION_TYPE {
	if t == nil || t.ProtectionStyleRequested == 0 {
		return MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	return t.ProtectionStyleRequested
}

// GetReoptimizeTimer retrieves the value of the leaf ReoptimizeTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReoptimizeTimer is set, it can
// safely use t.GetReoptimizeTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReoptimizeTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetReoptimizeTimer() uint16 {
	if t == nil || t.ReoptimizeTimer == nil {
		return 0
	}
	return *t.ReoptimizeTimer
}

// GetRole retrieves the value of the leaf Role from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Role is set, it can
// safely use t.GetRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Role == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetRole() E_MplsTypes_LSP_ROLE {
	if t == nil || t.Role == 0 {
		return 0
	}
	return t.Role
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetShortcutEligible retrieves the value of the leaf ShortcutEligible from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShortcutEligible is set, it can
// safely use t.GetShortcutEligible() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShortcutEligible == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetShortcutEligible() bool {
	if t == nil || t.ShortcutEligible == nil {
		return true
	}
	return *t.ShortcutEligible
}

// GetSignalingProtocol retrieves the value of the leaf SignalingProtocol from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignalingProtocol is set, it can
// safely use t.GetSignalingProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignalingProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSignalingProtocol() E_MplsTypes_PATH_SETUP_PROTOCOL {
	if t == nil || t.SignalingProtocol == 0 {
		return 0
	}
	return t.SignalingProtocol
}

// GetSoftPreemption retrieves the value of the leaf SoftPreemption from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftPreemption is set, it can
// safely use t.GetSoftPreemption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftPreemption == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSoftPreemption() bool {
	if t == nil || t.SoftPreemption == nil {
		return false
	}
	return *t.SoftPreemption
}

// GetSource retrieves the value of the leaf Source from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Source is set, it can
// safely use t.GetSource() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Source == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetSource() string {
	if t == nil || t.Source == nil {
		return ""
	}
	return *t.Source
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) GetType() E_MplsTypes_TUNNEL_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminStatus == 0 {
		t.AdminStatus = MplsTypes_TUNNEL_ADMIN_STATUS_ADMIN_UP
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.MetricType == 0 {
		t.MetricType = MplsTypes_LSP_METRIC_TYPE_LSP_METRIC_INHERITED
	}
	if t.ProtectionStyleRequested == 0 {
		t.ProtectionStyleRequested = MplsTypes_PROTECTION_TYPE_UNPROTECTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	if t.ShortcutEligible == nil {
		var v bool = true
		t.ShortcutEligible = &v
	}
	if t.SoftPreemption == nil {
		var v bool = false
		t.SoftPreemption = &v
	}
	t.Bandwidth.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.P2PTunnelAttributes.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth struct {
	ΛMetadata          []ygot.Annotation                                                         `path:"@" ygotAnnotation:"true"`
	AutoBandwidth      *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth `path:"auto-bandwidth" module:"openconfig-network-instance"`
	ΛAutoBandwidth     []ygot.Annotation                                                         `path:"@auto-bandwidth" ygotAnnotation:"true"`
	SetBandwidth       *uint64                                                                   `path:"config/set-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSetBandwidth      []ygot.Annotation                                                         `path:"config/@set-bandwidth" ygotAnnotation:"true"`
	SignaledBandwidth  *uint64                                                                   `path:"state/signaled-bandwidth" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSignaledBandwidth []ygot.Annotation                                                         `path:"state/@signaled-bandwidth" ygotAnnotation:"true"`
	SpecificationType  E_Mpls_TeBandwidthType                                                    `path:"config/specification-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSpecificationType []ygot.Annotation                                                         `path:"config/@specification-type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) IsYANGGoStruct() {}

// GetOrCreateAutoBandwidth retrieves the value of the AutoBandwidth field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetOrCreateAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	t.AutoBandwidth = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth{}
	return t.AutoBandwidth
}

// GetAutoBandwidth returns the value of the AutoBandwidth struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth. If the receiver or the field AutoBandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetAutoBandwidth() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth {
	if t != nil && t.AutoBandwidth != nil {
		return t.AutoBandwidth
	}
	return nil
}

// GetSetBandwidth retrieves the value of the leaf SetBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBandwidth is set, it can
// safely use t.GetSetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSetBandwidth() uint64 {
	if t == nil || t.SetBandwidth == nil {
		return 0
	}
	return *t.SetBandwidth
}

// GetSignaledBandwidth retrieves the value of the leaf SignaledBandwidth from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignaledBandwidth is set, it can
// safely use t.GetSignaledBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignaledBandwidth == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSignaledBandwidth() uint64 {
	if t == nil || t.SignaledBandwidth == nil {
		return 0
	}
	return *t.SignaledBandwidth
}

// GetSpecificationType retrieves the value of the leaf SpecificationType from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpecificationType is set, it can
// safely use t.GetSpecificationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpecificationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) GetSpecificationType() E_Mpls_TeBandwidthType {
	if t == nil || t.SpecificationType == 0 {
		return Mpls_TeBandwidthType_SPECIFIED
	}
	return t.SpecificationType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SpecificationType == 0 {
		t.SpecificationType = Mpls_TeBandwidthType_SPECIFIED
	}
	t.AutoBandwidth.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth struct {
	ΛMetadata        []ygot.Annotation                                                                   `path:"@" ygotAnnotation:"true"`
	AdjustInterval   *uint32                                                                             `path:"config/adjust-interval" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAdjustInterval  []ygot.Annotation                                                                   `path:"config/@adjust-interval" ygotAnnotation:"true"`
	AdjustThreshold  *uint8                                                                              `path:"config/adjust-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAdjustThreshold []ygot.Annotation                                                                   `path:"config/@adjust-threshold" ygotAnnotation:"true"`
	Enabled          *bool                                                                               `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnabled         []ygot.Annotation                                                                   `path:"config/@enabled" ygotAnnotation:"true"`
	IntervalHighBw   *uint64                                                                             `path:"state/interval-high-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIntervalHighBw  []ygot.Annotation                                                                   `path:"state/@interval-high-bw" ygotAnnotation:"true"`
	MaxBw            *uint64                                                                             `path:"config/max-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMaxBw           []ygot.Annotation                                                                   `path:"config/@max-bw" ygotAnnotation:"true"`
	MinBw            *uint64                                                                             `path:"config/min-bw" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMinBw           []ygot.Annotation                                                                   `path:"config/@min-bw" ygotAnnotation:"true"`
	Overflow         *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow  `path:"overflow" module:"openconfig-network-instance"`
	ΛOverflow        []ygot.Annotation                                                                   `path:"@overflow" ygotAnnotation:"true"`
	Underflow        *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow `path:"underflow" module:"openconfig-network-instance"`
	ΛUnderflow       []ygot.Annotation                                                                   `path:"@underflow" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) IsYANGGoStruct() {}

// GetOrCreateOverflow retrieves the value of the Overflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t.Overflow != nil {
		return t.Overflow
	}
	t.Overflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow{}
	return t.Overflow
}

// GetOrCreateUnderflow retrieves the value of the Underflow field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOrCreateUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t.Underflow != nil {
		return t.Underflow
	}
	t.Underflow = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow{}
	return t.Underflow
}

// GetOverflow returns the value of the Overflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Overflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetOverflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow {
	if t != nil && t.Overflow != nil {
		return t.Overflow
	}
	return nil
}

// GetUnderflow returns the value of the Underflow struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth. If the receiver or the field Underflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetUnderflow() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow {
	if t != nil && t.Underflow != nil {
		return t.Underflow
	}
	return nil
}

// GetAdjustInterval retrieves the value of the leaf AdjustInterval from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustInterval is set, it can
// safely use t.GetAdjustInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustInterval() uint32 {
	if t == nil || t.AdjustInterval == nil {
		return 0
	}
	return *t.AdjustInterval
}

// GetAdjustThreshold retrieves the value of the leaf AdjustThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdjustThreshold is set, it can
// safely use t.GetAdjustThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdjustThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetAdjustThreshold() uint8 {
	if t == nil || t.AdjustThreshold == nil {
		return 0
	}
	return *t.AdjustThreshold
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetIntervalHighBw retrieves the value of the leaf IntervalHighBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalHighBw is set, it can
// safely use t.GetIntervalHighBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalHighBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetIntervalHighBw() uint64 {
	if t == nil || t.IntervalHighBw == nil {
		return 0
	}
	return *t.IntervalHighBw
}

// GetMaxBw retrieves the value of the leaf MaxBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxBw is set, it can
// safely use t.GetMaxBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMaxBw() uint64 {
	if t == nil || t.MaxBw == nil {
		return 0
	}
	return *t.MaxBw
}

// GetMinBw retrieves the value of the leaf MinBw from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinBw is set, it can
// safely use t.GetMinBw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinBw == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) GetMinBw() uint64 {
	if t == nil || t.MinBw == nil {
		return 0
	}
	return *t.MinBw
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.Overflow.PopulateDefaults()
	t.Underflow.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/overflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow struct {
	ΛMetadata          []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Enabled            *bool             `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnabled           []ygot.Annotation `path:"config/@enabled" ygotAnnotation:"true"`
	OverflowThreshold  *uint8            `path:"config/overflow-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOverflowThreshold []ygot.Annotation `path:"config/@overflow-threshold" ygotAnnotation:"true"`
	TriggerEventCount  *uint16           `path:"config/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTriggerEventCount []ygot.Annotation `path:"config/@trigger-event-count" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetOverflowThreshold retrieves the value of the leaf OverflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverflowThreshold is set, it can
// safely use t.GetOverflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetOverflowThreshold() uint8 {
	if t == nil || t.OverflowThreshold == nil {
		return 0
	}
	return *t.OverflowThreshold
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Overflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/bandwidth/auto-bandwidth/underflow YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Enabled             *bool             `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnabled            []ygot.Annotation `path:"config/@enabled" ygotAnnotation:"true"`
	TriggerEventCount   *uint16           `path:"config/trigger-event-count" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTriggerEventCount  []ygot.Annotation `path:"config/@trigger-event-count" ygotAnnotation:"true"`
	UnderflowThreshold  *uint8            `path:"config/underflow-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUnderflowThreshold []ygot.Annotation `path:"config/@underflow-threshold" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) IsYANGGoStruct() {
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetTriggerEventCount retrieves the value of the leaf TriggerEventCount from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TriggerEventCount is set, it can
// safely use t.GetTriggerEventCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TriggerEventCount == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetTriggerEventCount() uint16 {
	if t == nil || t.TriggerEventCount == nil {
		return 0
	}
	return *t.TriggerEventCount
}

// GetUnderflowThreshold retrieves the value of the leaf UnderflowThreshold from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnderflowThreshold is set, it can
// safely use t.GetUnderflowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnderflowThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) GetUnderflowThreshold() uint8 {
	if t == nil || t.UnderflowThreshold == nil {
		return 0
	}
	return *t.UnderflowThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Bandwidth_AutoBandwidth_Underflow) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters struct {
	ΛMetadata               []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Bytes                   *uint64           `path:"bytes" module:"openconfig-network-instance"`
	ΛBytes                  []ygot.Annotation `path:"@bytes" ygotAnnotation:"true"`
	CurrentPathTime         *uint64           `path:"current-path-time" module:"openconfig-network-instance"`
	ΛCurrentPathTime        []ygot.Annotation `path:"@current-path-time" ygotAnnotation:"true"`
	NextReoptimizationTime  *uint64           `path:"next-reoptimization-time" module:"openconfig-network-instance"`
	ΛNextReoptimizationTime []ygot.Annotation `path:"@next-reoptimization-time" ygotAnnotation:"true"`
	OnlineTime              *uint64           `path:"online-time" module:"openconfig-network-instance"`
	ΛOnlineTime             []ygot.Annotation `path:"@online-time" ygotAnnotation:"true"`
	Packets                 *uint64           `path:"packets" module:"openconfig-network-instance"`
	ΛPackets                []ygot.Annotation `path:"@packets" ygotAnnotation:"true"`
	PathChanges             *uint64           `path:"path-changes" module:"openconfig-network-instance"`
	ΛPathChanges            []ygot.Annotation `path:"@path-changes" ygotAnnotation:"true"`
	StateChanges            *uint64           `path:"state-changes" module:"openconfig-network-instance"`
	ΛStateChanges           []ygot.Annotation `path:"@state-changes" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) IsYANGGoStruct() {}

// GetBytes retrieves the value of the leaf Bytes from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bytes is set, it can
// safely use t.GetBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bytes == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetBytes() uint64 {
	if t == nil || t.Bytes == nil {
		return 0
	}
	return *t.Bytes
}

// GetCurrentPathTime retrieves the value of the leaf CurrentPathTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPathTime is set, it can
// safely use t.GetCurrentPathTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPathTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetCurrentPathTime() uint64 {
	if t == nil || t.CurrentPathTime == nil {
		return 0
	}
	return *t.CurrentPathTime
}

// GetNextReoptimizationTime retrieves the value of the leaf NextReoptimizationTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextReoptimizationTime is set, it can
// safely use t.GetNextReoptimizationTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextReoptimizationTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetNextReoptimizationTime() uint64 {
	if t == nil || t.NextReoptimizationTime == nil {
		return 0
	}
	return *t.NextReoptimizationTime
}

// GetOnlineTime retrieves the value of the leaf OnlineTime from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OnlineTime is set, it can
// safely use t.GetOnlineTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OnlineTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetOnlineTime() uint64 {
	if t == nil || t.OnlineTime == nil {
		return 0
	}
	return *t.OnlineTime
}

// GetPackets retrieves the value of the leaf Packets from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Packets is set, it can
// safely use t.GetPackets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Packets == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPackets() uint64 {
	if t == nil || t.Packets == nil {
		return 0
	}
	return *t.Packets
}

// GetPathChanges retrieves the value of the leaf PathChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathChanges is set, it can
// safely use t.GetPathChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetPathChanges() uint64 {
	if t == nil || t.PathChanges == nil {
		return 0
	}
	return *t.PathChanges
}

// GetStateChanges retrieves the value of the leaf StateChanges from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StateChanges is set, it can
// safely use t.GetStateChanges() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StateChanges == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) GetStateChanges() uint64 {
	if t == nil || t.StateChanges == nil {
		return 0
	}
	return *t.StateChanges
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct {
	ΛMetadata           []ygot.Annotation                                                                                 `path:"@" ygotAnnotation:"true"`
	Destination         *string                                                                                           `path:"config/destination" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDestination        []ygot.Annotation                                                                                 `path:"config/@destination" ygotAnnotation:"true"`
	P2PPrimaryPath      map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath   `path:"p2p-primary-path/p2p-primary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛP2PPrimaryPath     []ygot.Annotation                                                                                 `path:"p2p-primary-path/@p2p-primary-path" ygotAnnotation:"true"`
	P2PSecondaryPath    map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath `path:"p2p-secondary-paths/p2p-secondary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛP2PSecondaryPath   []ygot.Annotation                                                                                 `path:"p2p-secondary-paths/@p2p-secondary-path" ygotAnnotation:"true"`
	RecordRouteEnabled  *bool                                                                                             `path:"config/record-route-enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRecordRouteEnabled []ygot.Annotation                                                                                 `path:"config/@record-route-enabled" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) IsYANGGoStruct() {}

// NewP2PPrimaryPath creates a new entry in the P2PPrimaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PPrimaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PPrimaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PPrimaryPath", key)
	}

	t.P2PPrimaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
		Name: &Name,
	}

	return t.P2PPrimaryPath[key], nil
}

// RenameP2PPrimaryPath renames an entry in the list P2PPrimaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PPrimaryPath(oldK, newK string) error {
	if _, ok := t.P2PPrimaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PPrimaryPath", newK)
	}

	e, ok := t.P2PPrimaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PPrimaryPath", oldK)
	}
	e.Name = &newK

	t.P2PPrimaryPath[newK] = e
	delete(t.P2PPrimaryPath, oldK)
	return nil
}

// GetOrCreateP2PPrimaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	key := Name

	if v, ok := t.P2PPrimaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PPrimaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PPrimaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PPrimaryPath retrieves the value with the specified key from
// the P2PPrimaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PPrimaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PPrimaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PPrimaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PPrimaryPath(Name string) {
	key := Name

	delete(t.P2PPrimaryPath, key)
}

// AppendP2PPrimaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct to the
// list P2PPrimaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PPrimaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PPrimaryPath == nil {
		t.P2PPrimaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
	}

	if _, ok := t.P2PPrimaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PPrimaryPath %v", key)
	}

	t.P2PPrimaryPath[key] = v
	return nil
}

// NewP2PSecondaryPath creates a new entry in the P2PSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) NewP2PSecondaryPath(Name string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.P2PSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list P2PSecondaryPath", key)
	}

	t.P2PSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
		Name: &Name,
	}

	return t.P2PSecondaryPath[key], nil
}

// RenameP2PSecondaryPath renames an entry in the list P2PSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) RenameP2PSecondaryPath(oldK, newK string) error {
	if _, ok := t.P2PSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in P2PSecondaryPath", newK)
	}

	e, ok := t.P2PSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in P2PSecondaryPath", oldK)
	}
	e.Name = &newK

	t.P2PSecondaryPath[newK] = e
	delete(t.P2PSecondaryPath, oldK)
	return nil
}

// GetOrCreateP2PSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetOrCreateP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	key := Name

	if v, ok := t.P2PSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewP2PSecondaryPath(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateP2PSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetP2PSecondaryPath retrieves the value with the specified key from
// the P2PSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetP2PSecondaryPath(Name string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.P2PSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteP2PSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) DeleteP2PSecondaryPath(Name string) {
	key := Name

	delete(t.P2PSecondaryPath, key)
}

// AppendP2PSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct to the
// list P2PSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) AppendP2PSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.P2PSecondaryPath == nil {
		t.P2PSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
	}

	if _, ok := t.P2PSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list P2PSecondaryPath %v", key)
	}

	t.P2PSecondaryPath[key] = v
	return nil
}

// GetDestination retrieves the value of the leaf Destination from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Destination is set, it can
// safely use t.GetDestination() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Destination == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetDestination() string {
	if t == nil || t.Destination == nil {
		return ""
	}
	return *t.Destination
}

// GetRecordRouteEnabled retrieves the value of the leaf RecordRouteEnabled from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RecordRouteEnabled is set, it can
// safely use t.GetRecordRouteEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RecordRouteEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) GetRecordRouteEnabled() bool {
	if t == nil || t.RecordRouteEnabled == nil {
		return false
	}
	return *t.RecordRouteEnabled
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.P2PPrimaryPath {
		e.PopulateDefaults()
	}
	for _, e := range t.P2PSecondaryPath {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct {
	ΛMetadata                  []ygot.Annotation                                                                                                                               `path:"@" ygotAnnotation:"true"`
	AdminGroups                *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups                                                `path:"admin-groups" module:"openconfig-network-instance"`
	ΛAdminGroups               []ygot.Annotation                                                                                                                               `path:"@admin-groups" ygotAnnotation:"true"`
	AssociatedRsvpSessions     []uint64                                                                                                                                        `path:"state/associated-rsvp-sessions" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAssociatedRsvpSessions    []ygot.Annotation                                                                                                                               `path:"state/@associated-rsvp-sessions" ygotAnnotation:"true"`
	CandidateSecondaryPath     map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath                          `path:"candidate-secondary-paths/candidate-secondary-path" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCandidateSecondaryPath    []ygot.Annotation                                                                                                                               `path:"candidate-secondary-paths/@candidate-secondary-path" ygotAnnotation:"true"`
	CspfMetric                 *uint64                                                                                                                                         `path:"state/cspf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCspfMetric                []ygot.Annotation                                                                                                                               `path:"state/@cspf-metric" ygotAnnotation:"true"`
	CspfTiebreaker             E_Mpls_CspfTieBreaking                                                                                                                          `path:"config/cspf-tiebreaker" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCspfTiebreaker            []ygot.Annotation                                                                                                                               `path:"config/@cspf-tiebreaker" ygotAnnotation:"true"`
	ExplicitPathName           *string                                                                                                                                         `path:"config/explicit-path-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExplicitPathName          []ygot.Annotation                                                                                                                               `path:"config/@explicit-path-name" ygotAnnotation:"true"`
	HoldPriority               *uint8                                                                                                                                          `path:"config/hold-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛHoldPriority              []ygot.Annotation                                                                                                                               `path:"config/@hold-priority" ygotAnnotation:"true"`
	Name                       *string                                                                                                                                         `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName                      []ygot.Annotation                                                                                                                               `path:"config/@name|@name" ygotAnnotation:"true"`
	PathComputationMethod      E_MplsTypes_PATH_COMPUTATION_METHOD                                                                                                             `path:"config/path-computation-method" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathComputationMethod     []ygot.Annotation                                                                                                                               `path:"config/@path-computation-method" ygotAnnotation:"true"`
	PathComputationServer      *string                                                                                                                                         `path:"config/path-computation-server" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathComputationServer     []ygot.Annotation                                                                                                                               `path:"config/@path-computation-server" ygotAnnotation:"true"`
	PathControl                E_Pcep_LspControlType                                                                                                                           `path:"config/path-control" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathControl               []ygot.Annotation                                                                                                                               `path:"config/@path-control" ygotAnnotation:"true"`
	PathMetricBoundConstraint  map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint `path:"path-metric-bound-constraints/path-metric-bound-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathMetricBoundConstraint []ygot.Annotation                                                                                                                               `path:"path-metric-bound-constraints/@path-metric-bound-constraint" ygotAnnotation:"true"`
	Preference                 *uint8                                                                                                                                          `path:"config/preference" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPreference                []ygot.Annotation                                                                                                                               `path:"config/@preference" ygotAnnotation:"true"`
	RetryTimer                 *uint16                                                                                                                                         `path:"config/retry-timer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRetryTimer                []ygot.Annotation                                                                                                                               `path:"config/@retry-timer" ygotAnnotation:"true"`
	SetupPriority              *uint8                                                                                                                                          `path:"config/setup-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSetupPriority             []ygot.Annotation                                                                                                                               `path:"config/@setup-priority" ygotAnnotation:"true"`
	SpfMetric                  *uint64                                                                                                                                         `path:"state/spf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSpfMetric                 []ygot.Annotation                                                                                                                               `path:"state/@spf-metric" ygotAnnotation:"true"`
	UseCspf                    *bool                                                                                                                                           `path:"config/use-cspf" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUseCspf                   []ygot.Annotation                                                                                                                               `path:"config/@use-cspf" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) IsYANGGoStruct() {
}

// NewCandidateSecondaryPath creates a new entry in the CandidateSecondaryPath list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewCandidateSecondaryPath(SecondaryPath string) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	key := SecondaryPath

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CandidateSecondaryPath", key)
	}

	t.CandidateSecondaryPath[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
		SecondaryPath: &SecondaryPath,
	}

	return t.CandidateSecondaryPath[key], nil
}

// RenameCandidateSecondaryPath renames an entry in the list CandidateSecondaryPath within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenameCandidateSecondaryPath(oldK, newK string) error {
	if _, ok := t.CandidateSecondaryPath[newK]; ok {
		return fmt.Errorf("key %v already exists in CandidateSecondaryPath", newK)
	}

	e, ok := t.CandidateSecondaryPath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CandidateSecondaryPath", oldK)
	}
	e.SecondaryPath = &newK

	t.CandidateSecondaryPath[newK] = e
	delete(t.CandidateSecondaryPath, oldK)
	return nil
}

// GetOrCreateCandidateSecondaryPath retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	key := SecondaryPath

	if v, ok := t.CandidateSecondaryPath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCandidateSecondaryPath(SecondaryPath)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCandidateSecondaryPath got unexpected error: %v", err))
	}
	return v
}

// GetCandidateSecondaryPath retrieves the value with the specified key from
// the CandidateSecondaryPath map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCandidateSecondaryPath(SecondaryPath string) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {

	if t == nil {
		return nil
	}

	key := SecondaryPath

	if lm, ok := t.CandidateSecondaryPath[key]; ok {
		return lm
	}
	return nil
}

// DeleteCandidateSecondaryPath deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) DeleteCandidateSecondaryPath(SecondaryPath string) {
	key := SecondaryPath

	delete(t.CandidateSecondaryPath, key)
}

// AppendCandidateSecondaryPath appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct to the
// list CandidateSecondaryPath of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendCandidateSecondaryPath(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) error {
	if v.SecondaryPath == nil {
		return fmt.Errorf("invalid nil key received for SecondaryPath")
	}

	key := *v.SecondaryPath

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CandidateSecondaryPath == nil {
		t.CandidateSecondaryPath = make(map[string]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
	}

	if _, ok := t.CandidateSecondaryPath[key]; ok {
		return fmt.Errorf("duplicate key for list CandidateSecondaryPath %v", key)
	}

	t.CandidateSecondaryPath[key] = v
	return nil
}

// NewPathMetricBoundConstraint creates a new entry in the PathMetricBoundConstraint list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) NewPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathMetricBoundConstraint", key)
	}

	t.PathMetricBoundConstraint[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
		Type: Type,
	}

	return t.PathMetricBoundConstraint[key], nil
}

// RenamePathMetricBoundConstraint renames an entry in the list PathMetricBoundConstraint within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) RenamePathMetricBoundConstraint(oldK, newK E_MplsTypes_PATH_METRIC_TYPE) error {
	if _, ok := t.PathMetricBoundConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in PathMetricBoundConstraint", newK)
	}

	e, ok := t.PathMetricBoundConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathMetricBoundConstraint", oldK)
	}
	e.Type = newK

	t.PathMetricBoundConstraint[newK] = e
	delete(t.PathMetricBoundConstraint, oldK)
	return nil
}

// GetOrCreatePathMetricBoundConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreatePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {

	key := Type

	if v, ok := t.PathMetricBoundConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathMetricBoundConstraint(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathMetricBoundConstraint got unexpected error: %v", err))
	}
	return v
}

// GetPathMetricBoundConstraint retrieves the value with the specified key from
// the PathMetricBoundConstraint map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.PathMetricBoundConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeletePathMetricBoundConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) DeletePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) {
	key := Type

	delete(t.PathMetricBoundConstraint, key)
}

// AppendPathMetricBoundConstraint appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct to the
// list PathMetricBoundConstraint of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) AppendPathMetricBoundConstraint(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
	}

	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list PathMetricBoundConstraint %v", key)
	}

	t.PathMetricBoundConstraint[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetAssociatedRsvpSessions retrieves the value of the leaf AssociatedRsvpSessions from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedRsvpSessions is set, it can
// safely use t.GetAssociatedRsvpSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedRsvpSessions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetAssociatedRsvpSessions() []uint64 {
	if t == nil || t.AssociatedRsvpSessions == nil {
		return nil
	}
	return t.AssociatedRsvpSessions
}

// GetCspfMetric retrieves the value of the leaf CspfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfMetric is set, it can
// safely use t.GetCspfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCspfMetric() uint64 {
	if t == nil || t.CspfMetric == nil {
		return 0
	}
	return *t.CspfMetric
}

// GetCspfTiebreaker retrieves the value of the leaf CspfTiebreaker from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfTiebreaker is set, it can
// safely use t.GetCspfTiebreaker() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfTiebreaker == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetCspfTiebreaker() E_Mpls_CspfTieBreaking {
	if t == nil || t.CspfTiebreaker == 0 {
		return Mpls_CspfTieBreaking_RANDOM
	}
	return t.CspfTiebreaker
}

// GetExplicitPathName retrieves the value of the leaf ExplicitPathName from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExplicitPathName is set, it can
// safely use t.GetExplicitPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExplicitPathName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetExplicitPathName() string {
	if t == nil || t.ExplicitPathName == nil {
		return ""
	}
	return *t.ExplicitPathName
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPathComputationMethod retrieves the value of the leaf PathComputationMethod from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationMethod is set, it can
// safely use t.GetPathComputationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathComputationMethod() E_MplsTypes_PATH_COMPUTATION_METHOD {
	if t == nil || t.PathComputationMethod == 0 {
		return MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	return t.PathComputationMethod
}

// GetPathComputationServer retrieves the value of the leaf PathComputationServer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationServer is set, it can
// safely use t.GetPathComputationServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationServer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathComputationServer() string {
	if t == nil || t.PathComputationServer == nil {
		return ""
	}
	return *t.PathComputationServer
}

// GetPathControl retrieves the value of the leaf PathControl from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathControl is set, it can
// safely use t.GetPathControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathControl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPathControl() E_Pcep_LspControlType {
	if t == nil || t.PathControl == 0 {
		return 0
	}
	return t.PathControl
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRetryTimer retrieves the value of the leaf RetryTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetryTimer is set, it can
// safely use t.GetRetryTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetryTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetRetryTimer() uint16 {
	if t == nil || t.RetryTimer == nil {
		return 0
	}
	return *t.RetryTimer
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetSpfMetric retrieves the value of the leaf SpfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfMetric is set, it can
// safely use t.GetSpfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetSpfMetric() uint64 {
	if t == nil || t.SpfMetric == nil {
		return 0
	}
	return *t.SpfMetric
}

// GetUseCspf retrieves the value of the leaf UseCspf from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseCspf is set, it can
// safely use t.GetUseCspf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseCspf == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) GetUseCspf() bool {
	if t == nil || t.UseCspf == nil {
		return false
	}
	return *t.UseCspf
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CspfTiebreaker == 0 {
		t.CspfTiebreaker = Mpls_CspfTieBreaking_RANDOM
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.PathComputationMethod == 0 {
		t.PathComputationMethod = MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	t.AdminGroups.PopulateDefaults()
	for _, e := range t.CandidateSecondaryPath {
		e.PopulateDefaults()
	}
	for _, e := range t.PathMetricBoundConstraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups struct {
	ΛMetadata        []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	ExcludeGroup     []string          `path:"config/exclude-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExcludeGroup    []ygot.Annotation `path:"config/@exclude-group" ygotAnnotation:"true"`
	IncludeAllGroup  []string          `path:"config/include-all-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncludeAllGroup []ygot.Annotation `path:"config/@include-all-group" ygotAnnotation:"true"`
	IncludeAnyGroup  []string          `path:"config/include-any-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncludeAnyGroup []ygot.Annotation `path:"config/@include-any-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct {
	ΛMetadata      []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Active         *bool             `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛActive        []ygot.Annotation `path:"state/@active" ygotAnnotation:"true"`
	Priority       *uint16           `path:"config/priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPriority      []ygot.Annotation `path:"config/@priority" ygotAnnotation:"true"`
	SecondaryPath  *string           `path:"config/secondary-path|secondary-path" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛSecondaryPath []ygot.Annotation `path:"config/@secondary-path|@secondary-path" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) IsYANGGoStruct() {
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetPriority retrieves the value of the leaf Priority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetPriority() uint16 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetSecondaryPath retrieves the value of the leaf SecondaryPath from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecondaryPath is set, it can
// safely use t.GetSecondaryPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecondaryPath == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) GetSecondaryPath() string {
	if t == nil || t.SecondaryPath == nil {
		return ""
	}
	return *t.SecondaryPath
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecondaryPath == nil {
		return nil, fmt.Errorf("nil value for key SecondaryPath")
	}

	return map[string]interface{}{
		"secondary-path": *t.SecondaryPath,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct {
	ΛMetadata         []ygot.Annotation            `path:"@" ygotAnnotation:"true"`
	MetricUpperBound  *uint64                      `path:"config/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMetricUpperBound []ygot.Annotation            `path:"config/@metric-upper-bound" ygotAnnotation:"true"`
	Type              E_MplsTypes_PATH_METRIC_TYPE `path:"config/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛType             []ygot.Annotation            `path:"config/@type|@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct {
	ΛMetadata                  []ygot.Annotation                                                                                                                                 `path:"@" ygotAnnotation:"true"`
	AdminGroups                *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups                                                `path:"admin-groups" module:"openconfig-network-instance"`
	ΛAdminGroups               []ygot.Annotation                                                                                                                                 `path:"@admin-groups" ygotAnnotation:"true"`
	AssociatedRsvpSessions     []uint64                                                                                                                                          `path:"state/associated-rsvp-sessions" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAssociatedRsvpSessions    []ygot.Annotation                                                                                                                                 `path:"state/@associated-rsvp-sessions" ygotAnnotation:"true"`
	CspfMetric                 *uint64                                                                                                                                           `path:"state/cspf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCspfMetric                []ygot.Annotation                                                                                                                                 `path:"state/@cspf-metric" ygotAnnotation:"true"`
	CspfTiebreaker             E_Mpls_CspfTieBreaking                                                                                                                            `path:"config/cspf-tiebreaker" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCspfTiebreaker            []ygot.Annotation                                                                                                                                 `path:"config/@cspf-tiebreaker" ygotAnnotation:"true"`
	ExplicitPathName           *string                                                                                                                                           `path:"config/explicit-path-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExplicitPathName          []ygot.Annotation                                                                                                                                 `path:"config/@explicit-path-name" ygotAnnotation:"true"`
	HoldPriority               *uint8                                                                                                                                            `path:"config/hold-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛHoldPriority              []ygot.Annotation                                                                                                                                 `path:"config/@hold-priority" ygotAnnotation:"true"`
	Name                       *string                                                                                                                                           `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName                      []ygot.Annotation                                                                                                                                 `path:"config/@name|@name" ygotAnnotation:"true"`
	PathComputationMethod      E_MplsTypes_PATH_COMPUTATION_METHOD                                                                                                               `path:"config/path-computation-method" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathComputationMethod     []ygot.Annotation                                                                                                                                 `path:"config/@path-computation-method" ygotAnnotation:"true"`
	PathComputationServer      *string                                                                                                                                           `path:"config/path-computation-server" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathComputationServer     []ygot.Annotation                                                                                                                                 `path:"config/@path-computation-server" ygotAnnotation:"true"`
	PathControl                E_Pcep_LspControlType                                                                                                                             `path:"config/path-control" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathControl               []ygot.Annotation                                                                                                                                 `path:"config/@path-control" ygotAnnotation:"true"`
	PathMetricBoundConstraint  map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint `path:"path-metric-bound-constraints/path-metric-bound-constraint" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPathMetricBoundConstraint []ygot.Annotation                                                                                                                                 `path:"path-metric-bound-constraints/@path-metric-bound-constraint" ygotAnnotation:"true"`
	Preference                 *uint8                                                                                                                                            `path:"config/preference" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPreference                []ygot.Annotation                                                                                                                                 `path:"config/@preference" ygotAnnotation:"true"`
	RetryTimer                 *uint16                                                                                                                                           `path:"config/retry-timer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRetryTimer                []ygot.Annotation                                                                                                                                 `path:"config/@retry-timer" ygotAnnotation:"true"`
	SetupPriority              *uint8                                                                                                                                            `path:"config/setup-priority" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSetupPriority             []ygot.Annotation                                                                                                                                 `path:"config/@setup-priority" ygotAnnotation:"true"`
	SpfMetric                  *uint64                                                                                                                                           `path:"state/spf-metric" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSpfMetric                 []ygot.Annotation                                                                                                                                 `path:"state/@spf-metric" ygotAnnotation:"true"`
	UseCspf                    *bool                                                                                                                                             `path:"config/use-cspf" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUseCspf                   []ygot.Annotation                                                                                                                                 `path:"config/@use-cspf" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) IsYANGGoStruct() {
}

// NewPathMetricBoundConstraint creates a new entry in the PathMetricBoundConstraint list of the
// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) NewPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	key := Type

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PathMetricBoundConstraint", key)
	}

	t.PathMetricBoundConstraint[key] = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
		Type: Type,
	}

	return t.PathMetricBoundConstraint[key], nil
}

// RenamePathMetricBoundConstraint renames an entry in the list PathMetricBoundConstraint within
// the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) RenamePathMetricBoundConstraint(oldK, newK E_MplsTypes_PATH_METRIC_TYPE) error {
	if _, ok := t.PathMetricBoundConstraint[newK]; ok {
		return fmt.Errorf("key %v already exists in PathMetricBoundConstraint", newK)
	}

	e, ok := t.PathMetricBoundConstraint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PathMetricBoundConstraint", oldK)
	}
	e.Type = newK

	t.PathMetricBoundConstraint[newK] = e
	delete(t.PathMetricBoundConstraint, oldK)
	return nil
}

// GetOrCreatePathMetricBoundConstraint retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreatePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	key := Type

	if v, ok := t.PathMetricBoundConstraint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPathMetricBoundConstraint(Type)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePathMetricBoundConstraint got unexpected error: %v", err))
	}
	return v
}

// GetPathMetricBoundConstraint retrieves the value with the specified key from
// the PathMetricBoundConstraint map field of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {

	if t == nil {
		return nil
	}

	key := Type

	if lm, ok := t.PathMetricBoundConstraint[key]; ok {
		return lm
	}
	return nil
}

// DeletePathMetricBoundConstraint deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) DeletePathMetricBoundConstraint(Type E_MplsTypes_PATH_METRIC_TYPE) {
	key := Type

	delete(t.PathMetricBoundConstraint, key)
}

// AppendPathMetricBoundConstraint appends the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct to the
// list PathMetricBoundConstraint of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) AppendPathMetricBoundConstraint(v *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) error {
	key := v.Type

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PathMetricBoundConstraint == nil {
		t.PathMetricBoundConstraint = make(map[E_MplsTypes_PATH_METRIC_TYPE]*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
	}

	if _, ok := t.PathMetricBoundConstraint[key]; ok {
		return fmt.Errorf("duplicate key for list PathMetricBoundConstraint %v", key)
	}

	t.PathMetricBoundConstraint[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetOrCreateAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	return t.AdminGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAdminGroups() *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetAssociatedRsvpSessions retrieves the value of the leaf AssociatedRsvpSessions from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociatedRsvpSessions is set, it can
// safely use t.GetAssociatedRsvpSessions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociatedRsvpSessions == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetAssociatedRsvpSessions() []uint64 {
	if t == nil || t.AssociatedRsvpSessions == nil {
		return nil
	}
	return t.AssociatedRsvpSessions
}

// GetCspfMetric retrieves the value of the leaf CspfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfMetric is set, it can
// safely use t.GetCspfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfMetric() uint64 {
	if t == nil || t.CspfMetric == nil {
		return 0
	}
	return *t.CspfMetric
}

// GetCspfTiebreaker retrieves the value of the leaf CspfTiebreaker from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CspfTiebreaker is set, it can
// safely use t.GetCspfTiebreaker() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CspfTiebreaker == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetCspfTiebreaker() E_Mpls_CspfTieBreaking {
	if t == nil || t.CspfTiebreaker == 0 {
		return Mpls_CspfTieBreaking_RANDOM
	}
	return t.CspfTiebreaker
}

// GetExplicitPathName retrieves the value of the leaf ExplicitPathName from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExplicitPathName is set, it can
// safely use t.GetExplicitPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExplicitPathName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetExplicitPathName() string {
	if t == nil || t.ExplicitPathName == nil {
		return ""
	}
	return *t.ExplicitPathName
}

// GetHoldPriority retrieves the value of the leaf HoldPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldPriority is set, it can
// safely use t.GetHoldPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetHoldPriority() uint8 {
	if t == nil || t.HoldPriority == nil {
		return 0
	}
	return *t.HoldPriority
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPathComputationMethod retrieves the value of the leaf PathComputationMethod from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationMethod is set, it can
// safely use t.GetPathComputationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationMethod == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationMethod() E_MplsTypes_PATH_COMPUTATION_METHOD {
	if t == nil || t.PathComputationMethod == 0 {
		return MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	return t.PathComputationMethod
}

// GetPathComputationServer retrieves the value of the leaf PathComputationServer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathComputationServer is set, it can
// safely use t.GetPathComputationServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathComputationServer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathComputationServer() string {
	if t == nil || t.PathComputationServer == nil {
		return ""
	}
	return *t.PathComputationServer
}

// GetPathControl retrieves the value of the leaf PathControl from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathControl is set, it can
// safely use t.GetPathControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathControl == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPathControl() E_Pcep_LspControlType {
	if t == nil || t.PathControl == 0 {
		return 0
	}
	return t.PathControl
}

// GetPreference retrieves the value of the leaf Preference from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 0
	}
	return *t.Preference
}

// GetRetryTimer retrieves the value of the leaf RetryTimer from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RetryTimer is set, it can
// safely use t.GetRetryTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RetryTimer == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetRetryTimer() uint16 {
	if t == nil || t.RetryTimer == nil {
		return 0
	}
	return *t.RetryTimer
}

// GetSetupPriority retrieves the value of the leaf SetupPriority from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetupPriority is set, it can
// safely use t.GetSetupPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetupPriority == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSetupPriority() uint8 {
	if t == nil || t.SetupPriority == nil {
		return 7
	}
	return *t.SetupPriority
}

// GetSpfMetric retrieves the value of the leaf SpfMetric from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpfMetric is set, it can
// safely use t.GetSpfMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpfMetric == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetSpfMetric() uint64 {
	if t == nil || t.SpfMetric == nil {
		return 0
	}
	return *t.SpfMetric
}

// GetUseCspf retrieves the value of the leaf UseCspf from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseCspf is set, it can
// safely use t.GetUseCspf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseCspf == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) GetUseCspf() bool {
	if t == nil || t.UseCspf == nil {
		return false
	}
	return *t.UseCspf
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CspfTiebreaker == 0 {
		t.CspfTiebreaker = Mpls_CspfTieBreaking_RANDOM
	}
	if t.HoldPriority == nil {
		var v uint8 = 0
		t.HoldPriority = &v
	}
	if t.PathComputationMethod == 0 {
		t.PathComputationMethod = MplsTypes_PATH_COMPUTATION_METHOD_LOCALLY_COMPUTED
	}
	if t.SetupPriority == nil {
		var v uint8 = 7
		t.SetupPriority = &v
	}
	t.AdminGroups.PopulateDefaults()
	for _, e := range t.PathMetricBoundConstraint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups struct {
	ΛMetadata        []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	ExcludeGroup     []string          `path:"config/exclude-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExcludeGroup    []ygot.Annotation `path:"config/@exclude-group" ygotAnnotation:"true"`
	IncludeAllGroup  []string          `path:"config/include-all-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncludeAllGroup []ygot.Annotation `path:"config/@include-all-group" ygotAnnotation:"true"`
	IncludeAnyGroup  []string          `path:"config/include-any-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncludeAnyGroup []ygot.Annotation `path:"config/@include-any-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) IsYANGGoStruct() {
}

// GetExcludeGroup retrieves the value of the leaf ExcludeGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExcludeGroup is set, it can
// safely use t.GetExcludeGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExcludeGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetExcludeGroup() []string {
	if t == nil || t.ExcludeGroup == nil {
		return nil
	}
	return t.ExcludeGroup
}

// GetIncludeAllGroup retrieves the value of the leaf IncludeAllGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAllGroup is set, it can
// safely use t.GetIncludeAllGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAllGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAllGroup() []string {
	if t == nil || t.IncludeAllGroup == nil {
		return nil
	}
	return t.IncludeAllGroup
}

// GetIncludeAnyGroup retrieves the value of the leaf IncludeAnyGroup from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeAnyGroup is set, it can
// safely use t.GetIncludeAnyGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeAnyGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) GetIncludeAnyGroup() []string {
	if t == nil || t.IncludeAnyGroup == nil {
		return nil
	}
	return t.IncludeAnyGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint YANG schema element.
type NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct {
	ΛMetadata         []ygot.Annotation            `path:"@" ygotAnnotation:"true"`
	MetricUpperBound  *uint64                      `path:"config/metric-upper-bound" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMetricUpperBound []ygot.Annotation            `path:"config/@metric-upper-bound" ygotAnnotation:"true"`
	Type              E_MplsTypes_PATH_METRIC_TYPE `path:"config/type|type" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛType             []ygot.Annotation            `path:"config/@type|@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) IsYANGGoStruct() {
}

// GetMetricUpperBound retrieves the value of the leaf MetricUpperBound from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricUpperBound is set, it can
// safely use t.GetMetricUpperBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricUpperBound == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetMetricUpperBound() uint64 {
	if t == nil || t.MetricUpperBound == nil {
		return 0
	}
	return *t.MetricUpperBound
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) GetType() E_MplsTypes_PATH_METRIC_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MetricUpperBound == nil {
		var v uint64 = 0
		t.MetricUpperBound = &v
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"type": t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint.
func (*NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp struct {
	ΛMetadata []ygot.Annotation                            `path:"@" ygotAnnotation:"true"`
	Egress    *NetworkInstance_Mpls_Lsps_StaticLsp_Egress  `path:"egress" module:"openconfig-network-instance"`
	ΛEgress   []ygot.Annotation                            `path:"@egress" ygotAnnotation:"true"`
	Ingress   *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress `path:"ingress" module:"openconfig-network-instance"`
	ΛIngress  []ygot.Annotation                            `path:"@ingress" ygotAnnotation:"true"`
	Name      *string                                      `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName     []ygot.Annotation                            `path:"config/@name|@name" ygotAnnotation:"true"`
	Transit   *NetworkInstance_Mpls_Lsps_StaticLsp_Transit `path:"transit" module:"openconfig-network-instance"`
	ΛTransit  []ygot.Annotation                            `path:"@transit" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp) IsYANGGoStruct() {}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	return t.Ingress
}

// GetOrCreateTransit retrieves the value of the Transit field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetOrCreateTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t.Transit != nil {
		return t.Transit
	}
	t.Transit = &NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	return t.Transit
}

// GetEgress returns the value of the Egress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetEgress() *NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetIngress() *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetTransit returns the value of the Transit struct pointer
// from NetworkInstance_Mpls_Lsps_StaticLsp. If the receiver or the field Transit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetTransit() *NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	if t != nil && t.Transit != nil {
		return t.Transit
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NetworkInstance_Mpls_Lsps_StaticLsp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Egress.PopulateDefaults()
	t.Ingress.PopulateDefaults()
	t.Transit.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Mpls_Lsps_StaticLsp struct, which is a YANG list entry.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp.
func (*NetworkInstance_Mpls_Lsps_StaticLsp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress struct {
	ΛMetadata      []ygot.Annotation                                              `path:"@" ygotAnnotation:"true"`
	IncomingLabel  NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union `path:"config/incoming-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncomingLabel []ygot.Annotation                                              `path:"config/@incoming-label" ygotAnnotation:"true"`
	NextHop        *string                                                        `path:"config/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop       []ygot.Annotation                                              `path:"config/@next-hop" ygotAnnotation:"true"`
	PushLabel      NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union     `path:"config/push-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPushLabel     []ygot.Annotation                                              `path:"config/@push-label" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Egress.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Egress) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress struct {
	ΛMetadata      []ygot.Annotation                                               `path:"@" ygotAnnotation:"true"`
	IncomingLabel  NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union `path:"config/incoming-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncomingLabel []ygot.Annotation                                               `path:"config/@incoming-label" ygotAnnotation:"true"`
	NextHop        *string                                                         `path:"config/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop       []ygot.Annotation                                               `path:"config/@next-hop" ygotAnnotation:"true"`
	PushLabel      NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union     `path:"config/push-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPushLabel     []ygot.Annotation                                               `path:"config/@push-label" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Ingress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Ingress.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit YANG schema element.
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit struct {
	ΛMetadata      []ygot.Annotation                                               `path:"@" ygotAnnotation:"true"`
	IncomingLabel  NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union `path:"config/incoming-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIncomingLabel []ygot.Annotation                                               `path:"config/@incoming-label" ygotAnnotation:"true"`
	NextHop        *string                                                         `path:"config/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop       []ygot.Annotation                                               `path:"config/@next-hop" ygotAnnotation:"true"`
	PushLabel      NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union     `path:"config/push-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPushLabel     []ygot.Annotation                                               `path:"config/@push-label" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_StaticLsp_Transit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit) IsYANGGoStruct() {}

// GetIncomingLabel retrieves the value of the leaf IncomingLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncomingLabel is set, it can
// safely use t.GetIncomingLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncomingLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetIncomingLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	if t == nil || t.IncomingLabel == nil {
		return nil
	}
	return t.IncomingLabel
}

// GetNextHop retrieves the value of the leaf NextHop from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetNextHop() string {
	if t == nil || t.NextHop == nil {
		return ""
	}
	return *t.NextHop
}

// GetPushLabel retrieves the value of the leaf PushLabel from the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushLabel is set, it can
// safely use t.GetPushLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) GetPushLabel() NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	if t == nil || t.PushLabel == nil {
		return nil
	}
	return t.PushLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_StaticLsp_Transit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_StaticLsp_Transit.
func (*NetworkInstance_Mpls_Lsps_StaticLsp_Transit) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath struct {
	ΛMetadata          []ygot.Annotation                                              `path:"@" ygotAnnotation:"true"`
	PathSetupProtocol  *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol `path:"path-setup-protocol" module:"openconfig-network-instance"`
	ΛPathSetupProtocol []ygot.Annotation                                              `path:"@path-setup-protocol" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath) IsYANGGoStruct() {}

// GetOrCreatePathSetupProtocol retrieves the value of the PathSetupProtocol field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetOrCreatePathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	t.PathSetupProtocol = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	return t.PathSetupProtocol
}

// GetPathSetupProtocol returns the value of the PathSetupProtocol struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath. If the receiver or the field PathSetupProtocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) GetPathSetupProtocol() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	if t != nil && t.PathSetupProtocol != nil {
		return t.PathSetupProtocol
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PathSetupProtocol.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol struct {
	ΛMetadata []ygot.Annotation                                                  `path:"@" ygotAnnotation:"true"`
	Ldp       *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp `path:"ldp" module:"openconfig-network-instance"`
	ΛLdp      []ygot.Annotation                                                  `path:"@ldp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetOrCreateLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	return t.Ldp
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) GetLdp() *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp YANG schema element.
type NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp.
func (*NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols struct {
	ΛMetadata       []ygot.Annotation                                       `path:"@" ygotAnnotation:"true"`
	Ldp             *NetworkInstance_Mpls_SignalingProtocols_Ldp            `path:"ldp" module:"openconfig-network-instance"`
	ΛLdp            []ygot.Annotation                                       `path:"@ldp" ygotAnnotation:"true"`
	RsvpTe          *NetworkInstance_Mpls_SignalingProtocols_RsvpTe         `path:"rsvp-te" module:"openconfig-network-instance"`
	ΛRsvpTe         []ygot.Annotation                                       `path:"@rsvp-te" ygotAnnotation:"true"`
	SegmentRouting  *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting `path:"segment-routing" module:"openconfig-network-instance"`
	ΛSegmentRouting []ygot.Annotation                                       `path:"@segment-routing" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols) IsYANGGoStruct() {}

// GetOrCreateLdp retrieves the value of the Ldp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t.Ldp != nil {
		return t.Ldp
	}
	t.Ldp = &NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	return t.Ldp
}

// GetOrCreateRsvpTe retrieves the value of the RsvpTe field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t.RsvpTe != nil {
		return t.RsvpTe
	}
	t.RsvpTe = &NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	return t.RsvpTe
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetOrCreateSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	return t.SegmentRouting
}

// GetLdp returns the value of the Ldp struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field Ldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetLdp() *NetworkInstance_Mpls_SignalingProtocols_Ldp {
	if t != nil && t.Ldp != nil {
		return t.Ldp
	}
	return nil
}

// GetRsvpTe returns the value of the RsvpTe struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field RsvpTe is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetRsvpTe() *NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	if t != nil && t.RsvpTe != nil {
		return t.RsvpTe
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance_Mpls_SignalingProtocols. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols) GetSegmentRouting() *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ldp.PopulateDefaults()
	t.RsvpTe.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols.
func (*NetworkInstance_Mpls_SignalingProtocols) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp struct {
	ΛMetadata            []ygot.Annotation                                                                                                  `path:"@" ygotAnnotation:"true"`
	Global               *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global                                                                `path:"global" module:"openconfig-network-instance"`
	ΛGlobal              []ygot.Annotation                                                                                                  `path:"@global" ygotAnnotation:"true"`
	InterfaceAttributes  *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes                                                   `path:"interface-attributes" module:"openconfig-network-instance"`
	ΛInterfaceAttributes []ygot.Annotation                                                                                                  `path:"@interface-attributes" ygotAnnotation:"true"`
	Neighbor             map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor `path:"neighbors/neighbor" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNeighbor            []ygot.Annotation                                                                                                  `path:"neighbors/@neighbor" ygotAnnotation:"true"`
	Targeted             *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted                                                              `path:"targeted" module:"openconfig-network-instance"`
	ΛTargeted            []ygot.Annotation                                                                                                  `path:"@targeted" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp) IsYANGGoStruct() {}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key represents the key for list Neighbor of element /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key struct {
	LsrId        string `path:"lsr-id"`
	LabelSpaceId uint16 `path:"label-space-id"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key key struct.
func (t NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"lsr-id":         t.LsrId,
		"label-space-id": t.LabelSpaceId,
	}, nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) NewNeighbor(LsrId string, LabelSpaceId uint16) (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
		LsrId:        &LsrId,
		LabelSpaceId: &LabelSpaceId,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the NetworkInstance_Mpls_SignalingProtocols_Ldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) RenameNeighbor(oldK, newK NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.LsrId = &newK.LsrId
	e.LabelSpaceId = &newK.LabelSpaceId

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(LsrId, LabelSpaceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetNeighbor(LsrId string, LabelSpaceId uint16) *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver NetworkInstance_Mpls_SignalingProtocols_Ldp. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) DeleteNeighbor(LsrId string, LabelSpaceId uint16) {
	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        LsrId,
		LabelSpaceId: LabelSpaceId,
	}

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor struct to the
// list Neighbor of NetworkInstance_Mpls_SignalingProtocols_Ldp. If the key value(s) specified in
// the supplied NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor already exist in the list, an error is
// returned.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) AppendNeighbor(v *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) error {
	if v.LsrId == nil {
		return fmt.Errorf("invalid nil key for LsrId")
	}

	if v.LabelSpaceId == nil {
		return fmt.Errorf("invalid nil key for LabelSpaceId")
	}

	key := NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key{
		LsrId:        *v.LsrId,
		LabelSpaceId: *v.LabelSpaceId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Key]*NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateGlobal retrieves the value of the Global field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t.Global != nil {
		return t.Global
	}
	t.Global = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	return t.Global
}

// GetOrCreateInterfaceAttributes retrieves the value of the InterfaceAttributes field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	t.InterfaceAttributes = &NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	return t.InterfaceAttributes
}

// GetOrCreateTargeted retrieves the value of the Targeted field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetOrCreateTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t.Targeted != nil {
		return t.Targeted
	}
	t.Targeted = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	return t.Targeted
}

// GetGlobal returns the value of the Global struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Global is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetGlobal() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	if t != nil && t.Global != nil {
		return t.Global
	}
	return nil
}

// GetInterfaceAttributes returns the value of the InterfaceAttributes struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field InterfaceAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetInterfaceAttributes() *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	if t != nil && t.InterfaceAttributes != nil {
		return t.InterfaceAttributes
	}
	return nil
}

// GetTargeted returns the value of the Targeted struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp. If the receiver or the field Targeted is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) GetTargeted() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	if t != nil && t.Targeted != nil {
		return t.Targeted
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Global.PopulateDefaults()
	t.InterfaceAttributes.PopulateDefaults()
	t.Targeted.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Mpls_SignalingProtocols_Ldp_Global represents the /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global YANG schema element.
type NetworkInstance_Mpls_SignalingProtocols_Ldp_Global struct {
	ΛMetadata        []ygot.Annotation                                                   `path:"@" ygotAnnotation:"true"`
	Authentication   *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication  `path:"authentication" module:"openconfig-network-instance"`
	ΛAuthentication  []ygot.Annotation                                                   `path:"@authentication" ygotAnnotation:"true"`
	GracefulRestart  *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart `path:"graceful-restart" module:"openconfig-network-instance"`
	ΛGracefulRestart []ygot.Annotation                                                   `path:"@graceful-restart" ygotAnnotation:"true"`
	LsrId            *string                                                             `path:"config/lsr-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLsrId           []ygot.Annotation                                                   `path:"config/@lsr-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Mpls_SignalingProtocols_Ldp_Global implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	return t.Authentication
}

// GetOrCreateGracefulRestart retrieves the value of the GracefulRestart field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetOrCreateGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	t.GracefulRestart = &NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	return t.GracefulRestart
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetAuthentication() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetGracefulRestart returns the value of the GracefulRestart struct pointer
// from NetworkInstance_Mpls_SignalingProtocols_Ldp_Global. If the receiver or the field GracefulRestart is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetGracefulRestart() *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	if t != nil && t.GracefulRestart != nil {
		return t.GracefulRestart
	}
	return nil
}

// GetLsrId retrieves the value of the leaf LsrId from the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LsrId is set, it can
// safely use t.GetLsrId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LsrId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) GetLsrId() string {
	if t == nil || t.LsrId == nil {
		return ""
	}
	return *t.LsrId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Authentication.PopulateDefaults()
	t.GracefulRestart.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Mpls_SignalingProtocols_Ldp_Global"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Mpls_SignalingProtocols_Ldp_Global.
func (*NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) ΛBelongingModule() string {
	return "openconfig-network-instance"
}
