/*
Package ocygot is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.12/genutil/names.go
using the following YANG input files:
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/aft/openconfig-aft-network-instance.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/defined-sets/openconfig-defined-sets.yang
  - public/release/models/ethernet-segments/openconfig-ethernet-segments.yang
  - public/release/models/flex-algo/openconfig-flexalgo.yang
  - public/release/models/gribi/openconfig-gribi.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ethernet-ext.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/keychain/openconfig-keychain.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/macsec/openconfig-macsec.yang
  - public/release/models/mpls/openconfig-mpls.yang
  - public/release/models/multicast/openconfig-igmp.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/optical-transport/openconfig-optical-amplifier.yang
  - public/release/models/optical-transport/openconfig-terminal-device.yang
  - public/release/models/optical-transport/openconfig-transport-line-protection.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/ospf/openconfig-ospf-policy.yang
  - public/release/models/pcep/openconfig-pcep.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-routing-policy.yang
  - public/release/models/probes/openconfig-probes.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/relay-agent/openconfig-relay-agent.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/sampling/openconfig-sampling.yang
  - public/release/models/segment-routing/openconfig-segment-routing.yang
  - public/release/models/stp/openconfig-spanning-tree.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/telemetry/openconfig-telemetry.yang
  - public/release/models/vlan/openconfig-vlan.yang

Imported modules were sourced from:
  - public/...
*/
package ocygot

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Lacp_Interface_Member_Counters represents the /openconfig-lacp/lacp/interfaces/interface/members/member/state/counters YANG schema element.
type Lacp_Interface_Member_Counters struct {
	ΛMetadata               []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	LacpErrors              *uint64           `path:"lacp-errors" module:"openconfig-lacp"`
	ΛLacpErrors             []ygot.Annotation `path:"@lacp-errors" ygotAnnotation:"true"`
	LacpInPkts              *uint64           `path:"lacp-in-pkts" module:"openconfig-lacp"`
	ΛLacpInPkts             []ygot.Annotation `path:"@lacp-in-pkts" ygotAnnotation:"true"`
	LacpOutPkts             *uint64           `path:"lacp-out-pkts" module:"openconfig-lacp"`
	ΛLacpOutPkts            []ygot.Annotation `path:"@lacp-out-pkts" ygotAnnotation:"true"`
	LacpRxErrors            *uint64           `path:"lacp-rx-errors" module:"openconfig-lacp"`
	ΛLacpRxErrors           []ygot.Annotation `path:"@lacp-rx-errors" ygotAnnotation:"true"`
	LacpTimeoutTransitions  *uint64           `path:"lacp-timeout-transitions" module:"openconfig-lacp"`
	ΛLacpTimeoutTransitions []ygot.Annotation `path:"@lacp-timeout-transitions" ygotAnnotation:"true"`
	LacpTxErrors            *uint64           `path:"lacp-tx-errors" module:"openconfig-lacp"`
	ΛLacpTxErrors           []ygot.Annotation `path:"@lacp-tx-errors" ygotAnnotation:"true"`
	LacpUnknownErrors       *uint64           `path:"lacp-unknown-errors" module:"openconfig-lacp"`
	ΛLacpUnknownErrors      []ygot.Annotation `path:"@lacp-unknown-errors" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member_Counters) IsYANGGoStruct() {}

// GetLacpErrors retrieves the value of the leaf LacpErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpErrors is set, it can
// safely use t.GetLacpErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpErrors() uint64 {
	if t == nil || t.LacpErrors == nil {
		return 0
	}
	return *t.LacpErrors
}

// GetLacpInPkts retrieves the value of the leaf LacpInPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpInPkts is set, it can
// safely use t.GetLacpInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpInPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpInPkts() uint64 {
	if t == nil || t.LacpInPkts == nil {
		return 0
	}
	return *t.LacpInPkts
}

// GetLacpOutPkts retrieves the value of the leaf LacpOutPkts from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpOutPkts is set, it can
// safely use t.GetLacpOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpOutPkts == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpOutPkts() uint64 {
	if t == nil || t.LacpOutPkts == nil {
		return 0
	}
	return *t.LacpOutPkts
}

// GetLacpRxErrors retrieves the value of the leaf LacpRxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpRxErrors is set, it can
// safely use t.GetLacpRxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpRxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpRxErrors() uint64 {
	if t == nil || t.LacpRxErrors == nil {
		return 0
	}
	return *t.LacpRxErrors
}

// GetLacpTimeoutTransitions retrieves the value of the leaf LacpTimeoutTransitions from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTimeoutTransitions is set, it can
// safely use t.GetLacpTimeoutTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTimeoutTransitions == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTimeoutTransitions() uint64 {
	if t == nil || t.LacpTimeoutTransitions == nil {
		return 0
	}
	return *t.LacpTimeoutTransitions
}

// GetLacpTxErrors retrieves the value of the leaf LacpTxErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpTxErrors is set, it can
// safely use t.GetLacpTxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpTxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpTxErrors() uint64 {
	if t == nil || t.LacpTxErrors == nil {
		return 0
	}
	return *t.LacpTxErrors
}

// GetLacpUnknownErrors retrieves the value of the leaf LacpUnknownErrors from the Lacp_Interface_Member_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpUnknownErrors is set, it can
// safely use t.GetLacpUnknownErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpUnknownErrors == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member_Counters) GetLacpUnknownErrors() uint64 {
	if t == nil || t.LacpUnknownErrors == nil {
		return 0
	}
	return *t.LacpUnknownErrors
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member_Counters.
func (*Lacp_Interface_Member_Counters) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lldp represents the /openconfig-lldp/lldp YANG schema element.
type Lldp struct {
	ΛMetadata                 []ygot.Annotation          `path:"@" ygotAnnotation:"true"`
	ChassisId                 *string                    `path:"config/chassis-id" module:"openconfig-lldp/openconfig-lldp"`
	ΛChassisId                []ygot.Annotation          `path:"config/@chassis-id" ygotAnnotation:"true"`
	ChassisIdType             E_LldpTypes_ChassisIdType  `path:"config/chassis-id-type" module:"openconfig-lldp/openconfig-lldp"`
	ΛChassisIdType            []ygot.Annotation          `path:"config/@chassis-id-type" ygotAnnotation:"true"`
	Counters                  *Lldp_Counters             `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	ΛCounters                 []ygot.Annotation          `path:"state/@counters" ygotAnnotation:"true"`
	Enabled                   *bool                      `path:"config/enabled" module:"openconfig-lldp/openconfig-lldp"`
	ΛEnabled                  []ygot.Annotation          `path:"config/@enabled" ygotAnnotation:"true"`
	HelloTimer                *uint64                    `path:"config/hello-timer" module:"openconfig-lldp/openconfig-lldp"`
	ΛHelloTimer               []ygot.Annotation          `path:"config/@hello-timer" ygotAnnotation:"true"`
	Interface                 map[string]*Lldp_Interface `path:"interfaces/interface" module:"openconfig-lldp/openconfig-lldp"`
	ΛInterface                []ygot.Annotation          `path:"interfaces/@interface" ygotAnnotation:"true"`
	SuppressTlvAdvertisement  []E_LldpTypes_LLDP_TLV     `path:"config/suppress-tlv-advertisement" module:"openconfig-lldp/openconfig-lldp"`
	ΛSuppressTlvAdvertisement []ygot.Annotation          `path:"config/@suppress-tlv-advertisement" ygotAnnotation:"true"`
	SystemDescription         *string                    `path:"config/system-description" module:"openconfig-lldp/openconfig-lldp"`
	ΛSystemDescription        []ygot.Annotation          `path:"config/@system-description" ygotAnnotation:"true"`
	SystemName                *string                    `path:"config/system-name" module:"openconfig-lldp/openconfig-lldp"`
	ΛSystemName               []ygot.Annotation          `path:"config/@system-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp) NewInterface(Name string) (*Lldp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp) GetOrCreateInterface(Name string) *Lldp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp) GetInterface(Name string) *Lldp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lldp. If there is no such element, the function
// is a no-op.
func (t *Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lldp_Interface struct to the
// list Interface of Lldp. If the key value(s) specified in
// the supplied Lldp_Interface already exist in the list, an error is
// returned.
func (t *Lldp) AppendInterface(v *Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp) GetOrCreateCounters() *Lldp_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp) GetCounters() *Lldp_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 0
	}
	return *t.HelloTimer
}

// GetSuppressTlvAdvertisement retrieves the value of the leaf SuppressTlvAdvertisement from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressTlvAdvertisement is set, it can
// safely use t.GetSuppressTlvAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressTlvAdvertisement == nil' before retrieving the leaf's value.
func (t *Lldp) GetSuppressTlvAdvertisement() []E_LldpTypes_LLDP_TLV {
	if t == nil || t.SuppressTlvAdvertisement == nil {
		return nil
	}
	return t.SuppressTlvAdvertisement
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp.
func (*Lldp) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Counters represents the /openconfig-lldp/lldp/state/counters YANG schema element.
type Lldp_Counters struct {
	ΛMetadata       []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	EntriesAgedOut  *uint64           `path:"entries-aged-out" module:"openconfig-lldp"`
	ΛEntriesAgedOut []ygot.Annotation `path:"@entries-aged-out" ygotAnnotation:"true"`
	FrameDiscard    *uint64           `path:"frame-discard" module:"openconfig-lldp"`
	ΛFrameDiscard   []ygot.Annotation `path:"@frame-discard" ygotAnnotation:"true"`
	FrameErrorIn    *uint64           `path:"frame-error-in" module:"openconfig-lldp"`
	ΛFrameErrorIn   []ygot.Annotation `path:"@frame-error-in" ygotAnnotation:"true"`
	FrameIn         *uint64           `path:"frame-in" module:"openconfig-lldp"`
	ΛFrameIn        []ygot.Annotation `path:"@frame-in" ygotAnnotation:"true"`
	FrameOut        *uint64           `path:"frame-out" module:"openconfig-lldp"`
	ΛFrameOut       []ygot.Annotation `path:"@frame-out" ygotAnnotation:"true"`
	LastClear       *string           `path:"last-clear" module:"openconfig-lldp"`
	ΛLastClear      []ygot.Annotation `path:"@last-clear" ygotAnnotation:"true"`
	TlvAccepted     *uint64           `path:"tlv-accepted" module:"openconfig-lldp"`
	ΛTlvAccepted    []ygot.Annotation `path:"@tlv-accepted" ygotAnnotation:"true"`
	TlvDiscard      *uint64           `path:"tlv-discard" module:"openconfig-lldp"`
	ΛTlvDiscard     []ygot.Annotation `path:"@tlv-discard" ygotAnnotation:"true"`
	TlvUnknown      *uint64           `path:"tlv-unknown" module:"openconfig-lldp"`
	ΛTlvUnknown     []ygot.Annotation `path:"@tlv-unknown" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Counters) IsYANGGoStruct() {}

// GetEntriesAgedOut retrieves the value of the leaf EntriesAgedOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntriesAgedOut is set, it can
// safely use t.GetEntriesAgedOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntriesAgedOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetEntriesAgedOut() uint64 {
	if t == nil || t.EntriesAgedOut == nil {
		return 0
	}
	return *t.EntriesAgedOut
}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvAccepted retrieves the value of the leaf TlvAccepted from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvAccepted is set, it can
// safely use t.GetTlvAccepted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvAccepted == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvAccepted() uint64 {
	if t == nil || t.TlvAccepted == nil {
		return 0
	}
	return *t.TlvAccepted
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Counters.
func (*Lldp_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface represents the /openconfig-lldp/lldp/interfaces/interface YANG schema element.
type Lldp_Interface struct {
	ΛMetadata []ygot.Annotation                   `path:"@" ygotAnnotation:"true"`
	Counters  *Lldp_Interface_Counters            `path:"state/counters" module:"openconfig-lldp/openconfig-lldp"`
	ΛCounters []ygot.Annotation                   `path:"state/@counters" ygotAnnotation:"true"`
	Enabled   *bool                               `path:"config/enabled" module:"openconfig-lldp/openconfig-lldp"`
	ΛEnabled  []ygot.Annotation                   `path:"config/@enabled" ygotAnnotation:"true"`
	Name      *string                             `path:"config/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛName     []ygot.Annotation                   `path:"config/@name|@name" ygotAnnotation:"true"`
	Neighbor  map[string]*Lldp_Interface_Neighbor `path:"neighbors/neighbor" module:"openconfig-lldp/openconfig-lldp"`
	ΛNeighbor []ygot.Annotation                   `path:"neighbors/@neighbor" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface) NewNeighbor(Id string) (*Lldp_Interface_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Lldp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Id = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Lldp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface) GetOrCreateNeighbor(Id string) *Lldp_Interface_Neighbor {

	key := Id

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Lldp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface) GetNeighbor(Id string) *Lldp_Interface_Neighbor {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Lldp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface) DeleteNeighbor(Id string) {
	key := Id

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Lldp_Interface_Neighbor struct to the
// list Neighbor of Lldp_Interface. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor already exist in the list, an error is
// returned.
func (t *Lldp_Interface) AppendNeighbor(v *Lldp_Interface_Neighbor) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Lldp_Interface_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lldp_Interface) GetOrCreateCounters() *Lldp_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lldp_Interface_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lldp_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lldp_Interface) GetCounters() *Lldp_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface struct, which is a YANG list entry.
func (t *Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface.
func (*Lldp_Interface) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Counters represents the /openconfig-lldp/lldp/interfaces/interface/state/counters YANG schema element.
type Lldp_Interface_Counters struct {
	ΛMetadata      []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	FrameDiscard   *uint64           `path:"frame-discard" module:"openconfig-lldp"`
	ΛFrameDiscard  []ygot.Annotation `path:"@frame-discard" ygotAnnotation:"true"`
	FrameErrorIn   *uint64           `path:"frame-error-in" module:"openconfig-lldp"`
	ΛFrameErrorIn  []ygot.Annotation `path:"@frame-error-in" ygotAnnotation:"true"`
	FrameErrorOut  *uint64           `path:"frame-error-out" module:"openconfig-lldp"`
	ΛFrameErrorOut []ygot.Annotation `path:"@frame-error-out" ygotAnnotation:"true"`
	FrameIn        *uint64           `path:"frame-in" module:"openconfig-lldp"`
	ΛFrameIn       []ygot.Annotation `path:"@frame-in" ygotAnnotation:"true"`
	FrameOut       *uint64           `path:"frame-out" module:"openconfig-lldp"`
	ΛFrameOut      []ygot.Annotation `path:"@frame-out" ygotAnnotation:"true"`
	LastClear      *string           `path:"last-clear" module:"openconfig-lldp"`
	ΛLastClear     []ygot.Annotation `path:"@last-clear" ygotAnnotation:"true"`
	TlvDiscard     *uint64           `path:"tlv-discard" module:"openconfig-lldp"`
	ΛTlvDiscard    []ygot.Annotation `path:"@tlv-discard" ygotAnnotation:"true"`
	TlvUnknown     *uint64           `path:"tlv-unknown" module:"openconfig-lldp"`
	ΛTlvUnknown    []ygot.Annotation `path:"@tlv-unknown" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Counters) IsYANGGoStruct() {}

// GetFrameDiscard retrieves the value of the leaf FrameDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameDiscard is set, it can
// safely use t.GetFrameDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameDiscard() uint64 {
	if t == nil || t.FrameDiscard == nil {
		return 0
	}
	return *t.FrameDiscard
}

// GetFrameErrorIn retrieves the value of the leaf FrameErrorIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorIn is set, it can
// safely use t.GetFrameErrorIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorIn() uint64 {
	if t == nil || t.FrameErrorIn == nil {
		return 0
	}
	return *t.FrameErrorIn
}

// GetFrameErrorOut retrieves the value of the leaf FrameErrorOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameErrorOut is set, it can
// safely use t.GetFrameErrorOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameErrorOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameErrorOut() uint64 {
	if t == nil || t.FrameErrorOut == nil {
		return 0
	}
	return *t.FrameErrorOut
}

// GetFrameIn retrieves the value of the leaf FrameIn from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameIn is set, it can
// safely use t.GetFrameIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameIn == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameIn() uint64 {
	if t == nil || t.FrameIn == nil {
		return 0
	}
	return *t.FrameIn
}

// GetFrameOut retrieves the value of the leaf FrameOut from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameOut is set, it can
// safely use t.GetFrameOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameOut == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetFrameOut() uint64 {
	if t == nil || t.FrameOut == nil {
		return 0
	}
	return *t.FrameOut
}

// GetLastClear retrieves the value of the leaf LastClear from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetLastClear() string {
	if t == nil || t.LastClear == nil {
		return ""
	}
	return *t.LastClear
}

// GetTlvDiscard retrieves the value of the leaf TlvDiscard from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvDiscard is set, it can
// safely use t.GetTlvDiscard() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvDiscard == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvDiscard() uint64 {
	if t == nil || t.TlvDiscard == nil {
		return 0
	}
	return *t.TlvDiscard
}

// GetTlvUnknown retrieves the value of the leaf TlvUnknown from the Lldp_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlvUnknown is set, it can
// safely use t.GetTlvUnknown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlvUnknown == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Counters) GetTlvUnknown() uint64 {
	if t == nil || t.TlvUnknown == nil {
		return 0
	}
	return *t.TlvUnknown
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Counters.
func (*Lldp_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor YANG schema element.
type Lldp_Interface_Neighbor struct {
	ΛMetadata              []ygot.Annotation                                                          `path:"@" ygotAnnotation:"true"`
	Age                    *uint64                                                                    `path:"state/age" module:"openconfig-lldp/openconfig-lldp"`
	ΛAge                   []ygot.Annotation                                                          `path:"state/@age" ygotAnnotation:"true"`
	Capability             map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability `path:"capabilities/capability" module:"openconfig-lldp/openconfig-lldp"`
	ΛCapability            []ygot.Annotation                                                          `path:"capabilities/@capability" ygotAnnotation:"true"`
	ChassisId              *string                                                                    `path:"state/chassis-id" module:"openconfig-lldp/openconfig-lldp"`
	ΛChassisId             []ygot.Annotation                                                          `path:"state/@chassis-id" ygotAnnotation:"true"`
	ChassisIdType          E_LldpTypes_ChassisIdType                                                  `path:"state/chassis-id-type" module:"openconfig-lldp/openconfig-lldp"`
	ΛChassisIdType         []ygot.Annotation                                                          `path:"state/@chassis-id-type" ygotAnnotation:"true"`
	Id                     *string                                                                    `path:"state/id|id" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛId                    []ygot.Annotation                                                          `path:"state/@id|@id" ygotAnnotation:"true"`
	LastUpdate             *int64                                                                     `path:"state/last-update" module:"openconfig-lldp/openconfig-lldp"`
	ΛLastUpdate            []ygot.Annotation                                                          `path:"state/@last-update" ygotAnnotation:"true"`
	ManagementAddress      *string                                                                    `path:"state/management-address" module:"openconfig-lldp/openconfig-lldp"`
	ΛManagementAddress     []ygot.Annotation                                                          `path:"state/@management-address" ygotAnnotation:"true"`
	ManagementAddressType  *string                                                                    `path:"state/management-address-type" module:"openconfig-lldp/openconfig-lldp"`
	ΛManagementAddressType []ygot.Annotation                                                          `path:"state/@management-address-type" ygotAnnotation:"true"`
	PortDescription        *string                                                                    `path:"state/port-description" module:"openconfig-lldp/openconfig-lldp"`
	ΛPortDescription       []ygot.Annotation                                                          `path:"state/@port-description" ygotAnnotation:"true"`
	PortId                 *string                                                                    `path:"state/port-id" module:"openconfig-lldp/openconfig-lldp"`
	ΛPortId                []ygot.Annotation                                                          `path:"state/@port-id" ygotAnnotation:"true"`
	PortIdType             E_LldpTypes_PortIdType                                                     `path:"state/port-id-type" module:"openconfig-lldp/openconfig-lldp"`
	ΛPortIdType            []ygot.Annotation                                                          `path:"state/@port-id-type" ygotAnnotation:"true"`
	SystemDescription      *string                                                                    `path:"state/system-description" module:"openconfig-lldp/openconfig-lldp"`
	ΛSystemDescription     []ygot.Annotation                                                          `path:"state/@system-description" ygotAnnotation:"true"`
	SystemName             *string                                                                    `path:"state/system-name" module:"openconfig-lldp/openconfig-lldp"`
	ΛSystemName            []ygot.Annotation                                                          `path:"state/@system-name" ygotAnnotation:"true"`
	Tlv                    map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv           `path:"custom-tlvs/tlv" module:"openconfig-lldp/openconfig-lldp"`
	ΛTlv                   []ygot.Annotation                                                          `path:"custom-tlvs/@tlv" ygotAnnotation:"true"`
	Ttl                    *uint16                                                                    `path:"state/ttl" module:"openconfig-lldp/openconfig-lldp"`
	ΛTtl                   []ygot.Annotation                                                          `path:"state/@ttl" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor) IsYANGGoStruct() {}

// Lldp_Interface_Neighbor_Tlv_Key represents the key for list Tlv of element /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor.
type Lldp_Interface_Neighbor_Tlv_Key struct {
	Type       int32  `path:"type"`
	Oui        string `path:"oui"`
	OuiSubtype string `path:"oui-subtype"`
}

// IsYANGGoKeyStruct ensures that Lldp_Interface_Neighbor_Tlv_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Lldp_Interface_Neighbor_Tlv_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the Lldp_Interface_Neighbor_Tlv_Key key struct.
func (t Lldp_Interface_Neighbor_Tlv_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"type":        t.Type,
		"oui":         t.Oui,
		"oui-subtype": t.OuiSubtype,
	}, nil
}

// NewCapability creates a new entry in the Capability list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) (*Lldp_Interface_Neighbor_Capability, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &Lldp_Interface_Neighbor_Capability{
		Name: Name,
	}

	return t.Capability[key], nil
}

// RenameCapability renames an entry in the list Capability within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameCapability(oldK, newK E_LldpTypes_LLDP_SYSTEM_CAPABILITY) error {
	if _, ok := t.Capability[newK]; ok {
		return fmt.Errorf("key %v already exists in Capability", newK)
	}

	e, ok := t.Capability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Capability", oldK)
	}
	e.Name = newK

	t.Capability[newK] = e
	delete(t.Capability, oldK)
	return nil
}

// GetOrCreateCapability retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	key := Name

	if v, ok := t.Capability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCapability(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCapability got unexpected error: %v", err))
	}
	return v
}

// GetCapability retrieves the value with the specified key from
// the Capability map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) *Lldp_Interface_Neighbor_Capability {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Capability[key]; ok {
		return lm
	}
	return nil
}

// DeleteCapability deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteCapability(Name E_LldpTypes_LLDP_SYSTEM_CAPABILITY) {
	key := Name

	delete(t.Capability, key)
}

// AppendCapability appends the supplied Lldp_Interface_Neighbor_Capability struct to the
// list Capability of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Capability already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendCapability(v *Lldp_Interface_Neighbor_Capability) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[E_LldpTypes_LLDP_SYSTEM_CAPABILITY]*Lldp_Interface_Neighbor_Capability)
	}

	if _, ok := t.Capability[key]; ok {
		return fmt.Errorf("duplicate key for list Capability %v", key)
	}

	t.Capability[key] = v
	return nil
}

// NewTlv creates a new entry in the Tlv list of the
// Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *Lldp_Interface_Neighbor) NewTlv(Type int32, Oui string, OuiSubtype string) (*Lldp_Interface_Neighbor_Tlv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tlv", key)
	}

	t.Tlv[key] = &Lldp_Interface_Neighbor_Tlv{
		Type:       &Type,
		Oui:        &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.Tlv[key], nil
}

// RenameTlv renames an entry in the list Tlv within
// the Lldp_Interface_Neighbor struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lldp_Interface_Neighbor) RenameTlv(oldK, newK Lldp_Interface_Neighbor_Tlv_Key) error {
	if _, ok := t.Tlv[newK]; ok {
		return fmt.Errorf("key %v already exists in Tlv", newK)
	}

	e, ok := t.Tlv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tlv", oldK)
	}
	e.Type = &newK.Type
	e.Oui = &newK.Oui
	e.OuiSubtype = &newK.OuiSubtype

	t.Tlv[newK] = e
	delete(t.Tlv, oldK)
	return nil
}

// GetOrCreateTlv retrieves the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lldp_Interface_Neighbor) GetOrCreateTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if v, ok := t.Tlv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTlv(Type, Oui, OuiSubtype)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTlv got unexpected error: %v", err))
	}
	return v
}

// GetTlv retrieves the value with the specified key from
// the Tlv map field of Lldp_Interface_Neighbor. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lldp_Interface_Neighbor) GetTlv(Type int32, Oui string, OuiSubtype string) *Lldp_Interface_Neighbor_Tlv {

	if t == nil {
		return nil
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	if lm, ok := t.Tlv[key]; ok {
		return lm
	}
	return nil
}

// DeleteTlv deletes the value with the specified keys from
// the receiver Lldp_Interface_Neighbor. If there is no such element, the function
// is a no-op.
func (t *Lldp_Interface_Neighbor) DeleteTlv(Type int32, Oui string, OuiSubtype string) {
	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       Type,
		Oui:        Oui,
		OuiSubtype: OuiSubtype,
	}

	delete(t.Tlv, key)
}

// AppendTlv appends the supplied Lldp_Interface_Neighbor_Tlv struct to the
// list Tlv of Lldp_Interface_Neighbor. If the key value(s) specified in
// the supplied Lldp_Interface_Neighbor_Tlv already exist in the list, an error is
// returned.
func (t *Lldp_Interface_Neighbor) AppendTlv(v *Lldp_Interface_Neighbor_Tlv) error {
	if v.Type == nil {
		return fmt.Errorf("invalid nil key for Type")
	}

	if v.Oui == nil {
		return fmt.Errorf("invalid nil key for Oui")
	}

	if v.OuiSubtype == nil {
		return fmt.Errorf("invalid nil key for OuiSubtype")
	}

	key := Lldp_Interface_Neighbor_Tlv_Key{
		Type:       *v.Type,
		Oui:        *v.Oui,
		OuiSubtype: *v.OuiSubtype,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tlv == nil {
		t.Tlv = make(map[Lldp_Interface_Neighbor_Tlv_Key]*Lldp_Interface_Neighbor_Tlv)
	}

	if _, ok := t.Tlv[key]; ok {
		return fmt.Errorf("duplicate key for list Tlv %v", key)
	}

	t.Tlv[key] = v
	return nil
}

// GetAge retrieves the value of the leaf Age from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Age is set, it can
// safely use t.GetAge() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Age == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetAge() uint64 {
	if t == nil || t.Age == nil {
		return 0
	}
	return *t.Age
}

// GetChassisId retrieves the value of the leaf ChassisId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisId is set, it can
// safely use t.GetChassisId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisId() string {
	if t == nil || t.ChassisId == nil {
		return ""
	}
	return *t.ChassisId
}

// GetChassisIdType retrieves the value of the leaf ChassisIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChassisIdType is set, it can
// safely use t.GetChassisIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChassisIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetChassisIdType() E_LldpTypes_ChassisIdType {
	if t == nil || t.ChassisIdType == 0 {
		return 0
	}
	return t.ChassisIdType
}

// GetId retrieves the value of the leaf Id from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLastUpdate retrieves the value of the leaf LastUpdate from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastUpdate is set, it can
// safely use t.GetLastUpdate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastUpdate == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetLastUpdate() int64 {
	if t == nil || t.LastUpdate == nil {
		return 0
	}
	return *t.LastUpdate
}

// GetManagementAddress retrieves the value of the leaf ManagementAddress from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddress is set, it can
// safely use t.GetManagementAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddress == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddress() string {
	if t == nil || t.ManagementAddress == nil {
		return ""
	}
	return *t.ManagementAddress
}

// GetManagementAddressType retrieves the value of the leaf ManagementAddressType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagementAddressType is set, it can
// safely use t.GetManagementAddressType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagementAddressType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetManagementAddressType() string {
	if t == nil || t.ManagementAddressType == nil {
		return ""
	}
	return *t.ManagementAddressType
}

// GetPortDescription retrieves the value of the leaf PortDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortDescription is set, it can
// safely use t.GetPortDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortDescription() string {
	if t == nil || t.PortDescription == nil {
		return ""
	}
	return *t.PortDescription
}

// GetPortId retrieves the value of the leaf PortId from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPortIdType retrieves the value of the leaf PortIdType from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortIdType is set, it can
// safely use t.GetPortIdType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortIdType == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetPortIdType() E_LldpTypes_PortIdType {
	if t == nil || t.PortIdType == 0 {
		return 0
	}
	return t.PortIdType
}

// GetSystemDescription retrieves the value of the leaf SystemDescription from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemDescription is set, it can
// safely use t.GetSystemDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemDescription == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemDescription() string {
	if t == nil || t.SystemDescription == nil {
		return ""
	}
	return *t.SystemDescription
}

// GetSystemName retrieves the value of the leaf SystemName from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemName is set, it can
// safely use t.GetSystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemName == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetSystemName() string {
	if t == nil || t.SystemName == nil {
		return ""
	}
	return *t.SystemName
}

// GetTtl retrieves the value of the leaf Ttl from the Lldp_Interface_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ttl is set, it can
// safely use t.GetTtl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ttl == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor) GetTtl() uint16 {
	if t == nil || t.Ttl == nil {
		return 0
	}
	return *t.Ttl
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Capability {
		e.PopulateDefaults()
	}
	for _, e := range t.Tlv {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor.
func (*Lldp_Interface_Neighbor) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Capability represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/capabilities/capability YANG schema element.
type Lldp_Interface_Neighbor_Capability struct {
	ΛMetadata []ygot.Annotation                  `path:"@" ygotAnnotation:"true"`
	Enabled   *bool                              `path:"state/enabled" module:"openconfig-lldp/openconfig-lldp"`
	ΛEnabled  []ygot.Annotation                  `path:"state/@enabled" ygotAnnotation:"true"`
	Name      E_LldpTypes_LLDP_SYSTEM_CAPABILITY `path:"state/name|name" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛName     []ygot.Annotation                  `path:"state/@name|@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Capability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Capability) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetName retrieves the value of the leaf Name from the Lldp_Interface_Neighbor_Capability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Capability) GetName() E_LldpTypes_LLDP_SYSTEM_CAPABILITY {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Capability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Capability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Capability.
func (*Lldp_Interface_Neighbor_Capability) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Lldp_Interface_Neighbor_Tlv represents the /openconfig-lldp/lldp/interfaces/interface/neighbors/neighbor/custom-tlvs/tlv YANG schema element.
type Lldp_Interface_Neighbor_Tlv struct {
	ΛMetadata   []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Oui         *string           `path:"state/oui|oui" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛOui        []ygot.Annotation `path:"state/@oui|@oui" ygotAnnotation:"true"`
	OuiSubtype  *string           `path:"state/oui-subtype|oui-subtype" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛOuiSubtype []ygot.Annotation `path:"state/@oui-subtype|@oui-subtype" ygotAnnotation:"true"`
	Type        *int32            `path:"state/type|type" module:"openconfig-lldp/openconfig-lldp|openconfig-lldp"`
	ΛType       []ygot.Annotation `path:"state/@type|@type" ygotAnnotation:"true"`
	Value       Binary            `path:"state/value" module:"openconfig-lldp/openconfig-lldp"`
	ΛValue      []ygot.Annotation `path:"state/@value" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lldp_Interface_Neighbor_Tlv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lldp_Interface_Neighbor_Tlv) IsYANGGoStruct() {}

// GetOui retrieves the value of the leaf Oui from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Oui is set, it can
// safely use t.GetOui() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Oui == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOui() string {
	if t == nil || t.Oui == nil {
		return ""
	}
	return *t.Oui
}

// GetOuiSubtype retrieves the value of the leaf OuiSubtype from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuiSubtype is set, it can
// safely use t.GetOuiSubtype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuiSubtype == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetOuiSubtype() string {
	if t == nil || t.OuiSubtype == nil {
		return ""
	}
	return *t.OuiSubtype
}

// GetType retrieves the value of the leaf Type from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// GetValue retrieves the value of the leaf Value from the Lldp_Interface_Neighbor_Tlv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *Lldp_Interface_Neighbor_Tlv) GetValue() Binary {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the Lldp_Interface_Neighbor_Tlv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lldp_Interface_Neighbor_Tlv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Lldp_Interface_Neighbor_Tlv struct, which is a YANG list entry.
func (t *Lldp_Interface_Neighbor_Tlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui":         *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type":        *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lldp_Interface_Neighbor_Tlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lldp_Interface_Neighbor_Tlv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lldp_Interface_Neighbor_Tlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lldp_Interface_Neighbor_Tlv.
func (*Lldp_Interface_Neighbor_Tlv) ΛBelongingModule() string {
	return "openconfig-lldp"
}

// Macsec represents the /openconfig-macsec/macsec YANG schema element.
type Macsec struct {
	ΛMetadata  []ygot.Annotation            `path:"@" ygotAnnotation:"true"`
	Interface  map[string]*Macsec_Interface `path:"interfaces/interface" module:"openconfig-macsec/openconfig-macsec"`
	ΛInterface []ygot.Annotation            `path:"interfaces/@interface" ygotAnnotation:"true"`
	Mka        *Macsec_Mka                  `path:"mka" module:"openconfig-macsec"`
	ΛMka       []ygot.Annotation            `path:"@mka" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Macsec struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec) NewInterface(Name string) (*Macsec_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Macsec_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Macsec_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Macsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Macsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec) GetOrCreateInterface(Name string) *Macsec_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Macsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec) GetInterface(Name string) *Macsec_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Macsec. If there is no such element, the function
// is a no-op.
func (t *Macsec) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Macsec_Interface struct to the
// list Interface of Macsec. If the key value(s) specified in
// the supplied Macsec_Interface already exist in the list, an error is
// returned.
func (t *Macsec) AppendInterface(v *Macsec_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Macsec_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *Macsec) GetOrCreateMka() *Macsec_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &Macsec_Mka{}
	return t.Mka
}

// GetMka returns the value of the Mka struct pointer
// from Macsec. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec) GetMka() *Macsec_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Mka.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec.
func (*Macsec) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface represents the /openconfig-macsec/macsec/interfaces/interface YANG schema element.
type Macsec_Interface struct {
	ΛMetadata         []ygot.Annotation                   `path:"@" ygotAnnotation:"true"`
	Counters          *Macsec_Interface_Counters          `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	ΛCounters         []ygot.Annotation                   `path:"state/@counters" ygotAnnotation:"true"`
	Enable            *bool                               `path:"config/enable" module:"openconfig-macsec/openconfig-macsec"`
	ΛEnable           []ygot.Annotation                   `path:"config/@enable" ygotAnnotation:"true"`
	Mka               *Macsec_Interface_Mka               `path:"mka" module:"openconfig-macsec"`
	ΛMka              []ygot.Annotation                   `path:"@mka" ygotAnnotation:"true"`
	Name              *string                             `path:"config/name|name" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	ΛName             []ygot.Annotation                   `path:"config/@name|@name" ygotAnnotation:"true"`
	ReplayProtection  *uint16                             `path:"config/replay-protection" module:"openconfig-macsec/openconfig-macsec"`
	ΛReplayProtection []ygot.Annotation                   `path:"config/@replay-protection" ygotAnnotation:"true"`
	ScsaRx            map[string]*Macsec_Interface_ScsaRx `path:"scsa-rx/scsa-rx" module:"openconfig-macsec/openconfig-macsec"`
	ΛScsaRx           []ygot.Annotation                   `path:"scsa-rx/@scsa-rx" ygotAnnotation:"true"`
	ScsaTx            map[string]*Macsec_Interface_ScsaTx `path:"scsa-tx/scsa-tx" module:"openconfig-macsec/openconfig-macsec"`
	ΛScsaTx           []ygot.Annotation                   `path:"scsa-tx/@scsa-tx" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface) IsYANGGoStruct() {}

// NewScsaRx creates a new entry in the ScsaRx list of the
// Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Interface) NewScsaRx(SciRx string) (*Macsec_Interface_ScsaRx, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaRx == nil {
		t.ScsaRx = make(map[string]*Macsec_Interface_ScsaRx)
	}

	key := SciRx

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ScsaRx[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ScsaRx", key)
	}

	t.ScsaRx[key] = &Macsec_Interface_ScsaRx{
		SciRx: &SciRx,
	}

	return t.ScsaRx[key], nil
}

// RenameScsaRx renames an entry in the list ScsaRx within
// the Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Interface) RenameScsaRx(oldK, newK string) error {
	if _, ok := t.ScsaRx[newK]; ok {
		return fmt.Errorf("key %v already exists in ScsaRx", newK)
	}

	e, ok := t.ScsaRx[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ScsaRx", oldK)
	}
	e.SciRx = &newK

	t.ScsaRx[newK] = e
	delete(t.ScsaRx, oldK)
	return nil
}

// GetOrCreateScsaRx retrieves the value with the specified keys from
// the receiver Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Interface) GetOrCreateScsaRx(SciRx string) *Macsec_Interface_ScsaRx {

	key := SciRx

	if v, ok := t.ScsaRx[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScsaRx(SciRx)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScsaRx got unexpected error: %v", err))
	}
	return v
}

// GetScsaRx retrieves the value with the specified key from
// the ScsaRx map field of Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Interface) GetScsaRx(SciRx string) *Macsec_Interface_ScsaRx {

	if t == nil {
		return nil
	}

	key := SciRx

	if lm, ok := t.ScsaRx[key]; ok {
		return lm
	}
	return nil
}

// DeleteScsaRx deletes the value with the specified keys from
// the receiver Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *Macsec_Interface) DeleteScsaRx(SciRx string) {
	key := SciRx

	delete(t.ScsaRx, key)
}

// AppendScsaRx appends the supplied Macsec_Interface_ScsaRx struct to the
// list ScsaRx of Macsec_Interface. If the key value(s) specified in
// the supplied Macsec_Interface_ScsaRx already exist in the list, an error is
// returned.
func (t *Macsec_Interface) AppendScsaRx(v *Macsec_Interface_ScsaRx) error {
	if v.SciRx == nil {
		return fmt.Errorf("invalid nil key received for SciRx")
	}

	key := *v.SciRx

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaRx == nil {
		t.ScsaRx = make(map[string]*Macsec_Interface_ScsaRx)
	}

	if _, ok := t.ScsaRx[key]; ok {
		return fmt.Errorf("duplicate key for list ScsaRx %v", key)
	}

	t.ScsaRx[key] = v
	return nil
}

// NewScsaTx creates a new entry in the ScsaTx list of the
// Macsec_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Interface) NewScsaTx(SciTx string) (*Macsec_Interface_ScsaTx, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaTx == nil {
		t.ScsaTx = make(map[string]*Macsec_Interface_ScsaTx)
	}

	key := SciTx

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ScsaTx[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ScsaTx", key)
	}

	t.ScsaTx[key] = &Macsec_Interface_ScsaTx{
		SciTx: &SciTx,
	}

	return t.ScsaTx[key], nil
}

// RenameScsaTx renames an entry in the list ScsaTx within
// the Macsec_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Interface) RenameScsaTx(oldK, newK string) error {
	if _, ok := t.ScsaTx[newK]; ok {
		return fmt.Errorf("key %v already exists in ScsaTx", newK)
	}

	e, ok := t.ScsaTx[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ScsaTx", oldK)
	}
	e.SciTx = &newK

	t.ScsaTx[newK] = e
	delete(t.ScsaTx, oldK)
	return nil
}

// GetOrCreateScsaTx retrieves the value with the specified keys from
// the receiver Macsec_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Interface) GetOrCreateScsaTx(SciTx string) *Macsec_Interface_ScsaTx {

	key := SciTx

	if v, ok := t.ScsaTx[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScsaTx(SciTx)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScsaTx got unexpected error: %v", err))
	}
	return v
}

// GetScsaTx retrieves the value with the specified key from
// the ScsaTx map field of Macsec_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Interface) GetScsaTx(SciTx string) *Macsec_Interface_ScsaTx {

	if t == nil {
		return nil
	}

	key := SciTx

	if lm, ok := t.ScsaTx[key]; ok {
		return lm
	}
	return nil
}

// DeleteScsaTx deletes the value with the specified keys from
// the receiver Macsec_Interface. If there is no such element, the function
// is a no-op.
func (t *Macsec_Interface) DeleteScsaTx(SciTx string) {
	key := SciTx

	delete(t.ScsaTx, key)
}

// AppendScsaTx appends the supplied Macsec_Interface_ScsaTx struct to the
// list ScsaTx of Macsec_Interface. If the key value(s) specified in
// the supplied Macsec_Interface_ScsaTx already exist in the list, an error is
// returned.
func (t *Macsec_Interface) AppendScsaTx(v *Macsec_Interface_ScsaTx) error {
	if v.SciTx == nil {
		return fmt.Errorf("invalid nil key received for SciTx")
	}

	key := *v.SciTx

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ScsaTx == nil {
		t.ScsaTx = make(map[string]*Macsec_Interface_ScsaTx)
	}

	if _, ok := t.ScsaTx[key]; ok {
		return fmt.Errorf("duplicate key for list ScsaTx %v", key)
	}

	t.ScsaTx[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface) GetOrCreateCounters() *Macsec_Interface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_Counters{}
	return t.Counters
}

// GetOrCreateMka retrieves the value of the Mka field
// or returns the existing field if it already exists.
func (t *Macsec_Interface) GetOrCreateMka() *Macsec_Interface_Mka {
	if t.Mka != nil {
		return t.Mka
	}
	t.Mka = &Macsec_Interface_Mka{}
	return t.Mka
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface) GetCounters() *Macsec_Interface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetMka returns the value of the Mka struct pointer
// from Macsec_Interface. If the receiver or the field Mka is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface) GetMka() *Macsec_Interface_Mka {
	if t != nil && t.Mka != nil {
		return t.Mka
	}
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetName retrieves the value of the leaf Name from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetReplayProtection retrieves the value of the leaf ReplayProtection from the Macsec_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayProtection is set, it can
// safely use t.GetReplayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayProtection == nil' before retrieving the leaf's value.
func (t *Macsec_Interface) GetReplayProtection() uint16 {
	if t == nil || t.ReplayProtection == nil {
		return 0
	}
	return *t.ReplayProtection
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
	if t.ReplayProtection == nil {
		var v uint16 = 0
		t.ReplayProtection = &v
	}
	t.Counters.PopulateDefaults()
	t.Mka.PopulateDefaults()
	for _, e := range t.ScsaRx {
		e.PopulateDefaults()
	}
	for _, e := range t.ScsaTx {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Macsec_Interface struct, which is a YANG list entry.
func (t *Macsec_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface.
func (*Macsec_Interface) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Counters represents the /openconfig-macsec/macsec/interfaces/interface/state/counters YANG schema element.
type Macsec_Interface_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	RxBadtagPkts      *uint64           `path:"rx-badtag-pkts" module:"openconfig-macsec"`
	ΛRxBadtagPkts     []ygot.Annotation `path:"@rx-badtag-pkts" ygotAnnotation:"true"`
	RxLatePkts        *uint64           `path:"rx-late-pkts" module:"openconfig-macsec"`
	ΛRxLatePkts       []ygot.Annotation `path:"@rx-late-pkts" ygotAnnotation:"true"`
	RxNosciPkts       *uint64           `path:"rx-nosci-pkts" module:"openconfig-macsec"`
	ΛRxNosciPkts      []ygot.Annotation `path:"@rx-nosci-pkts" ygotAnnotation:"true"`
	RxUnknownsciPkts  *uint64           `path:"rx-unknownsci-pkts" module:"openconfig-macsec"`
	ΛRxUnknownsciPkts []ygot.Annotation `path:"@rx-unknownsci-pkts" ygotAnnotation:"true"`
	RxUntaggedPkts    *uint64           `path:"rx-untagged-pkts" module:"openconfig-macsec"`
	ΛRxUntaggedPkts   []ygot.Annotation `path:"@rx-untagged-pkts" ygotAnnotation:"true"`
	TxUntaggedPkts    *uint64           `path:"tx-untagged-pkts" module:"openconfig-macsec"`
	ΛTxUntaggedPkts   []ygot.Annotation `path:"@tx-untagged-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Counters) IsYANGGoStruct() {}

// GetRxBadtagPkts retrieves the value of the leaf RxBadtagPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxBadtagPkts is set, it can
// safely use t.GetRxBadtagPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxBadtagPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxBadtagPkts() uint64 {
	if t == nil || t.RxBadtagPkts == nil {
		return 0
	}
	return *t.RxBadtagPkts
}

// GetRxLatePkts retrieves the value of the leaf RxLatePkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxLatePkts is set, it can
// safely use t.GetRxLatePkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxLatePkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxLatePkts() uint64 {
	if t == nil || t.RxLatePkts == nil {
		return 0
	}
	return *t.RxLatePkts
}

// GetRxNosciPkts retrieves the value of the leaf RxNosciPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxNosciPkts is set, it can
// safely use t.GetRxNosciPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxNosciPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxNosciPkts() uint64 {
	if t == nil || t.RxNosciPkts == nil {
		return 0
	}
	return *t.RxNosciPkts
}

// GetRxUnknownsciPkts retrieves the value of the leaf RxUnknownsciPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxUnknownsciPkts is set, it can
// safely use t.GetRxUnknownsciPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxUnknownsciPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxUnknownsciPkts() uint64 {
	if t == nil || t.RxUnknownsciPkts == nil {
		return 0
	}
	return *t.RxUnknownsciPkts
}

// GetRxUntaggedPkts retrieves the value of the leaf RxUntaggedPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxUntaggedPkts is set, it can
// safely use t.GetRxUntaggedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxUntaggedPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetRxUntaggedPkts() uint64 {
	if t == nil || t.RxUntaggedPkts == nil {
		return 0
	}
	return *t.RxUntaggedPkts
}

// GetTxUntaggedPkts retrieves the value of the leaf TxUntaggedPkts from the Macsec_Interface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TxUntaggedPkts is set, it can
// safely use t.GetTxUntaggedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TxUntaggedPkts == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Counters) GetTxUntaggedPkts() uint64 {
	if t == nil || t.TxUntaggedPkts == nil {
		return 0
	}
	return *t.TxUntaggedPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Counters.
func (*Macsec_Interface_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Mka represents the /openconfig-macsec/macsec/interfaces/interface/mka YANG schema element.
type Macsec_Interface_Mka struct {
	ΛMetadata  []ygot.Annotation              `path:"@" ygotAnnotation:"true"`
	Counters   *Macsec_Interface_Mka_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	ΛCounters  []ygot.Annotation              `path:"state/@counters" ygotAnnotation:"true"`
	KeyChain   *string                        `path:"config/key-chain" module:"openconfig-macsec/openconfig-macsec"`
	ΛKeyChain  []ygot.Annotation              `path:"config/@key-chain" ygotAnnotation:"true"`
	MkaPolicy  *string                        `path:"config/mka-policy" module:"openconfig-macsec/openconfig-macsec"`
	ΛMkaPolicy []ygot.Annotation              `path:"config/@mka-policy" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Mka) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_Mka) GetOrCreateCounters() *Macsec_Interface_Mka_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_Mka_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_Mka. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_Mka) GetCounters() *Macsec_Interface_Mka_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetKeyChain retrieves the value of the leaf KeyChain from the Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyChain is set, it can
// safely use t.GetKeyChain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyChain == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka) GetKeyChain() string {
	if t == nil || t.KeyChain == nil {
		return ""
	}
	return *t.KeyChain
}

// GetMkaPolicy retrieves the value of the leaf MkaPolicy from the Macsec_Interface_Mka
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MkaPolicy is set, it can
// safely use t.GetMkaPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MkaPolicy == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka) GetMkaPolicy() string {
	if t == nil || t.MkaPolicy == nil {
		return ""
	}
	return *t.MkaPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_Mka
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_Mka) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Mka) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Mka.
func (*Macsec_Interface_Mka) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_Mka_Counters represents the /openconfig-macsec/macsec/interfaces/interface/mka/state/counters YANG schema element.
type Macsec_Interface_Mka_Counters struct {
	ΛMetadata    []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InCakMkpdu   *uint64           `path:"in-cak-mkpdu" module:"openconfig-macsec"`
	ΛInCakMkpdu  []ygot.Annotation `path:"@in-cak-mkpdu" ygotAnnotation:"true"`
	InMkpdu      *uint64           `path:"in-mkpdu" module:"openconfig-macsec"`
	ΛInMkpdu     []ygot.Annotation `path:"@in-mkpdu" ygotAnnotation:"true"`
	InSakMkpdu   *uint64           `path:"in-sak-mkpdu" module:"openconfig-macsec"`
	ΛInSakMkpdu  []ygot.Annotation `path:"@in-sak-mkpdu" ygotAnnotation:"true"`
	OutCakMkpdu  *uint64           `path:"out-cak-mkpdu" module:"openconfig-macsec"`
	ΛOutCakMkpdu []ygot.Annotation `path:"@out-cak-mkpdu" ygotAnnotation:"true"`
	OutMkpdu     *uint64           `path:"out-mkpdu" module:"openconfig-macsec"`
	ΛOutMkpdu    []ygot.Annotation `path:"@out-mkpdu" ygotAnnotation:"true"`
	OutSakMkpdu  *uint64           `path:"out-sak-mkpdu" module:"openconfig-macsec"`
	ΛOutSakMkpdu []ygot.Annotation `path:"@out-sak-mkpdu" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_Mka_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_Mka_Counters) IsYANGGoStruct() {}

// GetInCakMkpdu retrieves the value of the leaf InCakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCakMkpdu is set, it can
// safely use t.GetInCakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInCakMkpdu() uint64 {
	if t == nil || t.InCakMkpdu == nil {
		return 0
	}
	return *t.InCakMkpdu
}

// GetInMkpdu retrieves the value of the leaf InMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpdu is set, it can
// safely use t.GetInMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInMkpdu() uint64 {
	if t == nil || t.InMkpdu == nil {
		return 0
	}
	return *t.InMkpdu
}

// GetInSakMkpdu retrieves the value of the leaf InSakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InSakMkpdu is set, it can
// safely use t.GetInSakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InSakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetInSakMkpdu() uint64 {
	if t == nil || t.InSakMkpdu == nil {
		return 0
	}
	return *t.InSakMkpdu
}

// GetOutCakMkpdu retrieves the value of the leaf OutCakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutCakMkpdu is set, it can
// safely use t.GetOutCakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutCakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutCakMkpdu() uint64 {
	if t == nil || t.OutCakMkpdu == nil {
		return 0
	}
	return *t.OutCakMkpdu
}

// GetOutMkpdu retrieves the value of the leaf OutMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMkpdu is set, it can
// safely use t.GetOutMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutMkpdu() uint64 {
	if t == nil || t.OutMkpdu == nil {
		return 0
	}
	return *t.OutMkpdu
}

// GetOutSakMkpdu retrieves the value of the leaf OutSakMkpdu from the Macsec_Interface_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutSakMkpdu is set, it can
// safely use t.GetOutSakMkpdu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutSakMkpdu == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_Mka_Counters) GetOutSakMkpdu() uint64 {
	if t == nil || t.OutSakMkpdu == nil {
		return 0
	}
	return *t.OutSakMkpdu
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_Mka_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_Mka_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_Mka_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_Mka_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_Mka_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_Mka_Counters.
func (*Macsec_Interface_Mka_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaRx represents the /openconfig-macsec/macsec/interfaces/interface/scsa-rx/scsa-rx YANG schema element.
type Macsec_Interface_ScsaRx struct {
	ΛMetadata []ygot.Annotation                 `path:"@" ygotAnnotation:"true"`
	Counters  *Macsec_Interface_ScsaRx_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	ΛCounters []ygot.Annotation                 `path:"state/@counters" ygotAnnotation:"true"`
	SciRx     *string                           `path:"state/sci-rx|sci-rx" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	ΛSciRx    []ygot.Annotation                 `path:"state/@sci-rx|@sci-rx" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaRx implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaRx) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_ScsaRx) GetOrCreateCounters() *Macsec_Interface_ScsaRx_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_ScsaRx_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_ScsaRx. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_ScsaRx) GetCounters() *Macsec_Interface_ScsaRx_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSciRx retrieves the value of the leaf SciRx from the Macsec_Interface_ScsaRx
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SciRx is set, it can
// safely use t.GetSciRx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SciRx == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx) GetSciRx() string {
	if t == nil || t.SciRx == nil {
		return ""
	}
	return *t.SciRx
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_ScsaRx
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_ScsaRx) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Macsec_Interface_ScsaRx struct, which is a YANG list entry.
func (t *Macsec_Interface_ScsaRx) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SciRx == nil {
		return nil, fmt.Errorf("nil value for key SciRx")
	}

	return map[string]interface{}{
		"sci-rx": *t.SciRx,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaRx"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaRx) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaRx.
func (*Macsec_Interface_ScsaRx) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaRx_Counters represents the /openconfig-macsec/macsec/interfaces/interface/scsa-rx/scsa-rx/state/counters YANG schema element.
type Macsec_Interface_ScsaRx_Counters struct {
	ΛMetadata  []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	SaInvalid  *uint64           `path:"sa-invalid" module:"openconfig-macsec"`
	ΛSaInvalid []ygot.Annotation `path:"@sa-invalid" ygotAnnotation:"true"`
	SaValid    *uint64           `path:"sa-valid" module:"openconfig-macsec"`
	ΛSaValid   []ygot.Annotation `path:"@sa-valid" ygotAnnotation:"true"`
	ScInvalid  *uint64           `path:"sc-invalid" module:"openconfig-macsec"`
	ΛScInvalid []ygot.Annotation `path:"@sc-invalid" ygotAnnotation:"true"`
	ScValid    *uint64           `path:"sc-valid" module:"openconfig-macsec"`
	ΛScValid   []ygot.Annotation `path:"@sc-valid" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaRx_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaRx_Counters) IsYANGGoStruct() {}

// GetSaInvalid retrieves the value of the leaf SaInvalid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaInvalid is set, it can
// safely use t.GetSaInvalid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaInvalid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetSaInvalid() uint64 {
	if t == nil || t.SaInvalid == nil {
		return 0
	}
	return *t.SaInvalid
}

// GetSaValid retrieves the value of the leaf SaValid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaValid is set, it can
// safely use t.GetSaValid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaValid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetSaValid() uint64 {
	if t == nil || t.SaValid == nil {
		return 0
	}
	return *t.SaValid
}

// GetScInvalid retrieves the value of the leaf ScInvalid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScInvalid is set, it can
// safely use t.GetScInvalid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScInvalid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetScInvalid() uint64 {
	if t == nil || t.ScInvalid == nil {
		return 0
	}
	return *t.ScInvalid
}

// GetScValid retrieves the value of the leaf ScValid from the Macsec_Interface_ScsaRx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScValid is set, it can
// safely use t.GetScValid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScValid == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaRx_Counters) GetScValid() uint64 {
	if t == nil || t.ScValid == nil {
		return 0
	}
	return *t.ScValid
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_ScsaRx_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_ScsaRx_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaRx_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaRx_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaRx_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaRx_Counters.
func (*Macsec_Interface_ScsaRx_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaTx represents the /openconfig-macsec/macsec/interfaces/interface/scsa-tx/scsa-tx YANG schema element.
type Macsec_Interface_ScsaTx struct {
	ΛMetadata []ygot.Annotation                 `path:"@" ygotAnnotation:"true"`
	Counters  *Macsec_Interface_ScsaTx_Counters `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	ΛCounters []ygot.Annotation                 `path:"state/@counters" ygotAnnotation:"true"`
	SciTx     *string                           `path:"state/sci-tx|sci-tx" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	ΛSciTx    []ygot.Annotation                 `path:"state/@sci-tx|@sci-tx" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaTx implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaTx) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Interface_ScsaTx) GetOrCreateCounters() *Macsec_Interface_ScsaTx_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Interface_ScsaTx_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Interface_ScsaTx. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Interface_ScsaTx) GetCounters() *Macsec_Interface_ScsaTx_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetSciTx retrieves the value of the leaf SciTx from the Macsec_Interface_ScsaTx
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SciTx is set, it can
// safely use t.GetSciTx() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SciTx == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx) GetSciTx() string {
	if t == nil || t.SciTx == nil {
		return ""
	}
	return *t.SciTx
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_ScsaTx
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_ScsaTx) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Macsec_Interface_ScsaTx struct, which is a YANG list entry.
func (t *Macsec_Interface_ScsaTx) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SciTx == nil {
		return nil, fmt.Errorf("nil value for key SciTx")
	}

	return map[string]interface{}{
		"sci-tx": *t.SciTx,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaTx"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaTx) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaTx.
func (*Macsec_Interface_ScsaTx) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Interface_ScsaTx_Counters represents the /openconfig-macsec/macsec/interfaces/interface/scsa-tx/scsa-tx/state/counters YANG schema element.
type Macsec_Interface_ScsaTx_Counters struct {
	ΛMetadata    []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	SaAuthOnly   *uint64           `path:"sa-auth-only" module:"openconfig-macsec"`
	ΛSaAuthOnly  []ygot.Annotation `path:"@sa-auth-only" ygotAnnotation:"true"`
	SaEncrypted  *uint64           `path:"sa-encrypted" module:"openconfig-macsec"`
	ΛSaEncrypted []ygot.Annotation `path:"@sa-encrypted" ygotAnnotation:"true"`
	ScAuthOnly   *uint64           `path:"sc-auth-only" module:"openconfig-macsec"`
	ΛScAuthOnly  []ygot.Annotation `path:"@sc-auth-only" ygotAnnotation:"true"`
	ScEncrypted  *uint64           `path:"sc-encrypted" module:"openconfig-macsec"`
	ΛScEncrypted []ygot.Annotation `path:"@sc-encrypted" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Interface_ScsaTx_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Interface_ScsaTx_Counters) IsYANGGoStruct() {}

// GetSaAuthOnly retrieves the value of the leaf SaAuthOnly from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaAuthOnly is set, it can
// safely use t.GetSaAuthOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaAuthOnly == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetSaAuthOnly() uint64 {
	if t == nil || t.SaAuthOnly == nil {
		return 0
	}
	return *t.SaAuthOnly
}

// GetSaEncrypted retrieves the value of the leaf SaEncrypted from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SaEncrypted is set, it can
// safely use t.GetSaEncrypted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SaEncrypted == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetSaEncrypted() uint64 {
	if t == nil || t.SaEncrypted == nil {
		return 0
	}
	return *t.SaEncrypted
}

// GetScAuthOnly retrieves the value of the leaf ScAuthOnly from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScAuthOnly is set, it can
// safely use t.GetScAuthOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScAuthOnly == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetScAuthOnly() uint64 {
	if t == nil || t.ScAuthOnly == nil {
		return 0
	}
	return *t.ScAuthOnly
}

// GetScEncrypted retrieves the value of the leaf ScEncrypted from the Macsec_Interface_ScsaTx_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScEncrypted is set, it can
// safely use t.GetScEncrypted() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScEncrypted == nil' before retrieving the leaf's value.
func (t *Macsec_Interface_ScsaTx_Counters) GetScEncrypted() uint64 {
	if t == nil || t.ScEncrypted == nil {
		return 0
	}
	return *t.ScEncrypted
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Interface_ScsaTx_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Interface_ScsaTx_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Interface_ScsaTx_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Interface_ScsaTx_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Interface_ScsaTx_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Interface_ScsaTx_Counters.
func (*Macsec_Interface_ScsaTx_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka represents the /openconfig-macsec/macsec/mka YANG schema element.
type Macsec_Mka struct {
	ΛMetadata []ygot.Annotation             `path:"@" ygotAnnotation:"true"`
	Counters  *Macsec_Mka_Counters          `path:"state/counters" module:"openconfig-macsec/openconfig-macsec"`
	ΛCounters []ygot.Annotation             `path:"state/@counters" ygotAnnotation:"true"`
	Policy    map[string]*Macsec_Mka_Policy `path:"policies/policy" module:"openconfig-macsec/openconfig-macsec"`
	ΛPolicy   []ygot.Annotation             `path:"policies/@policy" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Mka implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka) IsYANGGoStruct() {}

// NewPolicy creates a new entry in the Policy list of the
// Macsec_Mka struct. The keys of the list are populated from the input
// arguments.
func (t *Macsec_Mka) NewPolicy(Name string) (*Macsec_Mka_Policy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*Macsec_Mka_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &Macsec_Mka_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the Macsec_Mka struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Macsec_Mka) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.Name = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver Macsec_Mka. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Macsec_Mka) GetOrCreatePolicy(Name string) *Macsec_Mka_Policy {

	key := Name

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of Macsec_Mka. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Macsec_Mka) GetPolicy(Name string) *Macsec_Mka_Policy {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver Macsec_Mka. If there is no such element, the function
// is a no-op.
func (t *Macsec_Mka) DeletePolicy(Name string) {
	key := Name

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied Macsec_Mka_Policy struct to the
// list Policy of Macsec_Mka. If the key value(s) specified in
// the supplied Macsec_Mka_Policy already exist in the list, an error is
// returned.
func (t *Macsec_Mka) AppendPolicy(v *Macsec_Mka_Policy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*Macsec_Mka_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Macsec_Mka) GetOrCreateCounters() *Macsec_Mka_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Macsec_Mka_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Macsec_Mka. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Macsec_Mka) GetCounters() *Macsec_Mka_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Mka
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Mka) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka.
func (*Macsec_Mka) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka_Counters represents the /openconfig-macsec/macsec/mka/state/counters YANG schema element.
type Macsec_Mka_Counters struct {
	ΛMetadata                     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InMkpduBadPeerErrors          *uint64           `path:"in-mkpdu-bad-peer-errors" module:"openconfig-macsec"`
	ΛInMkpduBadPeerErrors         []ygot.Annotation `path:"@in-mkpdu-bad-peer-errors" ygotAnnotation:"true"`
	InMkpduIcvVerificationErrors  *uint64           `path:"in-mkpdu-icv-verification-errors" module:"openconfig-macsec"`
	ΛInMkpduIcvVerificationErrors []ygot.Annotation `path:"@in-mkpdu-icv-verification-errors" ygotAnnotation:"true"`
	InMkpduPeerListErrors         *uint64           `path:"in-mkpdu-peer-list-errors" module:"openconfig-macsec"`
	ΛInMkpduPeerListErrors        []ygot.Annotation `path:"@in-mkpdu-peer-list-errors" ygotAnnotation:"true"`
	InMkpduValidationErrors       *uint64           `path:"in-mkpdu-validation-errors" module:"openconfig-macsec"`
	ΛInMkpduValidationErrors      []ygot.Annotation `path:"@in-mkpdu-validation-errors" ygotAnnotation:"true"`
	OutMkpduErrors                *uint64           `path:"out-mkpdu-errors" module:"openconfig-macsec"`
	ΛOutMkpduErrors               []ygot.Annotation `path:"@out-mkpdu-errors" ygotAnnotation:"true"`
	SakCipherMismatchErrors       *uint64           `path:"sak-cipher-mismatch-errors" module:"openconfig-macsec"`
	ΛSakCipherMismatchErrors      []ygot.Annotation `path:"@sak-cipher-mismatch-errors" ygotAnnotation:"true"`
	SakDecryptionErrors           *uint64           `path:"sak-decryption-errors" module:"openconfig-macsec"`
	ΛSakDecryptionErrors          []ygot.Annotation `path:"@sak-decryption-errors" ygotAnnotation:"true"`
	SakEncryptionErrors           *uint64           `path:"sak-encryption-errors" module:"openconfig-macsec"`
	ΛSakEncryptionErrors          []ygot.Annotation `path:"@sak-encryption-errors" ygotAnnotation:"true"`
	SakGenerationErrors           *uint64           `path:"sak-generation-errors" module:"openconfig-macsec"`
	ΛSakGenerationErrors          []ygot.Annotation `path:"@sak-generation-errors" ygotAnnotation:"true"`
	SakHashErrors                 *uint64           `path:"sak-hash-errors" module:"openconfig-macsec"`
	ΛSakHashErrors                []ygot.Annotation `path:"@sak-hash-errors" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Mka_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka_Counters) IsYANGGoStruct() {}

// GetInMkpduBadPeerErrors retrieves the value of the leaf InMkpduBadPeerErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduBadPeerErrors is set, it can
// safely use t.GetInMkpduBadPeerErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduBadPeerErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduBadPeerErrors() uint64 {
	if t == nil || t.InMkpduBadPeerErrors == nil {
		return 0
	}
	return *t.InMkpduBadPeerErrors
}

// GetInMkpduIcvVerificationErrors retrieves the value of the leaf InMkpduIcvVerificationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduIcvVerificationErrors is set, it can
// safely use t.GetInMkpduIcvVerificationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduIcvVerificationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduIcvVerificationErrors() uint64 {
	if t == nil || t.InMkpduIcvVerificationErrors == nil {
		return 0
	}
	return *t.InMkpduIcvVerificationErrors
}

// GetInMkpduPeerListErrors retrieves the value of the leaf InMkpduPeerListErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduPeerListErrors is set, it can
// safely use t.GetInMkpduPeerListErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduPeerListErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduPeerListErrors() uint64 {
	if t == nil || t.InMkpduPeerListErrors == nil {
		return 0
	}
	return *t.InMkpduPeerListErrors
}

// GetInMkpduValidationErrors retrieves the value of the leaf InMkpduValidationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMkpduValidationErrors is set, it can
// safely use t.GetInMkpduValidationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMkpduValidationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetInMkpduValidationErrors() uint64 {
	if t == nil || t.InMkpduValidationErrors == nil {
		return 0
	}
	return *t.InMkpduValidationErrors
}

// GetOutMkpduErrors retrieves the value of the leaf OutMkpduErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMkpduErrors is set, it can
// safely use t.GetOutMkpduErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMkpduErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetOutMkpduErrors() uint64 {
	if t == nil || t.OutMkpduErrors == nil {
		return 0
	}
	return *t.OutMkpduErrors
}

// GetSakCipherMismatchErrors retrieves the value of the leaf SakCipherMismatchErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakCipherMismatchErrors is set, it can
// safely use t.GetSakCipherMismatchErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakCipherMismatchErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakCipherMismatchErrors() uint64 {
	if t == nil || t.SakCipherMismatchErrors == nil {
		return 0
	}
	return *t.SakCipherMismatchErrors
}

// GetSakDecryptionErrors retrieves the value of the leaf SakDecryptionErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakDecryptionErrors is set, it can
// safely use t.GetSakDecryptionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakDecryptionErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakDecryptionErrors() uint64 {
	if t == nil || t.SakDecryptionErrors == nil {
		return 0
	}
	return *t.SakDecryptionErrors
}

// GetSakEncryptionErrors retrieves the value of the leaf SakEncryptionErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakEncryptionErrors is set, it can
// safely use t.GetSakEncryptionErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakEncryptionErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakEncryptionErrors() uint64 {
	if t == nil || t.SakEncryptionErrors == nil {
		return 0
	}
	return *t.SakEncryptionErrors
}

// GetSakGenerationErrors retrieves the value of the leaf SakGenerationErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakGenerationErrors is set, it can
// safely use t.GetSakGenerationErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakGenerationErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakGenerationErrors() uint64 {
	if t == nil || t.SakGenerationErrors == nil {
		return 0
	}
	return *t.SakGenerationErrors
}

// GetSakHashErrors retrieves the value of the leaf SakHashErrors from the Macsec_Mka_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakHashErrors is set, it can
// safely use t.GetSakHashErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakHashErrors == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Counters) GetSakHashErrors() uint64 {
	if t == nil || t.SakHashErrors == nil {
		return 0
	}
	return *t.SakHashErrors
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Mka_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Mka_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka_Counters.
func (*Macsec_Mka_Counters) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Macsec_Mka_Policy represents the /openconfig-macsec/macsec/mka/policies/policy YANG schema element.
type Macsec_Mka_Policy struct {
	ΛMetadata               []ygot.Annotation                   `path:"@" ygotAnnotation:"true"`
	ConfidentialityOffset   E_MacsecTypes_ConfidentialityOffset `path:"config/confidentiality-offset" module:"openconfig-macsec/openconfig-macsec"`
	ΛConfidentialityOffset  []ygot.Annotation                   `path:"config/@confidentiality-offset" ygotAnnotation:"true"`
	DelayProtection         *bool                               `path:"config/delay-protection" module:"openconfig-macsec/openconfig-macsec"`
	ΛDelayProtection        []ygot.Annotation                   `path:"config/@delay-protection" ygotAnnotation:"true"`
	IncludeIcvIndicator     *bool                               `path:"config/include-icv-indicator" module:"openconfig-macsec/openconfig-macsec"`
	ΛIncludeIcvIndicator    []ygot.Annotation                   `path:"config/@include-icv-indicator" ygotAnnotation:"true"`
	KeyServerPriority       *uint8                              `path:"config/key-server-priority" module:"openconfig-macsec/openconfig-macsec"`
	ΛKeyServerPriority      []ygot.Annotation                   `path:"config/@key-server-priority" ygotAnnotation:"true"`
	MacsecCipherSuite       []E_MacsecTypes_MacsecCipherSuite   `path:"config/macsec-cipher-suite" module:"openconfig-macsec/openconfig-macsec"`
	ΛMacsecCipherSuite      []ygot.Annotation                   `path:"config/@macsec-cipher-suite" ygotAnnotation:"true"`
	Name                    *string                             `path:"config/name|name" module:"openconfig-macsec/openconfig-macsec|openconfig-macsec"`
	ΛName                   []ygot.Annotation                   `path:"config/@name|@name" ygotAnnotation:"true"`
	SakRekeyInterval        *uint32                             `path:"config/sak-rekey-interval" module:"openconfig-macsec/openconfig-macsec"`
	ΛSakRekeyInterval       []ygot.Annotation                   `path:"config/@sak-rekey-interval" ygotAnnotation:"true"`
	SakRekeyOnLivePeerLoss  *bool                               `path:"config/sak-rekey-on-live-peer-loss" module:"openconfig-macsec/openconfig-macsec"`
	ΛSakRekeyOnLivePeerLoss []ygot.Annotation                   `path:"config/@sak-rekey-on-live-peer-loss" ygotAnnotation:"true"`
	UseUpdatedEthHeader     *bool                               `path:"config/use-updated-eth-header" module:"openconfig-macsec/openconfig-macsec"`
	ΛUseUpdatedEthHeader    []ygot.Annotation                   `path:"config/@use-updated-eth-header" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Macsec_Mka_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Macsec_Mka_Policy) IsYANGGoStruct() {}

// GetConfidentialityOffset retrieves the value of the leaf ConfidentialityOffset from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConfidentialityOffset is set, it can
// safely use t.GetConfidentialityOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConfidentialityOffset == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetConfidentialityOffset() E_MacsecTypes_ConfidentialityOffset {
	if t == nil || t.ConfidentialityOffset == 0 {
		return MacsecTypes_ConfidentialityOffset_0_BYTES
	}
	return t.ConfidentialityOffset
}

// GetDelayProtection retrieves the value of the leaf DelayProtection from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DelayProtection is set, it can
// safely use t.GetDelayProtection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DelayProtection == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetDelayProtection() bool {
	if t == nil || t.DelayProtection == nil {
		return false
	}
	return *t.DelayProtection
}

// GetIncludeIcvIndicator retrieves the value of the leaf IncludeIcvIndicator from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeIcvIndicator is set, it can
// safely use t.GetIncludeIcvIndicator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeIcvIndicator == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetIncludeIcvIndicator() bool {
	if t == nil || t.IncludeIcvIndicator == nil {
		return true
	}
	return *t.IncludeIcvIndicator
}

// GetKeyServerPriority retrieves the value of the leaf KeyServerPriority from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyServerPriority is set, it can
// safely use t.GetKeyServerPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyServerPriority == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetKeyServerPriority() uint8 {
	if t == nil || t.KeyServerPriority == nil {
		return 16
	}
	return *t.KeyServerPriority
}

// GetMacsecCipherSuite retrieves the value of the leaf MacsecCipherSuite from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacsecCipherSuite is set, it can
// safely use t.GetMacsecCipherSuite() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacsecCipherSuite == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetMacsecCipherSuite() []E_MacsecTypes_MacsecCipherSuite {
	if t == nil || t.MacsecCipherSuite == nil {
		return nil
	}
	return t.MacsecCipherSuite
}

// GetName retrieves the value of the leaf Name from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSakRekeyInterval retrieves the value of the leaf SakRekeyInterval from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakRekeyInterval is set, it can
// safely use t.GetSakRekeyInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakRekeyInterval == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetSakRekeyInterval() uint32 {
	if t == nil || t.SakRekeyInterval == nil {
		return 0
	}
	return *t.SakRekeyInterval
}

// GetSakRekeyOnLivePeerLoss retrieves the value of the leaf SakRekeyOnLivePeerLoss from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SakRekeyOnLivePeerLoss is set, it can
// safely use t.GetSakRekeyOnLivePeerLoss() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SakRekeyOnLivePeerLoss == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetSakRekeyOnLivePeerLoss() bool {
	if t == nil || t.SakRekeyOnLivePeerLoss == nil {
		return false
	}
	return *t.SakRekeyOnLivePeerLoss
}

// GetUseUpdatedEthHeader retrieves the value of the leaf UseUpdatedEthHeader from the Macsec_Mka_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseUpdatedEthHeader is set, it can
// safely use t.GetUseUpdatedEthHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseUpdatedEthHeader == nil' before retrieving the leaf's value.
func (t *Macsec_Mka_Policy) GetUseUpdatedEthHeader() bool {
	if t == nil || t.UseUpdatedEthHeader == nil {
		return false
	}
	return *t.UseUpdatedEthHeader
}

// PopulateDefaults recursively populates unset leaf fields in the Macsec_Mka_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Macsec_Mka_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ConfidentialityOffset == 0 {
		t.ConfidentialityOffset = MacsecTypes_ConfidentialityOffset_0_BYTES
	}
	if t.DelayProtection == nil {
		var v bool = false
		t.DelayProtection = &v
	}
	if t.IncludeIcvIndicator == nil {
		var v bool = true
		t.IncludeIcvIndicator = &v
	}
	if t.KeyServerPriority == nil {
		var v uint8 = 16
		t.KeyServerPriority = &v
	}
	if t.SakRekeyInterval == nil {
		var v uint32 = 0
		t.SakRekeyInterval = &v
	}
	if t.SakRekeyOnLivePeerLoss == nil {
		var v bool = false
		t.SakRekeyOnLivePeerLoss = &v
	}
	if t.UseUpdatedEthHeader == nil {
		var v bool = false
		t.UseUpdatedEthHeader = &v
	}
}

// ΛListKeyMap returns the keys of the Macsec_Mka_Policy struct, which is a YANG list entry.
func (t *Macsec_Mka_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Macsec_Mka_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Macsec_Mka_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Macsec_Mka_Policy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Macsec_Mka_Policy.
func (*Macsec_Mka_Policy) ΛBelongingModule() string {
	return "openconfig-macsec"
}

// Messages represents the /openconfig-messages/messages YANG schema element.
type Messages struct {
	ΛMetadata     []ygot.Annotation                                   `path:"@" ygotAnnotation:"true"`
	DebugService  map[E_Messages_DEBUG_SERVICE]*Messages_DebugService `path:"debug-entries/debug-service" module:"openconfig-messages/openconfig-messages"`
	ΛDebugService []ygot.Annotation                                   `path:"debug-entries/@debug-service" ygotAnnotation:"true"`
	Message       *Messages_Message                                   `path:"state/message" module:"openconfig-messages/openconfig-messages"`
	ΛMessage      []ygot.Annotation                                   `path:"state/@message" ygotAnnotation:"true"`
	Severity      E_SystemLogging_SyslogSeverity                      `path:"config/severity" module:"openconfig-messages/openconfig-messages"`
	ΛSeverity     []ygot.Annotation                                   `path:"config/@severity" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Messages implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Messages) IsYANGGoStruct() {}

// NewDebugService creates a new entry in the DebugService list of the
// Messages struct. The keys of the list are populated from the input
// arguments.
func (t *Messages) NewDebugService(Service E_Messages_DEBUG_SERVICE) (*Messages_DebugService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DebugService == nil {
		t.DebugService = make(map[E_Messages_DEBUG_SERVICE]*Messages_DebugService)
	}

	key := Service

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DebugService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DebugService", key)
	}

	t.DebugService[key] = &Messages_DebugService{
		Service: Service,
	}

	return t.DebugService[key], nil
}

// RenameDebugService renames an entry in the list DebugService within
// the Messages struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Messages) RenameDebugService(oldK, newK E_Messages_DEBUG_SERVICE) error {
	if _, ok := t.DebugService[newK]; ok {
		return fmt.Errorf("key %v already exists in DebugService", newK)
	}

	e, ok := t.DebugService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DebugService", oldK)
	}
	e.Service = newK

	t.DebugService[newK] = e
	delete(t.DebugService, oldK)
	return nil
}

// GetOrCreateDebugService retrieves the value with the specified keys from
// the receiver Messages. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Messages) GetOrCreateDebugService(Service E_Messages_DEBUG_SERVICE) *Messages_DebugService {

	key := Service

	if v, ok := t.DebugService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDebugService(Service)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDebugService got unexpected error: %v", err))
	}
	return v
}

// GetDebugService retrieves the value with the specified key from
// the DebugService map field of Messages. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Messages) GetDebugService(Service E_Messages_DEBUG_SERVICE) *Messages_DebugService {

	if t == nil {
		return nil
	}

	key := Service

	if lm, ok := t.DebugService[key]; ok {
		return lm
	}
	return nil
}

// DeleteDebugService deletes the value with the specified keys from
// the receiver Messages. If there is no such element, the function
// is a no-op.
func (t *Messages) DeleteDebugService(Service E_Messages_DEBUG_SERVICE) {
	key := Service

	delete(t.DebugService, key)
}

// AppendDebugService appends the supplied Messages_DebugService struct to the
// list DebugService of Messages. If the key value(s) specified in
// the supplied Messages_DebugService already exist in the list, an error is
// returned.
func (t *Messages) AppendDebugService(v *Messages_DebugService) error {
	key := v.Service

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DebugService == nil {
		t.DebugService = make(map[E_Messages_DEBUG_SERVICE]*Messages_DebugService)
	}

	if _, ok := t.DebugService[key]; ok {
		return fmt.Errorf("duplicate key for list DebugService %v", key)
	}

	t.DebugService[key] = v
	return nil
}

// GetOrCreateMessage retrieves the value of the Message field
// or returns the existing field if it already exists.
func (t *Messages) GetOrCreateMessage() *Messages_Message {
	if t.Message != nil {
		return t.Message
	}
	t.Message = &Messages_Message{}
	return t.Message
}

// GetMessage returns the value of the Message struct pointer
// from Messages. If the receiver or the field Message is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Messages) GetMessage() *Messages_Message {
	if t != nil && t.Message != nil {
		return t.Message
	}
	return nil
}

// GetSeverity retrieves the value of the leaf Severity from the Messages
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Severity is set, it can
// safely use t.GetSeverity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Severity == nil' before retrieving the leaf's value.
func (t *Messages) GetSeverity() E_SystemLogging_SyslogSeverity {
	if t == nil || t.Severity == 0 {
		return 0
	}
	return t.Severity
}

// PopulateDefaults recursively populates unset leaf fields in the Messages
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Messages) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Message.PopulateDefaults()
	for _, e := range t.DebugService {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Messages"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Messages) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Messages.
func (*Messages) ΛBelongingModule() string {
	return "openconfig-messages"
}

// Messages_DebugService represents the /openconfig-messages/messages/debug-entries/debug-service YANG schema element.
type Messages_DebugService struct {
	ΛMetadata []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	Enabled   *bool                    `path:"config/enabled" module:"openconfig-messages/openconfig-messages"`
	ΛEnabled  []ygot.Annotation        `path:"config/@enabled" ygotAnnotation:"true"`
	Service   E_Messages_DEBUG_SERVICE `path:"config/service|service" module:"openconfig-messages/openconfig-messages|openconfig-messages"`
	ΛService  []ygot.Annotation        `path:"config/@service|@service" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Messages_DebugService implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Messages_DebugService) IsYANGGoStruct() {}

// GetEnabled retrieves the value of the leaf Enabled from the Messages_DebugService
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Messages_DebugService) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetService retrieves the value of the leaf Service from the Messages_DebugService
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Service is set, it can
// safely use t.GetService() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Service == nil' before retrieving the leaf's value.
func (t *Messages_DebugService) GetService() E_Messages_DEBUG_SERVICE {
	if t == nil || t.Service == 0 {
		return 0
	}
	return t.Service
}

// PopulateDefaults recursively populates unset leaf fields in the Messages_DebugService
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Messages_DebugService) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
}

// ΛListKeyMap returns the keys of the Messages_DebugService struct, which is a YANG list entry.
func (t *Messages_DebugService) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"service": t.Service,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages_DebugService) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Messages_DebugService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages_DebugService) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Messages_DebugService) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Messages_DebugService.
func (*Messages_DebugService) ΛBelongingModule() string {
	return "openconfig-messages"
}

// Messages_Message represents the /openconfig-messages/messages/state/message YANG schema element.
type Messages_Message struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	AppName   *string           `path:"app-name" module:"openconfig-messages"`
	ΛAppName  []ygot.Annotation `path:"@app-name" ygotAnnotation:"true"`
	Msg       *string           `path:"msg" module:"openconfig-messages"`
	ΛMsg      []ygot.Annotation `path:"@msg" ygotAnnotation:"true"`
	Msgid     *string           `path:"msgid" module:"openconfig-messages"`
	ΛMsgid    []ygot.Annotation `path:"@msgid" ygotAnnotation:"true"`
	Priority  *uint8            `path:"priority" module:"openconfig-messages"`
	ΛPriority []ygot.Annotation `path:"@priority" ygotAnnotation:"true"`
	Procid    *string           `path:"procid" module:"openconfig-messages"`
	ΛProcid   []ygot.Annotation `path:"@procid" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Messages_Message implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Messages_Message) IsYANGGoStruct() {}

// GetAppName retrieves the value of the leaf AppName from the Messages_Message
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AppName is set, it can
// safely use t.GetAppName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AppName == nil' before retrieving the leaf's value.
func (t *Messages_Message) GetAppName() string {
	if t == nil || t.AppName == nil {
		return ""
	}
	return *t.AppName
}

// GetMsg retrieves the value of the leaf Msg from the Messages_Message
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Msg is set, it can
// safely use t.GetMsg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Msg == nil' before retrieving the leaf's value.
func (t *Messages_Message) GetMsg() string {
	if t == nil || t.Msg == nil {
		return ""
	}
	return *t.Msg
}

// GetMsgid retrieves the value of the leaf Msgid from the Messages_Message
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Msgid is set, it can
// safely use t.GetMsgid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Msgid == nil' before retrieving the leaf's value.
func (t *Messages_Message) GetMsgid() string {
	if t == nil || t.Msgid == nil {
		return ""
	}
	return *t.Msgid
}

// GetPriority retrieves the value of the leaf Priority from the Messages_Message
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Messages_Message) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetProcid retrieves the value of the leaf Procid from the Messages_Message
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Procid is set, it can
// safely use t.GetProcid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Procid == nil' before retrieving the leaf's value.
func (t *Messages_Message) GetProcid() string {
	if t == nil || t.Procid == nil {
		return ""
	}
	return *t.Procid
}

// PopulateDefaults recursively populates unset leaf fields in the Messages_Message
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Messages_Message) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages_Message) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Messages_Message"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Messages_Message) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Messages_Message) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Messages_Message.
func (*Messages_Message) ΛBelongingModule() string {
	return "openconfig-messages"
}

// NetworkInstance represents the /openconfig-network-instance/network-instances/network-instance YANG schema element.
type NetworkInstance struct {
	ΛMetadata                []ygot.Annotation                                                        `path:"@" ygotAnnotation:"true"`
	Afts                     *NetworkInstance_Afts                                                    `path:"afts" module:"openconfig-network-instance"`
	ΛAfts                    []ygot.Annotation                                                        `path:"@afts" ygotAnnotation:"true"`
	ConnectionPoint          map[string]*NetworkInstance_ConnectionPoint                              `path:"connection-points/connection-point" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛConnectionPoint         []ygot.Annotation                                                        `path:"connection-points/@connection-point" ygotAnnotation:"true"`
	Description              *string                                                                  `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDescription             []ygot.Annotation                                                        `path:"config/@description" ygotAnnotation:"true"`
	Encapsulation            *NetworkInstance_Encapsulation                                           `path:"encapsulation" module:"openconfig-network-instance"`
	ΛEncapsulation           []ygot.Annotation                                                        `path:"@encapsulation" ygotAnnotation:"true"`
	Evpn                     *NetworkInstance_Evpn                                                    `path:"evpn" module:"openconfig-network-instance"`
	ΛEvpn                    []ygot.Annotation                                                        `path:"@evpn" ygotAnnotation:"true"`
	FallbackNetworkInstance  *string                                                                  `path:"config/fallback-network-instance" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛFallbackNetworkInstance []ygot.Annotation                                                        `path:"config/@fallback-network-instance" ygotAnnotation:"true"`
	Fdb                      *NetworkInstance_Fdb                                                     `path:"fdb" module:"openconfig-network-instance"`
	ΛFdb                     []ygot.Annotation                                                        `path:"@fdb" ygotAnnotation:"true"`
	FlexAlgorithm            *NetworkInstance_FlexAlgorithm                                           `path:"flex-algorithm" module:"openconfig-flexalgo"`
	ΛFlexAlgorithm           []ygot.Annotation                                                        `path:"@flex-algorithm" ygotAnnotation:"true"`
	InterInstancePolicies    *NetworkInstance_InterInstancePolicies                                   `path:"inter-instance-policies" module:"openconfig-network-instance"`
	ΛInterInstancePolicies   []ygot.Annotation                                                        `path:"@inter-instance-policies" ygotAnnotation:"true"`
	Interface                map[string]*NetworkInstance_Interface                                    `path:"interfaces/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface               []ygot.Annotation                                                        `path:"interfaces/@interface" ygotAnnotation:"true"`
	Mpls                     *NetworkInstance_Mpls                                                    `path:"mpls" module:"openconfig-network-instance"`
	ΛMpls                    []ygot.Annotation                                                        `path:"@mpls" ygotAnnotation:"true"`
	Name                     *string                                                                  `path:"config/name|name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛName                    []ygot.Annotation                                                        `path:"config/@name|@name" ygotAnnotation:"true"`
	PolicyForwarding         *NetworkInstance_PolicyForwarding                                        `path:"policy-forwarding" module:"openconfig-network-instance"`
	ΛPolicyForwarding        []ygot.Annotation                                                        `path:"@policy-forwarding" ygotAnnotation:"true"`
	Protocol                 map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol               `path:"protocols/protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProtocol                []ygot.Annotation                                                        `path:"protocols/@protocol" ygotAnnotation:"true"`
	RouteDistinguisher       *string                                                                  `path:"config/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRouteDistinguisher      []ygot.Annotation                                                        `path:"config/@route-distinguisher" ygotAnnotation:"true"`
	RouteLimit               map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit                   `path:"route-limits/route-limit" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRouteLimit              []ygot.Annotation                                                        `path:"route-limits/@route-limit" ygotAnnotation:"true"`
	RouterId                 *string                                                                  `path:"config/router-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRouterId                []ygot.Annotation                                                        `path:"config/@router-id" ygotAnnotation:"true"`
	SegmentRouting           *NetworkInstance_SegmentRouting                                          `path:"segment-routing" module:"openconfig-network-instance"`
	ΛSegmentRouting          []ygot.Annotation                                                        `path:"@segment-routing" ygotAnnotation:"true"`
	Table                    map[NetworkInstance_Table_Key]*NetworkInstance_Table                     `path:"tables/table" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTable                   []ygot.Annotation                                                        `path:"tables/@table" ygotAnnotation:"true"`
	TableConnection          map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection `path:"table-connections/table-connection" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTableConnection         []ygot.Annotation                                                        `path:"table-connections/@table-connection" ygotAnnotation:"true"`
	Type                     E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE                             `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛType                    []ygot.Annotation                                                        `path:"config/@type" ygotAnnotation:"true"`
	Vlan                     map[uint16]*NetworkInstance_Vlan                                         `path:"vlans/vlan" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVlan                    []ygot.Annotation                                                        `path:"vlans/@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance) IsYANGGoStruct() {}

// NetworkInstance_Protocol_Key represents the key for list Protocol of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Protocol_Key struct {
	Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"identifier"`
	Name       string                              `path:"name"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Protocol_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Protocol_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Protocol_Key key struct.
func (t NetworkInstance_Protocol_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"identifier": t.Identifier,
		"name":       t.Name,
	}, nil
}

// NetworkInstance_Table_Key represents the key for list Table of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_Table_Key struct {
	Protocol      E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Table_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Table_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Table_Key key struct.
func (t NetworkInstance_Table_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"protocol":       t.Protocol,
		"address-family": t.AddressFamily,
	}, nil
}

// NetworkInstance_TableConnection_Key represents the key for list TableConnection of element /openconfig-network-instance/network-instances/network-instance.
type NetworkInstance_TableConnection_Key struct {
	SrcProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"src-protocol"`
	DstProtocol   E_PolicyTypes_INSTALL_PROTOCOL_TYPE `path:"dst-protocol"`
	AddressFamily E_Types_ADDRESS_FAMILY              `path:"address-family"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_TableConnection_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_TableConnection_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_TableConnection_Key key struct.
func (t NetworkInstance_TableConnection_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"src-protocol":   t.SrcProtocol,
		"dst-protocol":   t.DstProtocol,
		"address-family": t.AddressFamily,
	}, nil
}

// NewConnectionPoint creates a new entry in the ConnectionPoint list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewConnectionPoint(ConnectionPointId string) (*NetworkInstance_ConnectionPoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	key := ConnectionPointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConnectionPoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConnectionPoint", key)
	}

	t.ConnectionPoint[key] = &NetworkInstance_ConnectionPoint{
		ConnectionPointId: &ConnectionPointId,
	}

	return t.ConnectionPoint[key], nil
}

// RenameConnectionPoint renames an entry in the list ConnectionPoint within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameConnectionPoint(oldK, newK string) error {
	if _, ok := t.ConnectionPoint[newK]; ok {
		return fmt.Errorf("key %v already exists in ConnectionPoint", newK)
	}

	e, ok := t.ConnectionPoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConnectionPoint", oldK)
	}
	e.ConnectionPointId = &newK

	t.ConnectionPoint[newK] = e
	delete(t.ConnectionPoint, oldK)
	return nil
}

// GetOrCreateConnectionPoint retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	key := ConnectionPointId

	if v, ok := t.ConnectionPoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConnectionPoint(ConnectionPointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConnectionPoint got unexpected error: %v", err))
	}
	return v
}

// GetConnectionPoint retrieves the value with the specified key from
// the ConnectionPoint map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetConnectionPoint(ConnectionPointId string) *NetworkInstance_ConnectionPoint {

	if t == nil {
		return nil
	}

	key := ConnectionPointId

	if lm, ok := t.ConnectionPoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteConnectionPoint deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteConnectionPoint(ConnectionPointId string) {
	key := ConnectionPointId

	delete(t.ConnectionPoint, key)
}

// AppendConnectionPoint appends the supplied NetworkInstance_ConnectionPoint struct to the
// list ConnectionPoint of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendConnectionPoint(v *NetworkInstance_ConnectionPoint) error {
	if v.ConnectionPointId == nil {
		return fmt.Errorf("invalid nil key received for ConnectionPointId")
	}

	key := *v.ConnectionPointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConnectionPoint == nil {
		t.ConnectionPoint = make(map[string]*NetworkInstance_ConnectionPoint)
	}

	if _, ok := t.ConnectionPoint[key]; ok {
		return fmt.Errorf("duplicate key for list ConnectionPoint %v", key)
	}

	t.ConnectionPoint[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewInterface(Id string) (*NetworkInstance_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &NetworkInstance_Interface{
		Id: &Id,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Id = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateInterface(Id string) *NetworkInstance_Interface {

	key := Id

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetInterface(Id string) *NetworkInstance_Interface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteInterface(Id string) {
	key := Id

	delete(t.Interface, key)
}

// AppendInterface appends the supplied NetworkInstance_Interface struct to the
// list Interface of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Interface already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendInterface(v *NetworkInstance_Interface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*NetworkInstance_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewProtocol creates a new entry in the Protocol list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) (*NetworkInstance_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NetworkInstance_Protocol{
		Identifier: Identifier,
		Name:       &Name,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameProtocol(oldK, newK NetworkInstance_Protocol_Key) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.Identifier = newK.Identifier
	e.Name = &newK.Name

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(Identifier, Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) *NetworkInstance_Protocol {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteProtocol(Identifier E_PolicyTypes_INSTALL_PROTOCOL_TYPE, Name string) {
	key := NetworkInstance_Protocol_Key{
		Identifier: Identifier,
		Name:       Name,
	}

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NetworkInstance_Protocol struct to the
// list Protocol of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Protocol already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendProtocol(v *NetworkInstance_Protocol) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := NetworkInstance_Protocol_Key{
		Identifier: v.Identifier,
		Name:       *v.Name,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NetworkInstance_Protocol_Key]*NetworkInstance_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// NewRouteLimit creates a new entry in the RouteLimit list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewRouteLimit(Afi E_Types_ADDRESS_FAMILY) (*NetworkInstance_RouteLimit, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	key := Afi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RouteLimit[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RouteLimit", key)
	}

	t.RouteLimit[key] = &NetworkInstance_RouteLimit{
		Afi: Afi,
	}

	return t.RouteLimit[key], nil
}

// RenameRouteLimit renames an entry in the list RouteLimit within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameRouteLimit(oldK, newK E_Types_ADDRESS_FAMILY) error {
	if _, ok := t.RouteLimit[newK]; ok {
		return fmt.Errorf("key %v already exists in RouteLimit", newK)
	}

	e, ok := t.RouteLimit[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RouteLimit", oldK)
	}
	e.Afi = newK

	t.RouteLimit[newK] = e
	delete(t.RouteLimit, oldK)
	return nil
}

// GetOrCreateRouteLimit retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	key := Afi

	if v, ok := t.RouteLimit[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRouteLimit(Afi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRouteLimit got unexpected error: %v", err))
	}
	return v
}

// GetRouteLimit retrieves the value with the specified key from
// the RouteLimit map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetRouteLimit(Afi E_Types_ADDRESS_FAMILY) *NetworkInstance_RouteLimit {

	if t == nil {
		return nil
	}

	key := Afi

	if lm, ok := t.RouteLimit[key]; ok {
		return lm
	}
	return nil
}

// DeleteRouteLimit deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteRouteLimit(Afi E_Types_ADDRESS_FAMILY) {
	key := Afi

	delete(t.RouteLimit, key)
}

// AppendRouteLimit appends the supplied NetworkInstance_RouteLimit struct to the
// list RouteLimit of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_RouteLimit already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendRouteLimit(v *NetworkInstance_RouteLimit) error {
	key := v.Afi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RouteLimit == nil {
		t.RouteLimit = make(map[E_Types_ADDRESS_FAMILY]*NetworkInstance_RouteLimit)
	}

	if _, ok := t.RouteLimit[key]; ok {
		return fmt.Errorf("duplicate key for list RouteLimit %v", key)
	}

	t.RouteLimit[key] = v
	return nil
}

// NewTable creates a new entry in the Table list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_Table, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Table[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Table", key)
	}

	t.Table[key] = &NetworkInstance_Table{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	return t.Table[key], nil
}

// RenameTable renames an entry in the list Table within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTable(oldK, newK NetworkInstance_Table_Key) error {
	if _, ok := t.Table[newK]; ok {
		return fmt.Errorf("key %v already exists in Table", newK)
	}

	e, ok := t.Table[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Table", oldK)
	}
	e.Protocol = newK.Protocol
	e.AddressFamily = newK.AddressFamily

	t.Table[newK] = e
	delete(t.Table, oldK)
	return nil
}

// GetOrCreateTable retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.Table[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTable(Protocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTable got unexpected error: %v", err))
	}
	return v
}

// GetTable retrieves the value with the specified key from
// the Table map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_Table {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.Table[key]; ok {
		return lm
	}
	return nil
}

// DeleteTable deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTable(Protocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_Table_Key{
		Protocol:      Protocol,
		AddressFamily: AddressFamily,
	}

	delete(t.Table, key)
}

// AppendTable appends the supplied NetworkInstance_Table struct to the
// list Table of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Table already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTable(v *NetworkInstance_Table) error {
	key := NetworkInstance_Table_Key{
		Protocol:      v.Protocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Table == nil {
		t.Table = make(map[NetworkInstance_Table_Key]*NetworkInstance_Table)
	}

	if _, ok := t.Table[key]; ok {
		return fmt.Errorf("duplicate key for list Table %v", key)
	}

	t.Table[key] = v
	return nil
}

// NewTableConnection creates a new entry in the TableConnection list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) (*NetworkInstance_TableConnection, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TableConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TableConnection", key)
	}

	t.TableConnection[key] = &NetworkInstance_TableConnection{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	return t.TableConnection[key], nil
}

// RenameTableConnection renames an entry in the list TableConnection within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameTableConnection(oldK, newK NetworkInstance_TableConnection_Key) error {
	if _, ok := t.TableConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in TableConnection", newK)
	}

	e, ok := t.TableConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TableConnection", oldK)
	}
	e.SrcProtocol = newK.SrcProtocol
	e.DstProtocol = newK.DstProtocol
	e.AddressFamily = newK.AddressFamily

	t.TableConnection[newK] = e
	delete(t.TableConnection, oldK)
	return nil
}

// GetOrCreateTableConnection retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if v, ok := t.TableConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTableConnection(SrcProtocol, DstProtocol, AddressFamily)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTableConnection got unexpected error: %v", err))
	}
	return v
}

// GetTableConnection retrieves the value with the specified key from
// the TableConnection map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) *NetworkInstance_TableConnection {

	if t == nil {
		return nil
	}

	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	if lm, ok := t.TableConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteTableConnection deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteTableConnection(SrcProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, DstProtocol E_PolicyTypes_INSTALL_PROTOCOL_TYPE, AddressFamily E_Types_ADDRESS_FAMILY) {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   SrcProtocol,
		DstProtocol:   DstProtocol,
		AddressFamily: AddressFamily,
	}

	delete(t.TableConnection, key)
}

// AppendTableConnection appends the supplied NetworkInstance_TableConnection struct to the
// list TableConnection of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_TableConnection already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendTableConnection(v *NetworkInstance_TableConnection) error {
	key := NetworkInstance_TableConnection_Key{
		SrcProtocol:   v.SrcProtocol,
		DstProtocol:   v.DstProtocol,
		AddressFamily: v.AddressFamily,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TableConnection == nil {
		t.TableConnection = make(map[NetworkInstance_TableConnection_Key]*NetworkInstance_TableConnection)
	}

	if _, ok := t.TableConnection[key]; ok {
		return fmt.Errorf("duplicate key for list TableConnection %v", key)
	}

	t.TableConnection[key] = v
	return nil
}

// NewVlan creates a new entry in the Vlan list of the
// NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance) NewVlan(VlanId uint16) (*NetworkInstance_Vlan, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	key := VlanId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vlan[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vlan", key)
	}

	t.Vlan[key] = &NetworkInstance_Vlan{
		VlanId: &VlanId,
	}

	return t.Vlan[key], nil
}

// RenameVlan renames an entry in the list Vlan within
// the NetworkInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance) RenameVlan(oldK, newK uint16) error {
	if _, ok := t.Vlan[newK]; ok {
		return fmt.Errorf("key %v already exists in Vlan", newK)
	}

	e, ok := t.Vlan[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vlan", oldK)
	}
	e.VlanId = &newK

	t.Vlan[newK] = e
	delete(t.Vlan, oldK)
	return nil
}

// GetOrCreateVlan retrieves the value with the specified keys from
// the receiver NetworkInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance) GetOrCreateVlan(VlanId uint16) *NetworkInstance_Vlan {

	key := VlanId

	if v, ok := t.Vlan[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlan(VlanId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlan got unexpected error: %v", err))
	}
	return v
}

// GetVlan retrieves the value with the specified key from
// the Vlan map field of NetworkInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance) GetVlan(VlanId uint16) *NetworkInstance_Vlan {

	if t == nil {
		return nil
	}

	key := VlanId

	if lm, ok := t.Vlan[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlan deletes the value with the specified keys from
// the receiver NetworkInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance) DeleteVlan(VlanId uint16) {
	key := VlanId

	delete(t.Vlan, key)
}

// AppendVlan appends the supplied NetworkInstance_Vlan struct to the
// list Vlan of NetworkInstance. If the key value(s) specified in
// the supplied NetworkInstance_Vlan already exist in the list, an error is
// returned.
func (t *NetworkInstance) AppendVlan(v *NetworkInstance_Vlan) error {
	if v.VlanId == nil {
		return fmt.Errorf("invalid nil key received for VlanId")
	}

	key := *v.VlanId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vlan == nil {
		t.Vlan = make(map[uint16]*NetworkInstance_Vlan)
	}

	if _, ok := t.Vlan[key]; ok {
		return fmt.Errorf("duplicate key for list Vlan %v", key)
	}

	t.Vlan[key] = v
	return nil
}

// GetOrCreateAfts retrieves the value of the Afts field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateAfts() *NetworkInstance_Afts {
	if t.Afts != nil {
		return t.Afts
	}
	t.Afts = &NetworkInstance_Afts{}
	return t.Afts
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEncapsulation() *NetworkInstance_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &NetworkInstance_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateEvpn() *NetworkInstance_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &NetworkInstance_Evpn{}
	return t.Evpn
}

// GetOrCreateFdb retrieves the value of the Fdb field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFdb() *NetworkInstance_Fdb {
	if t.Fdb != nil {
		return t.Fdb
	}
	t.Fdb = &NetworkInstance_Fdb{}
	return t.Fdb
}

// GetOrCreateFlexAlgorithm retrieves the value of the FlexAlgorithm field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateFlexAlgorithm() *NetworkInstance_FlexAlgorithm {
	if t.FlexAlgorithm != nil {
		return t.FlexAlgorithm
	}
	t.FlexAlgorithm = &NetworkInstance_FlexAlgorithm{}
	return t.FlexAlgorithm
}

// GetOrCreateInterInstancePolicies retrieves the value of the InterInstancePolicies field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	t.InterInstancePolicies = &NetworkInstance_InterInstancePolicies{}
	return t.InterInstancePolicies
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateMpls() *NetworkInstance_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &NetworkInstance_Mpls{}
	return t.Mpls
}

// GetOrCreatePolicyForwarding retrieves the value of the PolicyForwarding field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreatePolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	t.PolicyForwarding = &NetworkInstance_PolicyForwarding{}
	return t.PolicyForwarding
}

// GetOrCreateSegmentRouting retrieves the value of the SegmentRouting field
// or returns the existing field if it already exists.
func (t *NetworkInstance) GetOrCreateSegmentRouting() *NetworkInstance_SegmentRouting {
	if t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	t.SegmentRouting = &NetworkInstance_SegmentRouting{}
	return t.SegmentRouting
}

// GetAfts returns the value of the Afts struct pointer
// from NetworkInstance. If the receiver or the field Afts is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetAfts() *NetworkInstance_Afts {
	if t != nil && t.Afts != nil {
		return t.Afts
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from NetworkInstance. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEncapsulation() *NetworkInstance_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from NetworkInstance. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetEvpn() *NetworkInstance_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetFdb returns the value of the Fdb struct pointer
// from NetworkInstance. If the receiver or the field Fdb is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFdb() *NetworkInstance_Fdb {
	if t != nil && t.Fdb != nil {
		return t.Fdb
	}
	return nil
}

// GetFlexAlgorithm returns the value of the FlexAlgorithm struct pointer
// from NetworkInstance. If the receiver or the field FlexAlgorithm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetFlexAlgorithm() *NetworkInstance_FlexAlgorithm {
	if t != nil && t.FlexAlgorithm != nil {
		return t.FlexAlgorithm
	}
	return nil
}

// GetInterInstancePolicies returns the value of the InterInstancePolicies struct pointer
// from NetworkInstance. If the receiver or the field InterInstancePolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetInterInstancePolicies() *NetworkInstance_InterInstancePolicies {
	if t != nil && t.InterInstancePolicies != nil {
		return t.InterInstancePolicies
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from NetworkInstance. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetMpls() *NetworkInstance_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetPolicyForwarding returns the value of the PolicyForwarding struct pointer
// from NetworkInstance. If the receiver or the field PolicyForwarding is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetPolicyForwarding() *NetworkInstance_PolicyForwarding {
	if t != nil && t.PolicyForwarding != nil {
		return t.PolicyForwarding
	}
	return nil
}

// GetSegmentRouting returns the value of the SegmentRouting struct pointer
// from NetworkInstance. If the receiver or the field SegmentRouting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance) GetSegmentRouting() *NetworkInstance_SegmentRouting {
	if t != nil && t.SegmentRouting != nil {
		return t.SegmentRouting
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFallbackNetworkInstance retrieves the value of the leaf FallbackNetworkInstance from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallbackNetworkInstance is set, it can
// safely use t.GetFallbackNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallbackNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetFallbackNetworkInstance() string {
	if t == nil || t.FallbackNetworkInstance == nil {
		return ""
	}
	return *t.FallbackNetworkInstance
}

// GetName retrieves the value of the leaf Name from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouteDistinguisher() string {
	if t == nil || t.RouteDistinguisher == nil {
		return ""
	}
	return *t.RouteDistinguisher
}

// GetRouterId retrieves the value of the leaf RouterId from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterId is set, it can
// safely use t.GetRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterId == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetRouterId() string {
	if t == nil || t.RouterId == nil {
		return ""
	}
	return *t.RouterId
}

// GetType retrieves the value of the leaf Type from the NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance) GetType() E_NetworkInstanceTypes_NETWORK_INSTANCE_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Afts.PopulateDefaults()
	t.Encapsulation.PopulateDefaults()
	t.Evpn.PopulateDefaults()
	t.Fdb.PopulateDefaults()
	t.FlexAlgorithm.PopulateDefaults()
	t.InterInstancePolicies.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.PolicyForwarding.PopulateDefaults()
	t.SegmentRouting.PopulateDefaults()
	for _, e := range t.ConnectionPoint {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
	for _, e := range t.RouteLimit {
		e.PopulateDefaults()
	}
	for _, e := range t.Table {
		e.PopulateDefaults()
	}
	for _, e := range t.TableConnection {
		e.PopulateDefaults()
	}
	for _, e := range t.Vlan {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance struct, which is a YANG list entry.
func (t *NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance.
func (*NetworkInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts represents the /openconfig-network-instance/network-instances/network-instance/afts YANG schema element.
type NetworkInstance_Afts struct {
	ΛMetadata              []ygot.Annotation                                                                `path:"@" ygotAnnotation:"true"`
	Ipv4Entry              map[string]*NetworkInstance_Afts_Ipv4Entry                                       `path:"ipv4-unicast/ipv4-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpv4Entry             []ygot.Annotation                                                                `path:"ipv4-unicast/@ipv4-entry" ygotAnnotation:"true"`
	Ipv6Entry              map[string]*NetworkInstance_Afts_Ipv6Entry                                       `path:"ipv6-unicast/ipv6-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpv6Entry             []ygot.Annotation                                                                `path:"ipv6-unicast/@ipv6-entry" ygotAnnotation:"true"`
	LabelEntry             map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry `path:"mpls/label-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLabelEntry            []ygot.Annotation                                                                `path:"mpls/@label-entry" ygotAnnotation:"true"`
	MacEntry               map[string]*NetworkInstance_Afts_MacEntry                                        `path:"ethernet/mac-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacEntry              []ygot.Annotation                                                                `path:"ethernet/@mac-entry" ygotAnnotation:"true"`
	NextHop                map[uint64]*NetworkInstance_Afts_NextHop                                         `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop               []ygot.Annotation                                                                `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	NextHopGroup           map[uint64]*NetworkInstance_Afts_NextHopGroup                                    `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup          []ygot.Annotation                                                                `path:"next-hop-groups/@next-hop-group" ygotAnnotation:"true"`
	PolicyForwardingEntry  map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry                           `path:"policy-forwarding/policy-forwarding-entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPolicyForwardingEntry []ygot.Annotation                                                                `path:"policy-forwarding/@policy-forwarding-entry" ygotAnnotation:"true"`
	StateSynced            *NetworkInstance_Afts_StateSynced                                                `path:"state-synced" module:"openconfig-network-instance"`
	ΛStateSynced           []ygot.Annotation                                                                `path:"@state-synced" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts) IsYANGGoStruct() {}

// NewIpv4Entry creates a new entry in the Ipv4Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv4Entry(Prefix string) (*NetworkInstance_Afts_Ipv4Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Entry", key)
	}

	t.Ipv4Entry[key] = &NetworkInstance_Afts_Ipv4Entry{
		Prefix: &Prefix,
	}

	return t.Ipv4Entry[key], nil
}

// RenameIpv4Entry renames an entry in the list Ipv4Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv4Entry(oldK, newK string) error {
	if _, ok := t.Ipv4Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Entry", newK)
	}

	e, ok := t.Ipv4Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv4Entry[newK] = e
	delete(t.Ipv4Entry, oldK)
	return nil
}

// GetOrCreateIpv4Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	key := Prefix

	if v, ok := t.Ipv4Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Entry retrieves the value with the specified key from
// the Ipv4Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv4Entry(Prefix string) *NetworkInstance_Afts_Ipv4Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv4Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv4Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv4Entry, key)
}

// AppendIpv4Entry appends the supplied NetworkInstance_Afts_Ipv4Entry struct to the
// list Ipv4Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv4Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv4Entry(v *NetworkInstance_Afts_Ipv4Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Entry == nil {
		t.Ipv4Entry = make(map[string]*NetworkInstance_Afts_Ipv4Entry)
	}

	if _, ok := t.Ipv4Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Entry %v", key)
	}

	t.Ipv4Entry[key] = v
	return nil
}

// NewIpv6Entry creates a new entry in the Ipv6Entry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewIpv6Entry(Prefix string) (*NetworkInstance_Afts_Ipv6Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Entry", key)
	}

	t.Ipv6Entry[key] = &NetworkInstance_Afts_Ipv6Entry{
		Prefix: &Prefix,
	}

	return t.Ipv6Entry[key], nil
}

// RenameIpv6Entry renames an entry in the list Ipv6Entry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameIpv6Entry(oldK, newK string) error {
	if _, ok := t.Ipv6Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Entry", newK)
	}

	e, ok := t.Ipv6Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Entry", oldK)
	}
	e.Prefix = &newK

	t.Ipv6Entry[newK] = e
	delete(t.Ipv6Entry, oldK)
	return nil
}

// GetOrCreateIpv6Entry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	key := Prefix

	if v, ok := t.Ipv6Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Entry(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Entry got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Entry retrieves the value with the specified key from
// the Ipv6Entry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetIpv6Entry(Prefix string) *NetworkInstance_Afts_Ipv6Entry {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Ipv6Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Entry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteIpv6Entry(Prefix string) {
	key := Prefix

	delete(t.Ipv6Entry, key)
}

// AppendIpv6Entry appends the supplied NetworkInstance_Afts_Ipv6Entry struct to the
// list Ipv6Entry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_Ipv6Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendIpv6Entry(v *NetworkInstance_Afts_Ipv6Entry) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Entry == nil {
		t.Ipv6Entry = make(map[string]*NetworkInstance_Afts_Ipv6Entry)
	}

	if _, ok := t.Ipv6Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Entry %v", key)
	}

	t.Ipv6Entry[key] = v
	return nil
}

// NewLabelEntry creates a new entry in the LabelEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) (*NetworkInstance_Afts_LabelEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	key := Label

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LabelEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LabelEntry", key)
	}

	t.LabelEntry[key] = &NetworkInstance_Afts_LabelEntry{
		Label: Label,
	}

	return t.LabelEntry[key], nil
}

// RenameLabelEntry renames an entry in the list LabelEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameLabelEntry(oldK, newK NetworkInstance_Afts_LabelEntry_Label_Union) error {
	if _, ok := t.LabelEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in LabelEntry", newK)
	}

	e, ok := t.LabelEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LabelEntry", oldK)
	}
	e.Label = newK

	t.LabelEntry[newK] = e
	delete(t.LabelEntry, oldK)
	return nil
}

// GetOrCreateLabelEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	key := Label

	if v, ok := t.LabelEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLabelEntry(Label)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLabelEntry got unexpected error: %v", err))
	}
	return v
}

// GetLabelEntry retrieves the value with the specified key from
// the LabelEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) *NetworkInstance_Afts_LabelEntry {

	if t == nil {
		return nil
	}

	key := Label

	if lm, ok := t.LabelEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteLabelEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteLabelEntry(Label NetworkInstance_Afts_LabelEntry_Label_Union) {
	key := Label

	delete(t.LabelEntry, key)
}

// AppendLabelEntry appends the supplied NetworkInstance_Afts_LabelEntry struct to the
// list LabelEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_LabelEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendLabelEntry(v *NetworkInstance_Afts_LabelEntry) error {
	key := v.Label

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LabelEntry == nil {
		t.LabelEntry = make(map[NetworkInstance_Afts_LabelEntry_Label_Union]*NetworkInstance_Afts_LabelEntry)
	}

	if _, ok := t.LabelEntry[key]; ok {
		return fmt.Errorf("duplicate key for list LabelEntry %v", key)
	}

	t.LabelEntry[key] = v
	return nil
}

// NewMacEntry creates a new entry in the MacEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewMacEntry(MacAddress string) (*NetworkInstance_Afts_MacEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	key := MacAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacEntry", key)
	}

	t.MacEntry[key] = &NetworkInstance_Afts_MacEntry{
		MacAddress: &MacAddress,
	}

	return t.MacEntry[key], nil
}

// RenameMacEntry renames an entry in the list MacEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameMacEntry(oldK, newK string) error {
	if _, ok := t.MacEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in MacEntry", newK)
	}

	e, ok := t.MacEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacEntry", oldK)
	}
	e.MacAddress = &newK

	t.MacEntry[newK] = e
	delete(t.MacEntry, oldK)
	return nil
}

// GetOrCreateMacEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	key := MacAddress

	if v, ok := t.MacEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacEntry(MacAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacEntry got unexpected error: %v", err))
	}
	return v
}

// GetMacEntry retrieves the value with the specified key from
// the MacEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetMacEntry(MacAddress string) *NetworkInstance_Afts_MacEntry {

	if t == nil {
		return nil
	}

	key := MacAddress

	if lm, ok := t.MacEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteMacEntry(MacAddress string) {
	key := MacAddress

	delete(t.MacEntry, key)
}

// AppendMacEntry appends the supplied NetworkInstance_Afts_MacEntry struct to the
// list MacEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_MacEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendMacEntry(v *NetworkInstance_Afts_MacEntry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key received for MacAddress")
	}

	key := *v.MacAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacEntry == nil {
		t.MacEntry = make(map[string]*NetworkInstance_Afts_MacEntry)
	}

	if _, ok := t.MacEntry[key]; ok {
		return fmt.Errorf("duplicate key for list MacEntry %v", key)
	}

	t.MacEntry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHop struct to the
// list NextHop of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHop(v *NetworkInstance_Afts_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewNextHopGroup(Id uint64) (*NetworkInstance_Afts_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Afts_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetNextHopGroup(Id uint64) *NetworkInstance_Afts_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Afts_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendNextHopGroup(v *NetworkInstance_Afts_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Afts_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// NewPolicyForwardingEntry creates a new entry in the PolicyForwardingEntry list of the
// NetworkInstance_Afts struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts) NewPolicyForwardingEntry(Index uint64) (*NetworkInstance_Afts_PolicyForwardingEntry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicyForwardingEntry", key)
	}

	t.PolicyForwardingEntry[key] = &NetworkInstance_Afts_PolicyForwardingEntry{
		Index: &Index,
	}

	return t.PolicyForwardingEntry[key], nil
}

// RenamePolicyForwardingEntry renames an entry in the list PolicyForwardingEntry within
// the NetworkInstance_Afts struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts) RenamePolicyForwardingEntry(oldK, newK uint64) error {
	if _, ok := t.PolicyForwardingEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicyForwardingEntry", newK)
	}

	e, ok := t.PolicyForwardingEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicyForwardingEntry", oldK)
	}
	e.Index = &newK

	t.PolicyForwardingEntry[newK] = e
	delete(t.PolicyForwardingEntry, oldK)
	return nil
}

// GetOrCreatePolicyForwardingEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts) GetOrCreatePolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	key := Index

	if v, ok := t.PolicyForwardingEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicyForwardingEntry(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicyForwardingEntry got unexpected error: %v", err))
	}
	return v
}

// GetPolicyForwardingEntry retrieves the value with the specified key from
// the PolicyForwardingEntry map field of NetworkInstance_Afts. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts) GetPolicyForwardingEntry(Index uint64) *NetworkInstance_Afts_PolicyForwardingEntry {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.PolicyForwardingEntry[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicyForwardingEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Afts. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts) DeletePolicyForwardingEntry(Index uint64) {
	key := Index

	delete(t.PolicyForwardingEntry, key)
}

// AppendPolicyForwardingEntry appends the supplied NetworkInstance_Afts_PolicyForwardingEntry struct to the
// list PolicyForwardingEntry of NetworkInstance_Afts. If the key value(s) specified in
// the supplied NetworkInstance_Afts_PolicyForwardingEntry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts) AppendPolicyForwardingEntry(v *NetworkInstance_Afts_PolicyForwardingEntry) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicyForwardingEntry == nil {
		t.PolicyForwardingEntry = make(map[uint64]*NetworkInstance_Afts_PolicyForwardingEntry)
	}

	if _, ok := t.PolicyForwardingEntry[key]; ok {
		return fmt.Errorf("duplicate key for list PolicyForwardingEntry %v", key)
	}

	t.PolicyForwardingEntry[key] = v
	return nil
}

// GetOrCreateStateSynced retrieves the value of the StateSynced field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts) GetOrCreateStateSynced() *NetworkInstance_Afts_StateSynced {
	if t.StateSynced != nil {
		return t.StateSynced
	}
	t.StateSynced = &NetworkInstance_Afts_StateSynced{}
	return t.StateSynced
}

// GetStateSynced returns the value of the StateSynced struct pointer
// from NetworkInstance_Afts. If the receiver or the field StateSynced is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts) GetStateSynced() *NetworkInstance_Afts_StateSynced {
	if t != nil && t.StateSynced != nil {
		return t.StateSynced
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.StateSynced.PopulateDefaults()
	for _, e := range t.Ipv4Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.LabelEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.MacEntry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.PolicyForwardingEntry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts.
func (*NetworkInstance_Afts) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry YANG schema element.
type NetworkInstance_Afts_Ipv4Entry struct {
	ΛMetadata                    []ygot.Annotation                        `path:"@" ygotAnnotation:"true"`
	Counters                     *NetworkInstance_Afts_Ipv4Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                    []ygot.Annotation                        `path:"state/@counters" ygotAnnotation:"true"`
	DecapsulateHeader            E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDecapsulateHeader           []ygot.Annotation                        `path:"state/@decapsulate-header" ygotAnnotation:"true"`
	EntryMetadata                Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryMetadata               []ygot.Annotation                        `path:"state/@entry-metadata" ygotAnnotation:"true"`
	NextHopGroup                 *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroup                []ygot.Annotation                        `path:"state/@next-hop-group" ygotAnnotation:"true"`
	NextHopGroupNetworkInstance  *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroupNetworkInstance []ygot.Annotation                        `path:"state/@next-hop-group-network-instance" ygotAnnotation:"true"`
	OriginNetworkInstance        *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛOriginNetworkInstance       []ygot.Annotation                        `path:"state/@origin-network-instance" ygotAnnotation:"true"`
	OriginProtocol               E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOriginProtocol              []ygot.Annotation                        `path:"state/@origin-protocol" ygotAnnotation:"true"`
	Prefix                       *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛPrefix                      []ygot.Annotation                        `path:"state/@prefix|@prefix" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv4Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv4Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv4Entry) GetCounters() *NetworkInstance_Afts_Ipv4Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv4Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv4Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry.
func (*NetworkInstance_Afts_Ipv4Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv4Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv4-unicast/ipv4-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv4Entry_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv4Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv4Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv4Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv4Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv4Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv4Entry_Counters.
func (*NetworkInstance_Afts_Ipv4Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry YANG schema element.
type NetworkInstance_Afts_Ipv6Entry struct {
	ΛMetadata                    []ygot.Annotation                        `path:"@" ygotAnnotation:"true"`
	Counters                     *NetworkInstance_Afts_Ipv6Entry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                    []ygot.Annotation                        `path:"state/@counters" ygotAnnotation:"true"`
	DecapsulateHeader            E_AftTypes_EncapsulationHeaderType       `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDecapsulateHeader           []ygot.Annotation                        `path:"state/@decapsulate-header" ygotAnnotation:"true"`
	EntryMetadata                Binary                                   `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryMetadata               []ygot.Annotation                        `path:"state/@entry-metadata" ygotAnnotation:"true"`
	NextHopGroup                 *uint64                                  `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroup                []ygot.Annotation                        `path:"state/@next-hop-group" ygotAnnotation:"true"`
	NextHopGroupNetworkInstance  *string                                  `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroupNetworkInstance []ygot.Annotation                        `path:"state/@next-hop-group-network-instance" ygotAnnotation:"true"`
	OriginNetworkInstance        *string                                  `path:"state/origin-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛOriginNetworkInstance       []ygot.Annotation                        `path:"state/@origin-network-instance" ygotAnnotation:"true"`
	OriginProtocol               E_PolicyTypes_INSTALL_PROTOCOL_TYPE      `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOriginProtocol              []ygot.Annotation                        `path:"state/@origin-protocol" ygotAnnotation:"true"`
	Prefix                       *string                                  `path:"state/prefix|prefix" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛPrefix                      []ygot.Annotation                        `path:"state/@prefix|@prefix" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOrCreateCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_Ipv6Entry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_Ipv6Entry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_Ipv6Entry) GetCounters() *NetworkInstance_Afts_Ipv6Entry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetOriginNetworkInstance retrieves the value of the leaf OriginNetworkInstance from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginNetworkInstance is set, it can
// safely use t.GetOriginNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginNetworkInstance() string {
	if t == nil || t.OriginNetworkInstance == nil {
		return ""
	}
	return *t.OriginNetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPrefix retrieves the value of the leaf Prefix from the NetworkInstance_Afts_Ipv6Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_Ipv6Entry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry.
func (*NetworkInstance_Afts_Ipv6Entry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_Ipv6Entry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ipv6-unicast/ipv6-entry/state/counters YANG schema element.
type NetworkInstance_Afts_Ipv6Entry_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_Ipv6Entry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_Ipv6Entry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_Ipv6Entry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_Ipv6Entry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_Ipv6Entry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_Ipv6Entry_Counters.
func (*NetworkInstance_Afts_Ipv6Entry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry YANG schema element.
type NetworkInstance_Afts_LabelEntry struct {
	ΛMetadata                    []ygot.Annotation                                            `path:"@" ygotAnnotation:"true"`
	Counters                     *NetworkInstance_Afts_LabelEntry_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                    []ygot.Annotation                                            `path:"state/@counters" ygotAnnotation:"true"`
	EntryMetadata                Binary                                                       `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryMetadata               []ygot.Annotation                                            `path:"state/@entry-metadata" ygotAnnotation:"true"`
	Label                        NetworkInstance_Afts_LabelEntry_Label_Union                  `path:"state/label|label" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛLabel                       []ygot.Annotation                                            `path:"state/@label|@label" ygotAnnotation:"true"`
	NextHopGroup                 *uint64                                                      `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroup                []ygot.Annotation                                            `path:"state/@next-hop-group" ygotAnnotation:"true"`
	NextHopGroupNetworkInstance  *string                                                      `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroupNetworkInstance []ygot.Annotation                                            `path:"state/@next-hop-group-network-instance" ygotAnnotation:"true"`
	PoppedMplsLabelStack         []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union `path:"state/popped-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPoppedMplsLabelStack        []ygot.Annotation                                            `path:"state/@popped-mpls-label-stack" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_LabelEntry) GetOrCreateCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_LabelEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_LabelEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_LabelEntry) GetCounters() *NetworkInstance_Afts_LabelEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetLabel retrieves the value of the leaf Label from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Label is set, it can
// safely use t.GetLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Label == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetLabel() NetworkInstance_Afts_LabelEntry_Label_Union {
	if t == nil || t.Label == nil {
		return nil
	}
	return t.Label
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// GetPoppedMplsLabelStack retrieves the value of the leaf PoppedMplsLabelStack from the NetworkInstance_Afts_LabelEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PoppedMplsLabelStack is set, it can
// safely use t.GetPoppedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PoppedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry) GetPoppedMplsLabelStack() []NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union {
	if t == nil || t.PoppedMplsLabelStack == nil {
		return nil
	}
	return t.PoppedMplsLabelStack
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_LabelEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_LabelEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry.
func (*NetworkInstance_Afts_LabelEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_LabelEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/counters YANG schema element.
type NetworkInstance_Afts_LabelEntry_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_LabelEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_LabelEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_LabelEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_LabelEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_LabelEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_LabelEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_LabelEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_LabelEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_LabelEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_LabelEntry_Counters.
func (*NetworkInstance_Afts_LabelEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry YANG schema element.
type NetworkInstance_Afts_MacEntry struct {
	ΛMetadata                    []ygot.Annotation                       `path:"@" ygotAnnotation:"true"`
	Counters                     *NetworkInstance_Afts_MacEntry_Counters `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                    []ygot.Annotation                       `path:"state/@counters" ygotAnnotation:"true"`
	EntryMetadata                Binary                                  `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryMetadata               []ygot.Annotation                       `path:"state/@entry-metadata" ygotAnnotation:"true"`
	MacAddress                   *string                                 `path:"state/mac-address|mac-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛMacAddress                  []ygot.Annotation                       `path:"state/@mac-address|@mac-address" ygotAnnotation:"true"`
	NextHopGroup                 *uint64                                 `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroup                []ygot.Annotation                       `path:"state/@next-hop-group" ygotAnnotation:"true"`
	NextHopGroupNetworkInstance  *string                                 `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroupNetworkInstance []ygot.Annotation                       `path:"state/@next-hop-group-network-instance" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_MacEntry) GetOrCreateCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_MacEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_MacEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_MacEntry) GetCounters() *NetworkInstance_Afts_MacEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_MacEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_MacEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_MacEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MacAddress == nil {
		return nil, fmt.Errorf("nil value for key MacAddress")
	}

	return map[string]interface{}{
		"mac-address": *t.MacAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry.
func (*NetworkInstance_Afts_MacEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_MacEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/ethernet/mac-entry/state/counters YANG schema element.
type NetworkInstance_Afts_MacEntry_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_MacEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_MacEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_MacEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_MacEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_MacEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_MacEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_MacEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_MacEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_MacEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_MacEntry_Counters.
func (*NetworkInstance_Afts_MacEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHop struct {
	ΛMetadata             []ygot.Annotation                                         `path:"@" ygotAnnotation:"true"`
	Counters              *NetworkInstance_Afts_NextHop_Counters                    `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters             []ygot.Annotation                                         `path:"state/@counters" ygotAnnotation:"true"`
	DecapsulateHeader     E_AftTypes_EncapsulationHeaderType                        `path:"state/decapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDecapsulateHeader    []ygot.Annotation                                         `path:"state/@decapsulate-header" ygotAnnotation:"true"`
	EncapsulateHeader     E_AftTypes_EncapsulationHeaderType                        `path:"state/encapsulate-header" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEncapsulateHeader    []ygot.Annotation                                         `path:"state/@encapsulate-header" ygotAnnotation:"true"`
	Index                 *uint64                                                   `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex                []ygot.Annotation                                         `path:"state/@index|@index" ygotAnnotation:"true"`
	InterfaceRef          *NetworkInstance_Afts_NextHop_InterfaceRef                `path:"interface-ref" module:"openconfig-network-instance"`
	ΛInterfaceRef         []ygot.Annotation                                         `path:"@interface-ref" ygotAnnotation:"true"`
	IpAddress             *string                                                   `path:"state/ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpAddress            []ygot.Annotation                                         `path:"state/@ip-address" ygotAnnotation:"true"`
	IpInIp                *NetworkInstance_Afts_NextHop_IpInIp                      `path:"ip-in-ip" module:"openconfig-network-instance"`
	ΛIpInIp               []ygot.Annotation                                         `path:"@ip-in-ip" ygotAnnotation:"true"`
	LspName               *string                                                   `path:"state/lsp-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLspName              []ygot.Annotation                                         `path:"state/@lsp-name" ygotAnnotation:"true"`
	MacAddress            *string                                                   `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacAddress           []ygot.Annotation                                         `path:"state/@mac-address" ygotAnnotation:"true"`
	NetworkInstance       *string                                                   `path:"state/network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNetworkInstance      []ygot.Annotation                                         `path:"state/@network-instance" ygotAnnotation:"true"`
	OriginProtocol        E_PolicyTypes_INSTALL_PROTOCOL_TYPE                       `path:"state/origin-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOriginProtocol       []ygot.Annotation                                         `path:"state/@origin-protocol" ygotAnnotation:"true"`
	PopTopLabel           *bool                                                     `path:"state/pop-top-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPopTopLabel          []ygot.Annotation                                         `path:"state/@pop-top-label" ygotAnnotation:"true"`
	ProgrammedIndex       *uint64                                                   `path:"state/programmed-index" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProgrammedIndex      []ygot.Annotation                                         `path:"state/@programmed-index" ygotAnnotation:"true"`
	PushedMplsLabelStack  []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union `path:"state/pushed-mpls-label-stack" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPushedMplsLabelStack []ygot.Annotation                                         `path:"state/@pushed-mpls-label-stack" ygotAnnotation:"true"`
	TunnelSrcIpAddress    *string                                                   `path:"state/tunnel-src-ip-address" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛTunnelSrcIpAddress   []ygot.Annotation                                         `path:"state/@tunnel-src-ip-address" ygotAnnotation:"true"`
	VniLabel              *uint32                                                   `path:"state/vni-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVniLabel             []ygot.Annotation                                         `path:"state/@vni-label" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_NextHop_Counters{}
	return t.Counters
}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &NetworkInstance_Afts_NextHop_InterfaceRef{}
	return t.InterfaceRef
}

// GetOrCreateIpInIp retrieves the value of the IpInIp field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_NextHop) GetOrCreateIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t.IpInIp != nil {
		return t.IpInIp
	}
	t.IpInIp = &NetworkInstance_Afts_NextHop_IpInIp{}
	return t.IpInIp
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetCounters() *NetworkInstance_Afts_NextHop_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetInterfaceRef() *NetworkInstance_Afts_NextHop_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetIpInIp returns the value of the IpInIp struct pointer
// from NetworkInstance_Afts_NextHop. If the receiver or the field IpInIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_NextHop) GetIpInIp() *NetworkInstance_Afts_NextHop_IpInIp {
	if t != nil && t.IpInIp != nil {
		return t.IpInIp
	}
	return nil
}

// GetDecapsulateHeader retrieves the value of the leaf DecapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DecapsulateHeader is set, it can
// safely use t.GetDecapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DecapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetDecapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.DecapsulateHeader == 0 {
		return 0
	}
	return t.DecapsulateHeader
}

// GetEncapsulateHeader retrieves the value of the leaf EncapsulateHeader from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulateHeader is set, it can
// safely use t.GetEncapsulateHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulateHeader == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetEncapsulateHeader() E_AftTypes_EncapsulationHeaderType {
	if t == nil || t.EncapsulateHeader == 0 {
		return 0
	}
	return t.EncapsulateHeader
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpAddress retrieves the value of the leaf IpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetLspName retrieves the value of the leaf LspName from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspName is set, it can
// safely use t.GetLspName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetLspName() string {
	if t == nil || t.LspName == nil {
		return ""
	}
	return *t.LspName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOriginProtocol retrieves the value of the leaf OriginProtocol from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginProtocol is set, it can
// safely use t.GetOriginProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetOriginProtocol() E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	if t == nil || t.OriginProtocol == 0 {
		return 0
	}
	return t.OriginProtocol
}

// GetPopTopLabel retrieves the value of the leaf PopTopLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PopTopLabel is set, it can
// safely use t.GetPopTopLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PopTopLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPopTopLabel() bool {
	if t == nil || t.PopTopLabel == nil {
		return false
	}
	return *t.PopTopLabel
}

// GetProgrammedIndex retrieves the value of the leaf ProgrammedIndex from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedIndex is set, it can
// safely use t.GetProgrammedIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedIndex == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetProgrammedIndex() uint64 {
	if t == nil || t.ProgrammedIndex == nil {
		return 0
	}
	return *t.ProgrammedIndex
}

// GetPushedMplsLabelStack retrieves the value of the leaf PushedMplsLabelStack from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PushedMplsLabelStack is set, it can
// safely use t.GetPushedMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PushedMplsLabelStack == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetPushedMplsLabelStack() []NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union {
	if t == nil || t.PushedMplsLabelStack == nil {
		return nil
	}
	return t.PushedMplsLabelStack
}

// GetTunnelSrcIpAddress retrieves the value of the leaf TunnelSrcIpAddress from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelSrcIpAddress is set, it can
// safely use t.GetTunnelSrcIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelSrcIpAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetTunnelSrcIpAddress() string {
	if t == nil || t.TunnelSrcIpAddress == nil {
		return ""
	}
	return *t.TunnelSrcIpAddress
}

// GetVniLabel retrieves the value of the leaf VniLabel from the NetworkInstance_Afts_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniLabel is set, it can
// safely use t.GetVniLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop) GetVniLabel() uint32 {
	if t == nil || t.VniLabel == nil {
		return 0
	}
	return *t.VniLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PopTopLabel == nil {
		var v bool = false
		t.PopTopLabel = &v
	}
	t.Counters.PopulateDefaults()
	t.InterfaceRef.PopulateDefaults()
	t.IpInIp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop.
func (*NetworkInstance_Afts_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group YANG schema element.
type NetworkInstance_Afts_NextHopGroup struct {
	ΛMetadata           []ygot.Annotation                                       `path:"@" ygotAnnotation:"true"`
	BackupNextHopGroup  *uint64                                                 `path:"state/backup-next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛBackupNextHopGroup []ygot.Annotation                                       `path:"state/@backup-next-hop-group" ygotAnnotation:"true"`
	Color               *uint64                                                 `path:"state/color" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛColor              []ygot.Annotation                                       `path:"state/@color" ygotAnnotation:"true"`
	Condition           map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition `path:"conditional/condition" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCondition          []ygot.Annotation                                       `path:"conditional/@condition" ygotAnnotation:"true"`
	Id                  *uint64                                                 `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId                 []ygot.Annotation                                       `path:"state/@id|@id" ygotAnnotation:"true"`
	NextHop             map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop   `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop            []ygot.Annotation                                       `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	NextHopGroupName    *string                                                 `path:"state/next-hop-group-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroupName   []ygot.Annotation                                       `path:"state/@next-hop-group-name" ygotAnnotation:"true"`
	ProgrammedId        *uint64                                                 `path:"state/programmed-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛProgrammedId       []ygot.Annotation                                       `path:"state/@programmed-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup) IsYANGGoStruct() {}

// NewCondition creates a new entry in the Condition list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewCondition(Id uint64) (*NetworkInstance_Afts_NextHopGroup_Condition, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Condition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Condition", key)
	}

	t.Condition[key] = &NetworkInstance_Afts_NextHopGroup_Condition{
		Id: &Id,
	}

	return t.Condition[key], nil
}

// RenameCondition renames an entry in the list Condition within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameCondition(oldK, newK uint64) error {
	if _, ok := t.Condition[newK]; ok {
		return fmt.Errorf("key %v already exists in Condition", newK)
	}

	e, ok := t.Condition[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Condition", oldK)
	}
	e.Id = &newK

	t.Condition[newK] = e
	delete(t.Condition, oldK)
	return nil
}

// GetOrCreateCondition retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	key := Id

	if v, ok := t.Condition[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCondition(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCondition got unexpected error: %v", err))
	}
	return v
}

// GetCondition retrieves the value with the specified key from
// the Condition map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetCondition(Id uint64) *NetworkInstance_Afts_NextHopGroup_Condition {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Condition[key]; ok {
		return lm
	}
	return nil
}

// DeleteCondition deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteCondition(Id uint64) {
	key := Id

	delete(t.Condition, key)
}

// AppendCondition appends the supplied NetworkInstance_Afts_NextHopGroup_Condition struct to the
// list Condition of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendCondition(v *NetworkInstance_Afts_NextHopGroup_Condition) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Condition == nil {
		t.Condition = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_Condition)
	}

	if _, ok := t.Condition[key]; ok {
		return fmt.Errorf("duplicate key for list Condition %v", key)
	}

	t.Condition[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Afts_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup) NewNextHop(Index uint64) (*NetworkInstance_Afts_NextHopGroup_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Afts_NextHopGroup_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Afts_NextHopGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup) GetOrCreateNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Afts_NextHopGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHop(Index uint64) *NetworkInstance_Afts_NextHopGroup_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Afts_NextHopGroup_NextHop struct to the
// list NextHop of NetworkInstance_Afts_NextHopGroup. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup) AppendNextHop(v *NetworkInstance_Afts_NextHopGroup_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Afts_NextHopGroup_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetBackupNextHopGroup retrieves the value of the leaf BackupNextHopGroup from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackupNextHopGroup is set, it can
// safely use t.GetBackupNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackupNextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetBackupNextHopGroup() uint64 {
	if t == nil || t.BackupNextHopGroup == nil {
		return 0
	}
	return *t.BackupNextHopGroup
}

// GetColor retrieves the value of the leaf Color from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetColor() uint64 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroupName retrieves the value of the leaf NextHopGroupName from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupName is set, it can
// safely use t.GetNextHopGroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetNextHopGroupName() string {
	if t == nil || t.NextHopGroupName == nil {
		return ""
	}
	return *t.NextHopGroupName
}

// GetProgrammedId retrieves the value of the leaf ProgrammedId from the NetworkInstance_Afts_NextHopGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProgrammedId is set, it can
// safely use t.GetProgrammedId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProgrammedId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup) GetProgrammedId() uint64 {
	if t == nil || t.ProgrammedId == nil {
		return 0
	}
	return *t.ProgrammedId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Condition {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup.
func (*NetworkInstance_Afts_NextHopGroup) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition struct {
	ΛMetadata       []ygot.Annotation                                                      `path:"@" ygotAnnotation:"true"`
	Dscp            []uint8                                                                `path:"state/dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDscp           []ygot.Annotation                                                      `path:"state/@dscp" ygotAnnotation:"true"`
	Id              *uint64                                                                `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId             []ygot.Annotation                                                      `path:"state/@id|@id" ygotAnnotation:"true"`
	InputInterface  map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface `path:"input-interfaces/input-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInputInterface []ygot.Annotation                                                      `path:"input-interfaces/@input-interface" ygotAnnotation:"true"`
	NextHopGroup    *uint64                                                                `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup   []ygot.Annotation                                                      `path:"state/@next-hop-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition) IsYANGGoStruct() {}

// NewInputInterface creates a new entry in the InputInterface list of the
// NetworkInstance_Afts_NextHopGroup_Condition struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) NewInputInterface(Id string) (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InputInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InputInterface", key)
	}

	t.InputInterface[key] = &NetworkInstance_Afts_NextHopGroup_Condition_InputInterface{
		Id: &Id,
	}

	return t.InputInterface[key], nil
}

// RenameInputInterface renames an entry in the list InputInterface within
// the NetworkInstance_Afts_NextHopGroup_Condition struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) RenameInputInterface(oldK, newK string) error {
	if _, ok := t.InputInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in InputInterface", newK)
	}

	e, ok := t.InputInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InputInterface", oldK)
	}
	e.Id = &newK

	t.InputInterface[newK] = e
	delete(t.InputInterface, oldK)
	return nil
}

// GetOrCreateInputInterface retrieves the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetOrCreateInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	key := Id

	if v, ok := t.InputInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInputInterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInputInterface got unexpected error: %v", err))
	}
	return v
}

// GetInputInterface retrieves the value with the specified key from
// the InputInterface map field of NetworkInstance_Afts_NextHopGroup_Condition. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetInputInterface(Id string) *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.InputInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInputInterface deletes the value with the specified keys from
// the receiver NetworkInstance_Afts_NextHopGroup_Condition. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) DeleteInputInterface(Id string) {
	key := Id

	delete(t.InputInterface, key)
}

// AppendInputInterface appends the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct to the
// list InputInterface of NetworkInstance_Afts_NextHopGroup_Condition. If the key value(s) specified in
// the supplied NetworkInstance_Afts_NextHopGroup_Condition_InputInterface already exist in the list, an error is
// returned.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) AppendInputInterface(v *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InputInterface == nil {
		t.InputInterface = make(map[string]*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface)
	}

	if _, ok := t.InputInterface[key]; ok {
		return fmt.Errorf("duplicate key for list InputInterface %v", key)
	}

	t.InputInterface[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetDscp() []uint8 {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_NextHopGroup_Condition
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.InputInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition.
func (*NetworkInstance_Afts_NextHopGroup_Condition) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_Condition_InputInterface represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/conditional/condition/input-interfaces/input-interface YANG schema element.
type NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Id            *string           `path:"state/id|id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛId           []ygot.Annotation `path:"state/@id|@id" ygotAnnotation:"true"`
	Interface     *string           `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"state/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"state/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_Condition_InputInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_Condition_InputInterface struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_Condition_InputInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_Condition_InputInterface.
func (*NetworkInstance_Afts_NextHopGroup_Condition_InputInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHopGroup_NextHop represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hop-groups/next-hop-group/next-hops/next-hop YANG schema element.
type NetworkInstance_Afts_NextHopGroup_NextHop struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Index     *uint64           `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex    []ygot.Annotation `path:"state/@index|@index" ygotAnnotation:"true"`
	Weight    *uint64           `path:"state/weight" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛWeight   []ygot.Annotation `path:"state/@weight" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHopGroup_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetWeight retrieves the value of the leaf Weight from the NetworkInstance_Afts_NextHopGroup_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) GetWeight() uint64 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHopGroup_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHopGroup_NextHop.
func (*NetworkInstance_Afts_NextHopGroup_NextHop) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/counters YANG schema element.
type NetworkInstance_Afts_NextHop_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_NextHop_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_Counters.
func (*NetworkInstance_Afts_NextHop_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_InterfaceRef represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/interface-ref YANG schema element.
type NetworkInstance_Afts_NextHop_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"state/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"state/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"state/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"state/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Afts_NextHop_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_InterfaceRef.
func (*NetworkInstance_Afts_NextHop_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_NextHop_IpInIp represents the /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/ip-in-ip YANG schema element.
type NetworkInstance_Afts_NextHop_IpInIp struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	DstIp     *string           `path:"state/dst-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDstIp    []ygot.Annotation `path:"state/@dst-ip" ygotAnnotation:"true"`
	SrcIp     *string           `path:"state/src-ip" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSrcIp    []ygot.Annotation `path:"state/@src-ip" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_NextHop_IpInIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_NextHop_IpInIp) IsYANGGoStruct() {}

// GetDstIp retrieves the value of the leaf DstIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIp is set, it can
// safely use t.GetDstIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetDstIp() string {
	if t == nil || t.DstIp == nil {
		return ""
	}
	return *t.DstIp
}

// GetSrcIp retrieves the value of the leaf SrcIp from the NetworkInstance_Afts_NextHop_IpInIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIp is set, it can
// safely use t.GetSrcIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_NextHop_IpInIp) GetSrcIp() string {
	if t == nil || t.SrcIp == nil {
		return ""
	}
	return *t.SrcIp
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_NextHop_IpInIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_NextHop_IpInIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_NextHop_IpInIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_NextHop_IpInIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_NextHop_IpInIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_NextHop_IpInIp.
func (*NetworkInstance_Afts_NextHop_IpInIp) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry struct {
	ΛMetadata                    []ygot.Annotation                                           `path:"@" ygotAnnotation:"true"`
	Counters                     *NetworkInstance_Afts_PolicyForwardingEntry_Counters        `path:"state/counters" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛCounters                    []ygot.Annotation                                           `path:"state/@counters" ygotAnnotation:"true"`
	EntryMetadata                Binary                                                      `path:"state/entry-metadata" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntryMetadata               []ygot.Annotation                                           `path:"state/@entry-metadata" ygotAnnotation:"true"`
	Index                        *uint64                                                     `path:"state/index|index" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛIndex                       []ygot.Annotation                                           `path:"state/@index|@index" ygotAnnotation:"true"`
	IpDscp                       *uint8                                                      `path:"state/ip-dscp" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpDscp                      []ygot.Annotation                                           `path:"state/@ip-dscp" ygotAnnotation:"true"`
	IpPrefix                     *string                                                     `path:"state/ip-prefix" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpPrefix                    []ygot.Annotation                                           `path:"state/@ip-prefix" ygotAnnotation:"true"`
	IpProtocol                   NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union `path:"state/ip-protocol" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpProtocol                  []ygot.Annotation                                           `path:"state/@ip-protocol" ygotAnnotation:"true"`
	L4DstPort                    *uint16                                                     `path:"state/l4-dst-port" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL4DstPort                   []ygot.Annotation                                           `path:"state/@l4-dst-port" ygotAnnotation:"true"`
	L4SrcPort                    *uint16                                                     `path:"state/l4-src-port" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL4SrcPort                   []ygot.Annotation                                           `path:"state/@l4-src-port" ygotAnnotation:"true"`
	MacAddress                   *string                                                     `path:"state/mac-address" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacAddress                  []ygot.Annotation                                           `path:"state/@mac-address" ygotAnnotation:"true"`
	MplsLabel                    NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union  `path:"state/mpls-label" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMplsLabel                   []ygot.Annotation                                           `path:"state/@mpls-label" ygotAnnotation:"true"`
	MplsTc                       *uint8                                                      `path:"state/mpls-tc" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMplsTc                      []ygot.Annotation                                           `path:"state/@mpls-tc" ygotAnnotation:"true"`
	NextHopGroup                 *uint64                                                     `path:"state/next-hop-group" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroup                []ygot.Annotation                                           `path:"state/@next-hop-group" ygotAnnotation:"true"`
	NextHopGroupNetworkInstance  *string                                                     `path:"state/next-hop-group-network-instance" module:"openconfig-network-instance/openconfig-aft-network-instance"`
	ΛNextHopGroupNetworkInstance []ygot.Annotation                                           `path:"state/@next-hop-group-network-instance" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetOrCreateCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &NetworkInstance_Afts_PolicyForwardingEntry_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from NetworkInstance_Afts_PolicyForwardingEntry. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetCounters() *NetworkInstance_Afts_PolicyForwardingEntry_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetEntryMetadata retrieves the value of the leaf EntryMetadata from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryMetadata is set, it can
// safely use t.GetEntryMetadata() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryMetadata == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetEntryMetadata() Binary {
	if t == nil || t.EntryMetadata == nil {
		return nil
	}
	return t.EntryMetadata
}

// GetIndex retrieves the value of the leaf Index from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIndex() uint64 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpDscp retrieves the value of the leaf IpDscp from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpDscp is set, it can
// safely use t.GetIpDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpDscp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpDscp() uint8 {
	if t == nil || t.IpDscp == nil {
		return 0
	}
	return *t.IpDscp
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetIpProtocol retrieves the value of the leaf IpProtocol from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpProtocol is set, it can
// safely use t.GetIpProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpProtocol == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetIpProtocol() NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union {
	if t == nil || t.IpProtocol == nil {
		return nil
	}
	return t.IpProtocol
}

// GetL4DstPort retrieves the value of the leaf L4DstPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4DstPort is set, it can
// safely use t.GetL4DstPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4DstPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4DstPort() uint16 {
	if t == nil || t.L4DstPort == nil {
		return 0
	}
	return *t.L4DstPort
}

// GetL4SrcPort retrieves the value of the leaf L4SrcPort from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L4SrcPort is set, it can
// safely use t.GetL4SrcPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L4SrcPort == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetL4SrcPort() uint16 {
	if t == nil || t.L4SrcPort == nil {
		return 0
	}
	return *t.L4SrcPort
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMplsLabel retrieves the value of the leaf MplsLabel from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabel is set, it can
// safely use t.GetMplsLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabel == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsLabel() NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union {
	if t == nil || t.MplsLabel == nil {
		return nil
	}
	return t.MplsLabel
}

// GetMplsTc retrieves the value of the leaf MplsTc from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsTc is set, it can
// safely use t.GetMplsTc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsTc == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetMplsTc() uint8 {
	if t == nil || t.MplsTc == nil {
		return 0
	}
	return *t.MplsTc
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroup() uint64 {
	if t == nil || t.NextHopGroup == nil {
		return 0
	}
	return *t.NextHopGroup
}

// GetNextHopGroupNetworkInstance retrieves the value of the leaf NextHopGroupNetworkInstance from the NetworkInstance_Afts_PolicyForwardingEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroupNetworkInstance is set, it can
// safely use t.GetNextHopGroupNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroupNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) GetNextHopGroupNetworkInstance() string {
	if t == nil || t.NextHopGroupNetworkInstance == nil {
		return ""
	}
	return *t.NextHopGroupNetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_Afts_PolicyForwardingEntry struct, which is a YANG list entry.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry.
func (*NetworkInstance_Afts_PolicyForwardingEntry) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_PolicyForwardingEntry_Counters represents the /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/counters YANG schema element.
type NetworkInstance_Afts_PolicyForwardingEntry_Counters struct {
	ΛMetadata         []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	OctetsForwarded   *uint64           `path:"octets-forwarded" module:"openconfig-network-instance"`
	ΛOctetsForwarded  []ygot.Annotation `path:"@octets-forwarded" ygotAnnotation:"true"`
	PacketsForwarded  *uint64           `path:"packets-forwarded" module:"openconfig-network-instance"`
	ΛPacketsForwarded []ygot.Annotation `path:"@packets-forwarded" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_PolicyForwardingEntry_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) IsYANGGoStruct() {}

// GetOctetsForwarded retrieves the value of the leaf OctetsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsForwarded is set, it can
// safely use t.GetOctetsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetOctetsForwarded() uint64 {
	if t == nil || t.OctetsForwarded == nil {
		return 0
	}
	return *t.OctetsForwarded
}

// GetPacketsForwarded retrieves the value of the leaf PacketsForwarded from the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsForwarded is set, it can
// safely use t.GetPacketsForwarded() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsForwarded == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) GetPacketsForwarded() uint64 {
	if t == nil || t.PacketsForwarded == nil {
		return 0
	}
	return *t.PacketsForwarded
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_PolicyForwardingEntry_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_PolicyForwardingEntry_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_PolicyForwardingEntry_Counters.
func (*NetworkInstance_Afts_PolicyForwardingEntry_Counters) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Afts_StateSynced represents the /openconfig-network-instance/network-instances/network-instance/afts/state-synced YANG schema element.
type NetworkInstance_Afts_StateSynced struct {
	ΛMetadata    []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Ipv4Unicast  *bool             `path:"state/ipv4-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpv4Unicast []ygot.Annotation `path:"state/@ipv4-unicast" ygotAnnotation:"true"`
	Ipv6Unicast  *bool             `path:"state/ipv6-unicast" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpv6Unicast []ygot.Annotation `path:"state/@ipv6-unicast" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Afts_StateSynced implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Afts_StateSynced) IsYANGGoStruct() {}

// GetIpv4Unicast retrieves the value of the leaf Ipv4Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Unicast is set, it can
// safely use t.GetIpv4Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv4Unicast() bool {
	if t == nil || t.Ipv4Unicast == nil {
		return false
	}
	return *t.Ipv4Unicast
}

// GetIpv6Unicast retrieves the value of the leaf Ipv6Unicast from the NetworkInstance_Afts_StateSynced
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Unicast is set, it can
// safely use t.GetIpv6Unicast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Unicast == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Afts_StateSynced) GetIpv6Unicast() bool {
	if t == nil || t.Ipv6Unicast == nil {
		return false
	}
	return *t.Ipv6Unicast
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Afts_StateSynced
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Afts_StateSynced) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Ipv4Unicast == nil {
		var v bool = false
		t.Ipv4Unicast = &v
	}
	if t.Ipv6Unicast == nil {
		var v bool = false
		t.Ipv6Unicast = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Afts_StateSynced"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Afts_StateSynced) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Afts_StateSynced) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Afts_StateSynced.
func (*NetworkInstance_Afts_StateSynced) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point YANG schema element.
type NetworkInstance_ConnectionPoint struct {
	ΛMetadata          []ygot.Annotation                                    `path:"@" ygotAnnotation:"true"`
	ConnectionPointId  *string                                              `path:"config/connection-point-id|connection-point-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛConnectionPointId []ygot.Annotation                                    `path:"config/@connection-point-id|@connection-point-id" ygotAnnotation:"true"`
	Endpoint           map[string]*NetworkInstance_ConnectionPoint_Endpoint `path:"endpoints/endpoint" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEndpoint          []ygot.Annotation                                    `path:"endpoints/@endpoint" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint) IsYANGGoStruct() {}

// NewEndpoint creates a new entry in the Endpoint list of the
// NetworkInstance_ConnectionPoint struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint) NewEndpoint(EndpointId string) (*NetworkInstance_ConnectionPoint_Endpoint, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	key := EndpointId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Endpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Endpoint", key)
	}

	t.Endpoint[key] = &NetworkInstance_ConnectionPoint_Endpoint{
		EndpointId: &EndpointId,
	}

	return t.Endpoint[key], nil
}

// RenameEndpoint renames an entry in the list Endpoint within
// the NetworkInstance_ConnectionPoint struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint) RenameEndpoint(oldK, newK string) error {
	if _, ok := t.Endpoint[newK]; ok {
		return fmt.Errorf("key %v already exists in Endpoint", newK)
	}

	e, ok := t.Endpoint[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Endpoint", oldK)
	}
	e.EndpointId = &newK

	t.Endpoint[newK] = e
	delete(t.Endpoint, oldK)
	return nil
}

// GetOrCreateEndpoint retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint) GetOrCreateEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	key := EndpointId

	if v, ok := t.Endpoint[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpoint(EndpointId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpoint got unexpected error: %v", err))
	}
	return v
}

// GetEndpoint retrieves the value with the specified key from
// the Endpoint map field of NetworkInstance_ConnectionPoint. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint) GetEndpoint(EndpointId string) *NetworkInstance_ConnectionPoint_Endpoint {

	if t == nil {
		return nil
	}

	key := EndpointId

	if lm, ok := t.Endpoint[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpoint deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint) DeleteEndpoint(EndpointId string) {
	key := EndpointId

	delete(t.Endpoint, key)
}

// AppendEndpoint appends the supplied NetworkInstance_ConnectionPoint_Endpoint struct to the
// list Endpoint of NetworkInstance_ConnectionPoint. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint) AppendEndpoint(v *NetworkInstance_ConnectionPoint_Endpoint) error {
	if v.EndpointId == nil {
		return fmt.Errorf("invalid nil key received for EndpointId")
	}

	key := *v.EndpointId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Endpoint == nil {
		t.Endpoint = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint)
	}

	if _, ok := t.Endpoint[key]; ok {
		return fmt.Errorf("duplicate key for list Endpoint %v", key)
	}

	t.Endpoint[key] = v
	return nil
}

// GetConnectionPointId retrieves the value of the leaf ConnectionPointId from the NetworkInstance_ConnectionPoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConnectionPointId is set, it can
// safely use t.GetConnectionPointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConnectionPointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint) GetConnectionPointId() string {
	if t == nil || t.ConnectionPointId == nil {
		return ""
	}
	return *t.ConnectionPointId
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Endpoint {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ConnectionPointId == nil {
		return nil, fmt.Errorf("nil value for key ConnectionPointId")
	}

	return map[string]interface{}{
		"connection-point-id": *t.ConnectionPointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint.
func (*NetworkInstance_ConnectionPoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint struct {
	ΛMetadata   []ygot.Annotation                                `path:"@" ygotAnnotation:"true"`
	Active      *bool                                            `path:"state/active" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛActive     []ygot.Annotation                                `path:"state/@active" ygotAnnotation:"true"`
	EndpointId  *string                                          `path:"config/endpoint-id|endpoint-id" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛEndpointId []ygot.Annotation                                `path:"config/@endpoint-id|@endpoint-id" ygotAnnotation:"true"`
	Local       *NetworkInstance_ConnectionPoint_Endpoint_Local  `path:"local" module:"openconfig-network-instance"`
	ΛLocal      []ygot.Annotation                                `path:"@local" ygotAnnotation:"true"`
	Precedence  *uint16                                          `path:"config/precedence" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPrecedence []ygot.Annotation                                `path:"config/@precedence" ygotAnnotation:"true"`
	Remote      *NetworkInstance_ConnectionPoint_Endpoint_Remote `path:"remote" module:"openconfig-network-instance"`
	ΛRemote     []ygot.Annotation                                `path:"@remote" ygotAnnotation:"true"`
	Type        E_NetworkInstanceTypes_ENDPOINT_TYPE             `path:"config/type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛType       []ygot.Annotation                                `path:"config/@type" ygotAnnotation:"true"`
	Vxlan       *NetworkInstance_ConnectionPoint_Endpoint_Vxlan  `path:"vxlan" module:"openconfig-network-instance"`
	ΛVxlan      []ygot.Annotation                                `path:"@vxlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint) IsYANGGoStruct() {}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NetworkInstance_ConnectionPoint_Endpoint_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NetworkInstance_ConnectionPoint_Endpoint_Remote{}
	return t.Remote
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetOrCreateVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan{}
	return t.Vxlan
}

// GetLocal returns the value of the Local struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetLocal() *NetworkInstance_ConnectionPoint_Endpoint_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetRemote() *NetworkInstance_ConnectionPoint_Endpoint_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_ConnectionPoint_Endpoint. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetVxlan() *NetworkInstance_ConnectionPoint_Endpoint_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetActive retrieves the value of the leaf Active from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Active is set, it can
// safely use t.GetActive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Active == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetActive() bool {
	if t == nil || t.Active == nil {
		return false
	}
	return *t.Active
}

// GetEndpointId retrieves the value of the leaf EndpointId from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndpointId is set, it can
// safely use t.GetEndpointId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndpointId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetEndpointId() string {
	if t == nil || t.EndpointId == nil {
		return ""
	}
	return *t.EndpointId
}

// GetPrecedence retrieves the value of the leaf Precedence from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetPrecedence() uint16 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// GetType retrieves the value of the leaf Type from the NetworkInstance_ConnectionPoint_Endpoint
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint) GetType() E_NetworkInstanceTypes_ENDPOINT_TYPE {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Local.PopulateDefaults()
	t.Remote.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EndpointId == nil {
		return nil, fmt.Errorf("nil value for key EndpointId")
	}

	return map[string]interface{}{
		"endpoint-id": *t.EndpointId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint.
func (*NetworkInstance_ConnectionPoint_Endpoint) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Local represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/local YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Local struct {
	ΛMetadata             []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface             *string           `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface            []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	SiteId                *uint16           `path:"config/site-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSiteId               []ygot.Annotation `path:"config/@site-id" ygotAnnotation:"true"`
	SiteLabelBlockOffset  *uint16           `path:"config/site-label-block-offset" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSiteLabelBlockOffset []ygot.Annotation `path:"config/@site-label-block-offset" ygotAnnotation:"true"`
	SiteLabelBlockSize    *uint16           `path:"config/site-label-block-size" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSiteLabelBlockSize   []ygot.Annotation `path:"config/@site-label-block-size" ygotAnnotation:"true"`
	Subinterface          *uint32           `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface         []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetSiteLabelBlockOffset retrieves the value of the leaf SiteLabelBlockOffset from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockOffset is set, it can
// safely use t.GetSiteLabelBlockOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockOffset == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockOffset() uint16 {
	if t == nil || t.SiteLabelBlockOffset == nil {
		return 0
	}
	return *t.SiteLabelBlockOffset
}

// GetSiteLabelBlockSize retrieves the value of the leaf SiteLabelBlockSize from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteLabelBlockSize is set, it can
// safely use t.GetSiteLabelBlockSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteLabelBlockSize == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSiteLabelBlockSize() uint16 {
	if t == nil || t.SiteLabelBlockSize == nil {
		return 0
	}
	return *t.SiteLabelBlockSize
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_ConnectionPoint_Endpoint_Local
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Local
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Local.
func (*NetworkInstance_ConnectionPoint_Endpoint_Local) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Remote represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/remote YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Remote struct {
	ΛMetadata                 []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	RemoteSystem              *string           `path:"config/remote-system" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRemoteSystem             []ygot.Annotation `path:"config/@remote-system" ygotAnnotation:"true"`
	SiteId                    *uint16           `path:"config/site-id" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSiteId                   []ygot.Annotation `path:"config/@site-id" ygotAnnotation:"true"`
	VirtualCircuitIdentifier  *uint32           `path:"config/virtual-circuit-identifier" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVirtualCircuitIdentifier []ygot.Annotation `path:"config/@virtual-circuit-identifier" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) IsYANGGoStruct() {}

// GetRemoteSystem retrieves the value of the leaf RemoteSystem from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteSystem is set, it can
// safely use t.GetRemoteSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteSystem == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetRemoteSystem() string {
	if t == nil || t.RemoteSystem == nil {
		return ""
	}
	return *t.RemoteSystem
}

// GetSiteId retrieves the value of the leaf SiteId from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SiteId is set, it can
// safely use t.GetSiteId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SiteId == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetSiteId() uint16 {
	if t == nil || t.SiteId == nil {
		return 0
	}
	return *t.SiteId
}

// GetVirtualCircuitIdentifier retrieves the value of the leaf VirtualCircuitIdentifier from the NetworkInstance_ConnectionPoint_Endpoint_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualCircuitIdentifier is set, it can
// safely use t.GetVirtualCircuitIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualCircuitIdentifier == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) GetVirtualCircuitIdentifier() uint32 {
	if t == nil || t.VirtualCircuitIdentifier == nil {
		return 0
	}
	return *t.VirtualCircuitIdentifier
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Remote
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Remote.
func (*NetworkInstance_ConnectionPoint_Endpoint_Remote) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct {
	ΛMetadata        []ygot.Annotation                                                       `path:"@" ygotAnnotation:"true"`
	Description      *string                                                                 `path:"config/description" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDescription     []ygot.Annotation                                                       `path:"config/@description" ygotAnnotation:"true"`
	Enabled          *bool                                                                   `path:"config/enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnabled         []ygot.Annotation                                                       `path:"config/@enabled" ygotAnnotation:"true"`
	EndpointPeer     map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer `path:"endpoint-peers/endpoint-peer" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEndpointPeer    []ygot.Annotation                                                       `path:"endpoint-peers/@endpoint-peer" ygotAnnotation:"true"`
	EndpointVni      map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni  `path:"endpoint-vnis/endpoint-vni" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEndpointVni     []ygot.Annotation                                                       `path:"endpoint-vnis/@endpoint-vni" ygotAnnotation:"true"`
	SourceInterface  *string                                                                 `path:"config/source-interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSourceInterface []ygot.Annotation                                                       `path:"config/@source-interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) IsYANGGoStruct() {}

// NewEndpointPeer creates a new entry in the EndpointPeer list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointPeer(PeerAddress string) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	key := PeerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointPeer", key)
	}

	t.EndpointPeer[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer{
		PeerAddress: &PeerAddress,
	}

	return t.EndpointPeer[key], nil
}

// RenameEndpointPeer renames an entry in the list EndpointPeer within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointPeer(oldK, newK string) error {
	if _, ok := t.EndpointPeer[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointPeer", newK)
	}

	e, ok := t.EndpointPeer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointPeer", oldK)
	}
	e.PeerAddress = &newK

	t.EndpointPeer[newK] = e
	delete(t.EndpointPeer, oldK)
	return nil
}

// GetOrCreateEndpointPeer retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	key := PeerAddress

	if v, ok := t.EndpointPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointPeer(PeerAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointPeer got unexpected error: %v", err))
	}
	return v
}

// GetEndpointPeer retrieves the value with the specified key from
// the EndpointPeer map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointPeer(PeerAddress string) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer {

	if t == nil {
		return nil
	}

	key := PeerAddress

	if lm, ok := t.EndpointPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointPeer deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointPeer(PeerAddress string) {
	key := PeerAddress

	delete(t.EndpointPeer, key)
}

// AppendEndpointPeer appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct to the
// list EndpointPeer of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointPeer(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) error {
	if v.PeerAddress == nil {
		return fmt.Errorf("invalid nil key received for PeerAddress")
	}

	key := *v.PeerAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointPeer == nil {
		t.EndpointPeer = make(map[string]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer)
	}

	if _, ok := t.EndpointPeer[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointPeer %v", key)
	}

	t.EndpointPeer[key] = v
	return nil
}

// NewEndpointVni creates a new entry in the EndpointVni list of the
// NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) NewEndpointVni(Vni uint32) (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	key := Vni

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EndpointVni[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EndpointVni", key)
	}

	t.EndpointVni[key] = &NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni{
		Vni: &Vni,
	}

	return t.EndpointVni[key], nil
}

// RenameEndpointVni renames an entry in the list EndpointVni within
// the NetworkInstance_ConnectionPoint_Endpoint_Vxlan struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) RenameEndpointVni(oldK, newK uint32) error {
	if _, ok := t.EndpointVni[newK]; ok {
		return fmt.Errorf("key %v already exists in EndpointVni", newK)
	}

	e, ok := t.EndpointVni[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EndpointVni", oldK)
	}
	e.Vni = &newK

	t.EndpointVni[newK] = e
	delete(t.EndpointVni, oldK)
	return nil
}

// GetOrCreateEndpointVni retrieves the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetOrCreateEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	key := Vni

	if v, ok := t.EndpointVni[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEndpointVni(Vni)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEndpointVni got unexpected error: %v", err))
	}
	return v
}

// GetEndpointVni retrieves the value with the specified key from
// the EndpointVni map field of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEndpointVni(Vni uint32) *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni {

	if t == nil {
		return nil
	}

	key := Vni

	if lm, ok := t.EndpointVni[key]; ok {
		return lm
	}
	return nil
}

// DeleteEndpointVni deletes the value with the specified keys from
// the receiver NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) DeleteEndpointVni(Vni uint32) {
	key := Vni

	delete(t.EndpointVni, key)
}

// AppendEndpointVni appends the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct to the
// list EndpointVni of NetworkInstance_ConnectionPoint_Endpoint_Vxlan. If the key value(s) specified in
// the supplied NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni already exist in the list, an error is
// returned.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) AppendEndpointVni(v *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) error {
	if v.Vni == nil {
		return fmt.Errorf("invalid nil key received for Vni")
	}

	key := *v.Vni

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EndpointVni == nil {
		t.EndpointVni = make(map[uint32]*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni)
	}

	if _, ok := t.EndpointVni[key]; ok {
		return fmt.Errorf("duplicate key for list EndpointVni %v", key)
	}

	t.EndpointVni[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetSourceInterface retrieves the value of the leaf SourceInterface from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceInterface is set, it can
// safely use t.GetSourceInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceInterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) GetSourceInterface() string {
	if t == nil || t.SourceInterface == nil {
		return ""
	}
	return *t.SourceInterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EndpointPeer {
		e.PopulateDefaults()
	}
	for _, e := range t.EndpointVni {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-peers/endpoint-peer YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct {
	ΛMetadata         []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	ControlPlaneVnis  []uint32                 `path:"state/control-plane-vnis" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛControlPlaneVnis []ygot.Annotation        `path:"state/@control-plane-vnis" ygotAnnotation:"true"`
	PeerAddress       *string                  `path:"state/peer-address|peer-address" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛPeerAddress      []ygot.Annotation        `path:"state/@peer-address|@peer-address" ygotAnnotation:"true"`
	PeerState         E_EndpointPeer_PeerState `path:"state/peer-state" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛPeerState        []ygot.Annotation        `path:"state/@peer-state" ygotAnnotation:"true"`
	RouterMac         *string                  `path:"state/router-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRouterMac        []ygot.Annotation        `path:"state/@router-mac" ygotAnnotation:"true"`
	Uptime            *uint64                  `path:"state/uptime" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛUptime           []ygot.Annotation        `path:"state/@uptime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) IsYANGGoStruct() {}

// GetControlPlaneVnis retrieves the value of the leaf ControlPlaneVnis from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPlaneVnis is set, it can
// safely use t.GetControlPlaneVnis() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPlaneVnis == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetControlPlaneVnis() []uint32 {
	if t == nil || t.ControlPlaneVnis == nil {
		return nil
	}
	return t.ControlPlaneVnis
}

// GetPeerAddress retrieves the value of the leaf PeerAddress from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerAddress is set, it can
// safely use t.GetPeerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerAddress == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerAddress() string {
	if t == nil || t.PeerAddress == nil {
		return ""
	}
	return *t.PeerAddress
}

// GetPeerState retrieves the value of the leaf PeerState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerState is set, it can
// safely use t.GetPeerState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetPeerState() E_EndpointPeer_PeerState {
	if t == nil || t.PeerState == 0 {
		return 0
	}
	return t.PeerState
}

// GetRouterMac retrieves the value of the leaf RouterMac from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterMac is set, it can
// safely use t.GetRouterMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetRouterMac() string {
	if t == nil || t.RouterMac == nil {
		return ""
	}
	return *t.RouterMac
}

// GetUptime retrieves the value of the leaf Uptime from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uptime is set, it can
// safely use t.GetUptime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uptime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) GetUptime() uint64 {
	if t == nil || t.Uptime == nil {
		return 0
	}
	return *t.Uptime
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerAddress == nil {
		return nil, fmt.Errorf("nil value for key PeerAddress")
	}

	return map[string]interface{}{
		"peer-address": *t.PeerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointPeer) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni represents the /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni YANG schema element.
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct {
	ΛMetadata                []ygot.Annotation                                                                        `path:"@" ygotAnnotation:"true"`
	BridgeDomain             *uint32                                                                                  `path:"state/bridge-domain" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛBridgeDomain            []ygot.Annotation                                                                        `path:"state/@bridge-domain" ygotAnnotation:"true"`
	L3VrfName                *string                                                                                  `path:"state/l3-vrf-name" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛL3VrfName               []ygot.Annotation                                                                        `path:"state/@l3-vrf-name" ygotAnnotation:"true"`
	LearningMode             E_EvpnTypes_LearningMode                                                                 `path:"state/learning-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLearningMode            []ygot.Annotation                                                                        `path:"state/@learning-mode" ygotAnnotation:"true"`
	MultidestinationTraffic  NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union `path:"state/multidestination-traffic" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMultidestinationTraffic []ygot.Annotation                                                                        `path:"state/@multidestination-traffic" ygotAnnotation:"true"`
	SviState                 E_EndpointVni_SviState                                                                   `path:"state/svi-state" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSviState                []ygot.Annotation                                                                        `path:"state/@svi-state" ygotAnnotation:"true"`
	Vni                      *uint32                                                                                  `path:"state/vni|vni" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛVni                     []ygot.Annotation                                                                        `path:"state/@vni|@vni" ygotAnnotation:"true"`
	VniState                 E_EndpointVni_VniState                                                                   `path:"state/vni-state" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVniState                []ygot.Annotation                                                                        `path:"state/@vni-state" ygotAnnotation:"true"`
	VniType                  E_EndpointVni_VniType                                                                    `path:"state/vni-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVniType                 []ygot.Annotation                                                                        `path:"state/@vni-type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) IsYANGGoStruct() {}

// GetBridgeDomain retrieves the value of the leaf BridgeDomain from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BridgeDomain is set, it can
// safely use t.GetBridgeDomain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BridgeDomain == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetBridgeDomain() uint32 {
	if t == nil || t.BridgeDomain == nil {
		return 0
	}
	return *t.BridgeDomain
}

// GetL3VrfName retrieves the value of the leaf L3VrfName from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3VrfName is set, it can
// safely use t.GetL3VrfName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3VrfName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetL3VrfName() string {
	if t == nil || t.L3VrfName == nil {
		return ""
	}
	return *t.L3VrfName
}

// GetLearningMode retrieves the value of the leaf LearningMode from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearningMode is set, it can
// safely use t.GetLearningMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearningMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetLearningMode() E_EvpnTypes_LearningMode {
	if t == nil || t.LearningMode == 0 {
		return 0
	}
	return t.LearningMode
}

// GetMultidestinationTraffic retrieves the value of the leaf MultidestinationTraffic from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultidestinationTraffic is set, it can
// safely use t.GetMultidestinationTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultidestinationTraffic == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetMultidestinationTraffic() NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union {
	if t == nil || t.MultidestinationTraffic == nil {
		return nil
	}
	return t.MultidestinationTraffic
}

// GetSviState retrieves the value of the leaf SviState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SviState is set, it can
// safely use t.GetSviState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SviState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetSviState() E_EndpointVni_SviState {
	if t == nil || t.SviState == 0 {
		return 0
	}
	return t.SviState
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// GetVniState retrieves the value of the leaf VniState from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniState is set, it can
// safely use t.GetVniState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniState == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniState() E_EndpointVni_VniState {
	if t == nil || t.VniState == 0 {
		return 0
	}
	return t.VniState
}

// GetVniType retrieves the value of the leaf VniType from the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VniType is set, it can
// safely use t.GetVniType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VniType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) GetVniType() E_EndpointVni_VniType {
	if t == nil || t.VniType == 0 {
		return 0
	}
	return t.VniType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni struct, which is a YANG list entry.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Vni == nil {
		return nil, fmt.Errorf("nil value for key Vni")
	}

	return map[string]interface{}{
		"vni": *t.Vni,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni.
func (*NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Encapsulation represents the /openconfig-network-instance/network-instances/network-instance/encapsulation YANG schema element.
type NetworkInstance_Encapsulation struct {
	ΛMetadata            []ygot.Annotation                            `path:"@" ygotAnnotation:"true"`
	ControlWord          *bool                                        `path:"config/control-word" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛControlWord         []ygot.Annotation                            `path:"config/@control-word" ygotAnnotation:"true"`
	EncapsulationType    E_NetworkInstanceTypes_ENCAPSULATION         `path:"config/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEncapsulationType   []ygot.Annotation                            `path:"config/@encapsulation-type" ygotAnnotation:"true"`
	LabelAllocationMode  E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE `path:"config/label-allocation-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛLabelAllocationMode []ygot.Annotation                            `path:"config/@label-allocation-mode" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Encapsulation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Encapsulation) IsYANGGoStruct() {}

// GetControlWord retrieves the value of the leaf ControlWord from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWord is set, it can
// safely use t.GetControlWord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWord == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetControlWord() bool {
	if t == nil || t.ControlWord == nil {
		return false
	}
	return *t.ControlWord
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetLabelAllocationMode retrieves the value of the leaf LabelAllocationMode from the NetworkInstance_Encapsulation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelAllocationMode is set, it can
// safely use t.GetLabelAllocationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelAllocationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Encapsulation) GetLabelAllocationMode() E_NetworkInstanceTypes_LABEL_ALLOCATION_MODE {
	if t == nil || t.LabelAllocationMode == 0 {
		return 0
	}
	return t.LabelAllocationMode
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Encapsulation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Encapsulation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Encapsulation.
func (*NetworkInstance_Encapsulation) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn represents the /openconfig-network-instance/network-instances/network-instance/evpn YANG schema element.
type NetworkInstance_Evpn struct {
	ΛMetadata     []ygot.Annotation                             `path:"@" ygotAnnotation:"true"`
	EvpnInstance  map[string]*NetworkInstance_Evpn_EvpnInstance `path:"evpn-instances/evpn-instance" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEvpnInstance []ygot.Annotation                             `path:"evpn-instances/@evpn-instance" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn) IsYANGGoStruct() {}

// NewEvpnInstance creates a new entry in the EvpnInstance list of the
// NetworkInstance_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn) NewEvpnInstance(Evi string) (*NetworkInstance_Evpn_EvpnInstance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	key := Evi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EvpnInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EvpnInstance", key)
	}

	t.EvpnInstance[key] = &NetworkInstance_Evpn_EvpnInstance{
		Evi: &Evi,
	}

	return t.EvpnInstance[key], nil
}

// RenameEvpnInstance renames an entry in the list EvpnInstance within
// the NetworkInstance_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn) RenameEvpnInstance(oldK, newK string) error {
	if _, ok := t.EvpnInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in EvpnInstance", newK)
	}

	e, ok := t.EvpnInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EvpnInstance", oldK)
	}
	e.Evi = &newK

	t.EvpnInstance[newK] = e
	delete(t.EvpnInstance, oldK)
	return nil
}

// GetOrCreateEvpnInstance retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn) GetOrCreateEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	key := Evi

	if v, ok := t.EvpnInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvpnInstance(Evi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvpnInstance got unexpected error: %v", err))
	}
	return v
}

// GetEvpnInstance retrieves the value with the specified key from
// the EvpnInstance map field of NetworkInstance_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn) GetEvpnInstance(Evi string) *NetworkInstance_Evpn_EvpnInstance {

	if t == nil {
		return nil
	}

	key := Evi

	if lm, ok := t.EvpnInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvpnInstance deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn) DeleteEvpnInstance(Evi string) {
	key := Evi

	delete(t.EvpnInstance, key)
}

// AppendEvpnInstance appends the supplied NetworkInstance_Evpn_EvpnInstance struct to the
// list EvpnInstance of NetworkInstance_Evpn. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn) AppendEvpnInstance(v *NetworkInstance_Evpn_EvpnInstance) error {
	if v.Evi == nil {
		return fmt.Errorf("invalid nil key received for Evi")
	}

	key := *v.Evi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EvpnInstance == nil {
		t.EvpnInstance = make(map[string]*NetworkInstance_Evpn_EvpnInstance)
	}

	if _, ok := t.EvpnInstance[key]; ok {
		return fmt.Errorf("duplicate key for list EvpnInstance %v", key)
	}

	t.EvpnInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EvpnInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn.
func (*NetworkInstance_Evpn) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance YANG schema element.
type NetworkInstance_Evpn_EvpnInstance struct {
	ΛMetadata           []ygot.Annotation                                          `path:"@" ygotAnnotation:"true"`
	BComponent          map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent   `path:"pbb/b-component" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛBComponent         []ygot.Annotation                                          `path:"pbb/@b-component" ygotAnnotation:"true"`
	ControlWordEnabled  *bool                                                      `path:"config/control-word-enabled" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛControlWordEnabled []ygot.Annotation                                          `path:"config/@control-word-enabled" ygotAnnotation:"true"`
	EncapsulationType   E_NetworkInstanceTypes_ENCAPSULATION                       `path:"config/encapsulation-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEncapsulationType  []ygot.Annotation                                          `path:"config/@encapsulation-type" ygotAnnotation:"true"`
	Evi                 *string                                                    `path:"config/evi|evi" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛEvi                []ygot.Annotation                                          `path:"config/@evi|@evi" ygotAnnotation:"true"`
	ImportExportPolicy  *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy      `path:"import-export-policy" module:"openconfig-network-instance"`
	ΛImportExportPolicy []ygot.Annotation                                          `path:"@import-export-policy" ygotAnnotation:"true"`
	MulticastGroup      *string                                                    `path:"config/multicast-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMulticastGroup     []ygot.Annotation                                          `path:"config/@multicast-group" ygotAnnotation:"true"`
	MulticastMask       *string                                                    `path:"config/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMulticastMask      []ygot.Annotation                                          `path:"config/@multicast-mask" ygotAnnotation:"true"`
	ReplicationMode     E_EvpnInstance_ReplicationMode                             `path:"config/replication-mode" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛReplicationMode    []ygot.Annotation                                          `path:"config/@replication-mode" ygotAnnotation:"true"`
	RouteDistinguisher  NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union `path:"config/route-distinguisher" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛRouteDistinguisher []ygot.Annotation                                          `path:"config/@route-distinguisher" ygotAnnotation:"true"`
	ServiceType         E_EvpnTypes_EVPN_TYPE                                      `path:"config/service-type" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛServiceType        []ygot.Annotation                                          `path:"config/@service-type" ygotAnnotation:"true"`
	Vxlan               *NetworkInstance_Evpn_EvpnInstance_Vxlan                   `path:"vxlan" module:"openconfig-network-instance"`
	ΛVxlan              []ygot.Annotation                                          `path:"@vxlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance) IsYANGGoStruct() {}

// NewBComponent creates a new entry in the BComponent list of the
// NetworkInstance_Evpn_EvpnInstance struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance) NewBComponent(BComponentName string) (*NetworkInstance_Evpn_EvpnInstance_BComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	key := BComponentName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BComponent", key)
	}

	t.BComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent{
		BComponentName: &BComponentName,
	}

	return t.BComponent[key], nil
}

// RenameBComponent renames an entry in the list BComponent within
// the NetworkInstance_Evpn_EvpnInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance) RenameBComponent(oldK, newK string) error {
	if _, ok := t.BComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in BComponent", newK)
	}

	e, ok := t.BComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BComponent", oldK)
	}
	e.BComponentName = &newK

	t.BComponent[newK] = e
	delete(t.BComponent, oldK)
	return nil
}

// GetOrCreateBComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	key := BComponentName

	if v, ok := t.BComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBComponent(BComponentName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBComponent got unexpected error: %v", err))
	}
	return v
}

// GetBComponent retrieves the value with the specified key from
// the BComponent map field of NetworkInstance_Evpn_EvpnInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetBComponent(BComponentName string) *NetworkInstance_Evpn_EvpnInstance_BComponent {

	if t == nil {
		return nil
	}

	key := BComponentName

	if lm, ok := t.BComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteBComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance) DeleteBComponent(BComponentName string) {
	key := BComponentName

	delete(t.BComponent, key)
}

// AppendBComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent struct to the
// list BComponent of NetworkInstance_Evpn_EvpnInstance. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance) AppendBComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent) error {
	if v.BComponentName == nil {
		return fmt.Errorf("invalid nil key received for BComponentName")
	}

	key := *v.BComponentName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BComponent == nil {
		t.BComponent = make(map[string]*NetworkInstance_Evpn_EvpnInstance_BComponent)
	}

	if _, ok := t.BComponent[key]; ok {
		return fmt.Errorf("duplicate key for list BComponent %v", key)
	}

	t.BComponent[key] = v
	return nil
}

// GetOrCreateImportExportPolicy retrieves the value of the ImportExportPolicy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	t.ImportExportPolicy = &NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy{}
	return t.ImportExportPolicy
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance) GetOrCreateVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NetworkInstance_Evpn_EvpnInstance_Vxlan{}
	return t.Vxlan
}

// GetImportExportPolicy returns the value of the ImportExportPolicy struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field ImportExportPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetImportExportPolicy() *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy {
	if t != nil && t.ImportExportPolicy != nil {
		return t.ImportExportPolicy
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NetworkInstance_Evpn_EvpnInstance. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance) GetVxlan() *NetworkInstance_Evpn_EvpnInstance_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetControlWordEnabled retrieves the value of the leaf ControlWordEnabled from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlWordEnabled is set, it can
// safely use t.GetControlWordEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlWordEnabled == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetControlWordEnabled() bool {
	if t == nil || t.ControlWordEnabled == nil {
		return false
	}
	return *t.ControlWordEnabled
}

// GetEncapsulationType retrieves the value of the leaf EncapsulationType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulationType is set, it can
// safely use t.GetEncapsulationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulationType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEncapsulationType() E_NetworkInstanceTypes_ENCAPSULATION {
	if t == nil || t.EncapsulationType == 0 {
		return 0
	}
	return t.EncapsulationType
}

// GetEvi retrieves the value of the leaf Evi from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Evi is set, it can
// safely use t.GetEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Evi == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetEvi() string {
	if t == nil || t.Evi == nil {
		return ""
	}
	return *t.Evi
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetReplicationMode retrieves the value of the leaf ReplicationMode from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplicationMode is set, it can
// safely use t.GetReplicationMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplicationMode == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetReplicationMode() E_EvpnInstance_ReplicationMode {
	if t == nil || t.ReplicationMode == 0 {
		return 0
	}
	return t.ReplicationMode
}

// GetRouteDistinguisher retrieves the value of the leaf RouteDistinguisher from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteDistinguisher is set, it can
// safely use t.GetRouteDistinguisher() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteDistinguisher == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetRouteDistinguisher() NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union {
	if t == nil || t.RouteDistinguisher == nil {
		return nil
	}
	return t.RouteDistinguisher
}

// GetServiceType retrieves the value of the leaf ServiceType from the NetworkInstance_Evpn_EvpnInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServiceType is set, it can
// safely use t.GetServiceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServiceType == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance) GetServiceType() E_EvpnTypes_EVPN_TYPE {
	if t == nil || t.ServiceType == 0 {
		return 0
	}
	return t.ServiceType
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ImportExportPolicy.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
	for _, e := range t.BComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Evi == nil {
		return nil, fmt.Errorf("nil value for key Evi")
	}

	return map[string]interface{}{
		"evi": *t.Evi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance.
func (*NetworkInstance_Evpn_EvpnInstance) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent struct {
	ΛMetadata       []ygot.Annotation                                                   `path:"@" ygotAnnotation:"true"`
	BComponentName  *string                                                             `path:"config/b-component-name|b-component-name" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛBComponentName []ygot.Annotation                                                   `path:"config/@b-component-name|@b-component-name" ygotAnnotation:"true"`
	BackboneSrcMac  *string                                                             `path:"config/backbone-src-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛBackboneSrcMac []ygot.Annotation                                                   `path:"config/@backbone-src-mac" ygotAnnotation:"true"`
	IComponent      map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent `path:"i-components/i-component" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIComponent     []ygot.Annotation                                                   `path:"i-components/@i-component" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) IsYANGGoStruct() {}

// NewIComponent creates a new entry in the IComponent list of the
// NetworkInstance_Evpn_EvpnInstance_BComponent struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) NewIComponent(ISid uint32) (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	key := ISid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IComponent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IComponent", key)
	}

	t.IComponent[key] = &NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent{
		ISid: &ISid,
	}

	return t.IComponent[key], nil
}

// RenameIComponent renames an entry in the list IComponent within
// the NetworkInstance_Evpn_EvpnInstance_BComponent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) RenameIComponent(oldK, newK uint32) error {
	if _, ok := t.IComponent[newK]; ok {
		return fmt.Errorf("key %v already exists in IComponent", newK)
	}

	e, ok := t.IComponent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IComponent", oldK)
	}
	e.ISid = &newK

	t.IComponent[newK] = e
	delete(t.IComponent, oldK)
	return nil
}

// GetOrCreateIComponent retrieves the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetOrCreateIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	key := ISid

	if v, ok := t.IComponent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIComponent(ISid)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIComponent got unexpected error: %v", err))
	}
	return v
}

// GetIComponent retrieves the value with the specified key from
// the IComponent map field of NetworkInstance_Evpn_EvpnInstance_BComponent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetIComponent(ISid uint32) *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent {

	if t == nil {
		return nil
	}

	key := ISid

	if lm, ok := t.IComponent[key]; ok {
		return lm
	}
	return nil
}

// DeleteIComponent deletes the value with the specified keys from
// the receiver NetworkInstance_Evpn_EvpnInstance_BComponent. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) DeleteIComponent(ISid uint32) {
	key := ISid

	delete(t.IComponent, key)
}

// AppendIComponent appends the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct to the
// list IComponent of NetworkInstance_Evpn_EvpnInstance_BComponent. If the key value(s) specified in
// the supplied NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent already exist in the list, an error is
// returned.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) AppendIComponent(v *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) error {
	if v.ISid == nil {
		return fmt.Errorf("invalid nil key received for ISid")
	}

	key := *v.ISid

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IComponent == nil {
		t.IComponent = make(map[uint32]*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent)
	}

	if _, ok := t.IComponent[key]; ok {
		return fmt.Errorf("duplicate key for list IComponent %v", key)
	}

	t.IComponent[key] = v
	return nil
}

// GetBComponentName retrieves the value of the leaf BComponentName from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BComponentName is set, it can
// safely use t.GetBComponentName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BComponentName == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBComponentName() string {
	if t == nil || t.BComponentName == nil {
		return ""
	}
	return *t.BComponentName
}

// GetBackboneSrcMac retrieves the value of the leaf BackboneSrcMac from the NetworkInstance_Evpn_EvpnInstance_BComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BackboneSrcMac is set, it can
// safely use t.GetBackboneSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BackboneSrcMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) GetBackboneSrcMac() string {
	if t == nil || t.BackboneSrcMac == nil {
		return ""
	}
	return *t.BackboneSrcMac
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.IComponent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BComponentName == nil {
		return nil, fmt.Errorf("nil value for key BComponentName")
	}

	return map[string]interface{}{
		"b-component-name": *t.BComponentName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/pbb/b-component/i-components/i-component YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	ISid      *uint32           `path:"config/i-sid|i-sid" module:"openconfig-network-instance/openconfig-network-instance|openconfig-network-instance"`
	ΛISid     []ygot.Annotation `path:"config/@i-sid|@i-sid" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) IsYANGGoStruct() {}

// GetISid retrieves the value of the leaf ISid from the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ISid is set, it can
// safely use t.GetISid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ISid == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) GetISid() uint32 {
	if t == nil || t.ISid == nil {
		return 0
	}
	return *t.ISid
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent struct, which is a YANG list entry.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ISid == nil {
		return nil, fmt.Errorf("nil value for key ISid")
	}

	return map[string]interface{}{
		"i-sid": *t.ISid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent.
func (*NetworkInstance_Evpn_EvpnInstance_BComponent_IComponent) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy struct {
	ΛMetadata          []ygot.Annotation                                                              `path:"@" ygotAnnotation:"true"`
	ExportRouteTarget  []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union `path:"config/export-route-target" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛExportRouteTarget []ygot.Annotation                                                              `path:"config/@export-route-target" ygotAnnotation:"true"`
	ImportRouteTarget  []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union `path:"config/import-route-target" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛImportRouteTarget []ygot.Annotation                                                              `path:"config/@import-route-target" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) IsYANGGoStruct() {}

// GetExportRouteTarget retrieves the value of the leaf ExportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportRouteTarget is set, it can
// safely use t.GetExportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetExportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union {
	if t == nil || t.ExportRouteTarget == nil {
		return nil
	}
	return t.ExportRouteTarget
}

// GetImportRouteTarget retrieves the value of the leaf ImportRouteTarget from the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportRouteTarget is set, it can
// safely use t.GetImportRouteTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportRouteTarget == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) GetImportRouteTarget() []NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union {
	if t == nil || t.ImportRouteTarget == nil {
		return nil
	}
	return t.ImportRouteTarget
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy.
func (*NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan struct {
	ΛMetadata                       []ygot.Annotation                                               `path:"@" ygotAnnotation:"true"`
	AnycastSourceInterface          *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface `path:"anycast-source-interface" module:"openconfig-network-instance"`
	ΛAnycastSourceInterface         []ygot.Annotation                                               `path:"@anycast-source-interface" ygotAnnotation:"true"`
	HostReachabilityBgp             *bool                                                           `path:"config/host-reachability-bgp" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛHostReachabilityBgp            []ygot.Annotation                                               `path:"config/@host-reachability-bgp" ygotAnnotation:"true"`
	MulticastGroup                  *string                                                         `path:"config/multicast-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMulticastGroup                 []ygot.Annotation                                               `path:"config/@multicast-group" ygotAnnotation:"true"`
	MulticastMask                   *string                                                         `path:"config/multicast-mask" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMulticastMask                  []ygot.Annotation                                               `path:"config/@multicast-mask" ygotAnnotation:"true"`
	OverlayEndpoint                 *string                                                         `path:"config/overlay-endpoint" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOverlayEndpoint                []ygot.Annotation                                               `path:"config/@overlay-endpoint" ygotAnnotation:"true"`
	OverlayEndpointNetworkInstance  *string                                                         `path:"config/overlay-endpoint-network-instance" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛOverlayEndpointNetworkInstance []ygot.Annotation                                               `path:"config/@overlay-endpoint-network-instance" ygotAnnotation:"true"`
	Vni                             *uint32                                                         `path:"config/vni" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛVni                            []ygot.Annotation                                               `path:"config/@vni" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) IsYANGGoStruct() {}

// GetOrCreateAnycastSourceInterface retrieves the value of the AnycastSourceInterface field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOrCreateAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	t.AnycastSourceInterface = &NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface{}
	return t.AnycastSourceInterface
}

// GetAnycastSourceInterface returns the value of the AnycastSourceInterface struct pointer
// from NetworkInstance_Evpn_EvpnInstance_Vxlan. If the receiver or the field AnycastSourceInterface is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetAnycastSourceInterface() *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface {
	if t != nil && t.AnycastSourceInterface != nil {
		return t.AnycastSourceInterface
	}
	return nil
}

// GetHostReachabilityBgp retrieves the value of the leaf HostReachabilityBgp from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostReachabilityBgp is set, it can
// safely use t.GetHostReachabilityBgp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostReachabilityBgp == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetHostReachabilityBgp() bool {
	if t == nil || t.HostReachabilityBgp == nil {
		return false
	}
	return *t.HostReachabilityBgp
}

// GetMulticastGroup retrieves the value of the leaf MulticastGroup from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastGroup is set, it can
// safely use t.GetMulticastGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastGroup == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastGroup() string {
	if t == nil || t.MulticastGroup == nil {
		return ""
	}
	return *t.MulticastGroup
}

// GetMulticastMask retrieves the value of the leaf MulticastMask from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastMask is set, it can
// safely use t.GetMulticastMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastMask == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetMulticastMask() string {
	if t == nil || t.MulticastMask == nil {
		return ""
	}
	return *t.MulticastMask
}

// GetOverlayEndpoint retrieves the value of the leaf OverlayEndpoint from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpoint is set, it can
// safely use t.GetOverlayEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpoint == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpoint() string {
	if t == nil || t.OverlayEndpoint == nil {
		return ""
	}
	return *t.OverlayEndpoint
}

// GetOverlayEndpointNetworkInstance retrieves the value of the leaf OverlayEndpointNetworkInstance from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverlayEndpointNetworkInstance is set, it can
// safely use t.GetOverlayEndpointNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverlayEndpointNetworkInstance == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetOverlayEndpointNetworkInstance() string {
	if t == nil || t.OverlayEndpointNetworkInstance == nil {
		return ""
	}
	return *t.OverlayEndpointNetworkInstance
}

// GetVni retrieves the value of the leaf Vni from the NetworkInstance_Evpn_EvpnInstance_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AnycastSourceInterface.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface represents the /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/vxlan/anycast-source-interface YANG schema element.
type NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface.
func (*NetworkInstance_Evpn_EvpnInstance_Vxlan_AnycastSourceInterface) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb represents the /openconfig-network-instance/network-instances/network-instance/fdb YANG schema element.
type NetworkInstance_Fdb struct {
	ΛMetadata                      []ygot.Annotation                `path:"@" ygotAnnotation:"true"`
	AnycastGatewayMac              *string                          `path:"config/anycast-gateway-mac" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛAnycastGatewayMac             []ygot.Annotation                `path:"config/@anycast-gateway-mac" ygotAnnotation:"true"`
	ArpProxy                       *NetworkInstance_Fdb_ArpProxy    `path:"arp-proxy" module:"openconfig-network-instance"`
	ΛArpProxy                      []ygot.Annotation                `path:"@arp-proxy" ygotAnnotation:"true"`
	FloodUnknownUnicastSupression  *bool                            `path:"config/flood-unknown-unicast-supression" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛFloodUnknownUnicastSupression []ygot.Annotation                `path:"config/@flood-unknown-unicast-supression" ygotAnnotation:"true"`
	L2Rib                          *NetworkInstance_Fdb_L2Rib       `path:"l2rib" module:"openconfig-network-instance"`
	ΛL2Rib                         []ygot.Annotation                `path:"@l2rib" ygotAnnotation:"true"`
	MacAgingTime                   *uint16                          `path:"config/mac-aging-time" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacAgingTime                  []ygot.Annotation                `path:"config/@mac-aging-time" ygotAnnotation:"true"`
	MacLearning                    *bool                            `path:"config/mac-learning" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMacLearning                   []ygot.Annotation                `path:"config/@mac-learning" ygotAnnotation:"true"`
	MacMobility                    *NetworkInstance_Fdb_MacMobility `path:"mac-mobility" module:"openconfig-network-instance"`
	ΛMacMobility                   []ygot.Annotation                `path:"@mac-mobility" ygotAnnotation:"true"`
	MacTable                       *NetworkInstance_Fdb_MacTable    `path:"mac-table" module:"openconfig-network-instance"`
	ΛMacTable                      []ygot.Annotation                `path:"@mac-table" ygotAnnotation:"true"`
	MaximumEntries                 *uint16                          `path:"config/maximum-entries" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛMaximumEntries                []ygot.Annotation                `path:"config/@maximum-entries" ygotAnnotation:"true"`
	NdProxy                        *NetworkInstance_Fdb_NdProxy     `path:"nd-proxy" module:"openconfig-network-instance"`
	ΛNdProxy                       []ygot.Annotation                `path:"@nd-proxy" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb) IsYANGGoStruct() {}

// GetOrCreateArpProxy retrieves the value of the ArpProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t.ArpProxy != nil {
		return t.ArpProxy
	}
	t.ArpProxy = &NetworkInstance_Fdb_ArpProxy{}
	return t.ArpProxy
}

// GetOrCreateL2Rib retrieves the value of the L2Rib field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t.L2Rib != nil {
		return t.L2Rib
	}
	t.L2Rib = &NetworkInstance_Fdb_L2Rib{}
	return t.L2Rib
}

// GetOrCreateMacMobility retrieves the value of the MacMobility field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t.MacMobility != nil {
		return t.MacMobility
	}
	t.MacMobility = &NetworkInstance_Fdb_MacMobility{}
	return t.MacMobility
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateMacTable() *NetworkInstance_Fdb_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_MacTable{}
	return t.MacTable
}

// GetOrCreateNdProxy retrieves the value of the NdProxy field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb) GetOrCreateNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t.NdProxy != nil {
		return t.NdProxy
	}
	t.NdProxy = &NetworkInstance_Fdb_NdProxy{}
	return t.NdProxy
}

// GetArpProxy returns the value of the ArpProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field ArpProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetArpProxy() *NetworkInstance_Fdb_ArpProxy {
	if t != nil && t.ArpProxy != nil {
		return t.ArpProxy
	}
	return nil
}

// GetL2Rib returns the value of the L2Rib struct pointer
// from NetworkInstance_Fdb. If the receiver or the field L2Rib is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetL2Rib() *NetworkInstance_Fdb_L2Rib {
	if t != nil && t.L2Rib != nil {
		return t.L2Rib
	}
	return nil
}

// GetMacMobility returns the value of the MacMobility struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacMobility is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacMobility() *NetworkInstance_Fdb_MacMobility {
	if t != nil && t.MacMobility != nil {
		return t.MacMobility
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetMacTable() *NetworkInstance_Fdb_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// GetNdProxy returns the value of the NdProxy struct pointer
// from NetworkInstance_Fdb. If the receiver or the field NdProxy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb) GetNdProxy() *NetworkInstance_Fdb_NdProxy {
	if t != nil && t.NdProxy != nil {
		return t.NdProxy
	}
	return nil
}

// GetAnycastGatewayMac retrieves the value of the leaf AnycastGatewayMac from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGatewayMac is set, it can
// safely use t.GetAnycastGatewayMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGatewayMac == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetAnycastGatewayMac() string {
	if t == nil || t.AnycastGatewayMac == nil {
		return ""
	}
	return *t.AnycastGatewayMac
}

// GetFloodUnknownUnicastSupression retrieves the value of the leaf FloodUnknownUnicastSupression from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FloodUnknownUnicastSupression is set, it can
// safely use t.GetFloodUnknownUnicastSupression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FloodUnknownUnicastSupression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetFloodUnknownUnicastSupression() bool {
	if t == nil || t.FloodUnknownUnicastSupression == nil {
		return false
	}
	return *t.FloodUnknownUnicastSupression
}

// GetMacAgingTime retrieves the value of the leaf MacAgingTime from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAgingTime is set, it can
// safely use t.GetMacAgingTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAgingTime == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacAgingTime() uint16 {
	if t == nil || t.MacAgingTime == nil {
		return 0
	}
	return *t.MacAgingTime
}

// GetMacLearning retrieves the value of the leaf MacLearning from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacLearning is set, it can
// safely use t.GetMacLearning() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacLearning == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMacLearning() bool {
	if t == nil || t.MacLearning == nil {
		return false
	}
	return *t.MacLearning
}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the NetworkInstance_Fdb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb) GetMaximumEntries() uint16 {
	if t == nil || t.MaximumEntries == nil {
		return 0
	}
	return *t.MaximumEntries
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FloodUnknownUnicastSupression == nil {
		var v bool = false
		t.FloodUnknownUnicastSupression = &v
	}
	t.ArpProxy.PopulateDefaults()
	t.L2Rib.PopulateDefaults()
	t.MacMobility.PopulateDefaults()
	t.MacTable.PopulateDefaults()
	t.NdProxy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb.
func (*NetworkInstance_Fdb) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_ArpProxy represents the /openconfig-network-instance/network-instances/network-instance/fdb/arp-proxy YANG schema element.
type NetworkInstance_Fdb_ArpProxy struct {
	ΛMetadata                     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	ArpSuppression                *bool             `path:"config/arp-suppression" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛArpSuppression               []ygot.Annotation `path:"config/@arp-suppression" ygotAnnotation:"true"`
	DuplicateIpDetectionInterval  *uint16           `path:"config/duplicate-ip-detection-interval" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛDuplicateIpDetectionInterval []ygot.Annotation `path:"config/@duplicate-ip-detection-interval" ygotAnnotation:"true"`
	Enable                        *bool             `path:"config/enable" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEnable                       []ygot.Annotation `path:"config/@enable" ygotAnnotation:"true"`
	IpMobilityThreshold           *uint16           `path:"config/ip-mobility-threshold" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛIpMobilityThreshold          []ygot.Annotation `path:"config/@ip-mobility-threshold" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_ArpProxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_ArpProxy) IsYANGGoStruct() {}

// GetArpSuppression retrieves the value of the leaf ArpSuppression from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ArpSuppression is set, it can
// safely use t.GetArpSuppression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ArpSuppression == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetArpSuppression() bool {
	if t == nil || t.ArpSuppression == nil {
		return false
	}
	return *t.ArpSuppression
}

// GetDuplicateIpDetectionInterval retrieves the value of the leaf DuplicateIpDetectionInterval from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateIpDetectionInterval is set, it can
// safely use t.GetDuplicateIpDetectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateIpDetectionInterval == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetDuplicateIpDetectionInterval() uint16 {
	if t == nil || t.DuplicateIpDetectionInterval == nil {
		return 0
	}
	return *t.DuplicateIpDetectionInterval
}

// GetEnable retrieves the value of the leaf Enable from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return false
	}
	return *t.Enable
}

// GetIpMobilityThreshold retrieves the value of the leaf IpMobilityThreshold from the NetworkInstance_Fdb_ArpProxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMobilityThreshold is set, it can
// safely use t.GetIpMobilityThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMobilityThreshold == nil' before retrieving the leaf's value.
func (t *NetworkInstance_Fdb_ArpProxy) GetIpMobilityThreshold() uint16 {
	if t == nil || t.IpMobilityThreshold == nil {
		return 0
	}
	return *t.IpMobilityThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_ArpProxy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_ArpProxy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ArpSuppression == nil {
		var v bool = false
		t.ArpSuppression = &v
	}
	if t.Enable == nil {
		var v bool = false
		t.Enable = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_ArpProxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_ArpProxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_ArpProxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_ArpProxy.
func (*NetworkInstance_Fdb_ArpProxy) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib YANG schema element.
type NetworkInstance_Fdb_L2Rib struct {
	ΛMetadata   []ygot.Annotation                     `path:"@" ygotAnnotation:"true"`
	MacIpTable  *NetworkInstance_Fdb_L2Rib_MacIpTable `path:"mac-ip-table" module:"openconfig-network-instance"`
	ΛMacIpTable []ygot.Annotation                     `path:"@mac-ip-table" ygotAnnotation:"true"`
	MacTable    *NetworkInstance_Fdb_L2Rib_MacTable   `path:"mac-table" module:"openconfig-network-instance"`
	ΛMacTable   []ygot.Annotation                     `path:"@mac-table" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib) IsYANGGoStruct() {}

// GetOrCreateMacIpTable retrieves the value of the MacIpTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t.MacIpTable != nil {
		return t.MacIpTable
	}
	t.MacIpTable = &NetworkInstance_Fdb_L2Rib_MacIpTable{}
	return t.MacIpTable
}

// GetOrCreateMacTable retrieves the value of the MacTable field
// or returns the existing field if it already exists.
func (t *NetworkInstance_Fdb_L2Rib) GetOrCreateMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t.MacTable != nil {
		return t.MacTable
	}
	t.MacTable = &NetworkInstance_Fdb_L2Rib_MacTable{}
	return t.MacTable
}

// GetMacIpTable returns the value of the MacIpTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacIpTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacIpTable() *NetworkInstance_Fdb_L2Rib_MacIpTable {
	if t != nil && t.MacIpTable != nil {
		return t.MacIpTable
	}
	return nil
}

// GetMacTable returns the value of the MacTable struct pointer
// from NetworkInstance_Fdb_L2Rib. If the receiver or the field MacTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NetworkInstance_Fdb_L2Rib) GetMacTable() *NetworkInstance_Fdb_L2Rib_MacTable {
	if t != nil && t.MacTable != nil {
		return t.MacTable
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MacIpTable.PopulateDefaults()
	t.MacTable.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib.
func (*NetworkInstance_Fdb_L2Rib) ΛBelongingModule() string {
	return "openconfig-network-instance"
}

// NetworkInstance_Fdb_L2Rib_MacIpTable represents the /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table YANG schema element.
type NetworkInstance_Fdb_L2Rib_MacIpTable struct {
	ΛMetadata     []ygot.Annotation                                                                              `path:"@" ygotAnnotation:"true"`
	Entry         map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry `path:"entries/entry" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛEntry        []ygot.Annotation                                                                              `path:"entries/@entry" ygotAnnotation:"true"`
	NextHop       map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop                                       `path:"next-hops/next-hop" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHop      []ygot.Annotation                                                                              `path:"next-hops/@next-hop" ygotAnnotation:"true"`
	NextHopGroup  map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup                                  `path:"next-hop-groups/next-hop-group" module:"openconfig-network-instance/openconfig-network-instance"`
	ΛNextHopGroup []ygot.Annotation                                                                              `path:"next-hop-groups/@next-hop-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) IsYANGGoStruct() {}

// NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key represents the key for list Entry of element /openconfig-network-instance/network-instances/network-instance/fdb/l2rib/mac-ip-table.
type NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key struct {
	MacAddress string `path:"mac-address"`
	HostIp     string `path:"host-ip"`
}

// IsYANGGoKeyStruct ensures that NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key key struct.
func (t NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mac-address": t.MacAddress,
		"host-ip":     t.HostIp,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewEntry(MacAddress string, HostIp string) (*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_Entry{
		MacAddress: &MacAddress,
		HostIp:     &HostIp,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameEntry(oldK, newK NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.MacAddress = &newK.MacAddress
	e.HostIp = &newK.HostIp

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(MacAddress, HostIp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetEntry(MacAddress string, HostIp string) *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry {

	if t == nil {
		return nil
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteEntry(MacAddress string, HostIp string) {
	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: MacAddress,
		HostIp:     HostIp,
	}

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry struct to the
// list Entry of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_Entry already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendEntry(v *NetworkInstance_Fdb_L2Rib_MacIpTable_Entry) error {
	if v.MacAddress == nil {
		return fmt.Errorf("invalid nil key for MacAddress")
	}

	if v.HostIp == nil {
		return fmt.Errorf("invalid nil key for HostIp")
	}

	key := NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key{
		MacAddress: *v.MacAddress,
		HostIp:     *v.HostIp,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NetworkInstance_Fdb_L2Rib_MacIpTable_Entry_Key]*NetworkInstance_Fdb_L2Rib_MacIpTable_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHop(Index uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHop(oldK, newK uint64) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.Index = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	key := Index

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHop(Index uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop {

	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHop(Index uint64) {
	key := Index

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop struct to the
// list NextHop of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHop(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// NetworkInstance_Fdb_L2Rib_MacIpTable struct. The keys of the list are populated from the input
// arguments.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) NewNextHopGroup(Id uint64) (*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup{
		Id: &Id,
	}

	return t.NextHopGroup[key], nil
}

// RenameNextHopGroup renames an entry in the list NextHopGroup within
// the NetworkInstance_Fdb_L2Rib_MacIpTable struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) RenameNextHopGroup(oldK, newK uint64) error {
	if _, ok := t.NextHopGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHopGroup", newK)
	}

	e, ok := t.NextHopGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHopGroup", oldK)
	}
	e.Id = &newK

	t.NextHopGroup[newK] = e
	delete(t.NextHopGroup, oldK)
	return nil
}

// GetOrCreateNextHopGroup retrieves the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetOrCreateNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup {

	key := Id

	if v, ok := t.NextHopGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHopGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHopGroup got unexpected error: %v", err))
	}
	return v
}

// GetNextHopGroup retrieves the value with the specified key from
// the NextHopGroup map field of NetworkInstance_Fdb_L2Rib_MacIpTable. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) GetNextHopGroup(Id uint64) *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NextHopGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHopGroup deletes the value with the specified keys from
// the receiver NetworkInstance_Fdb_L2Rib_MacIpTable. If there is no such element, the function
// is a no-op.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) DeleteNextHopGroup(Id uint64) {
	key := Id

	delete(t.NextHopGroup, key)
}

// AppendNextHopGroup appends the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup struct to the
// list NextHopGroup of NetworkInstance_Fdb_L2Rib_MacIpTable. If the key value(s) specified in
// the supplied NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup already exist in the list, an error is
// returned.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) AppendNextHopGroup(v *NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*NetworkInstance_Fdb_L2Rib_MacIpTable_NextHopGroup)
	}

	if _, ok := t.NextHopGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NextHopGroup %v", key)
	}

	t.NextHopGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NetworkInstance_Fdb_L2Rib_MacIpTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHopGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NetworkInstance_Fdb_L2Rib_MacIpTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NetworkInstance_Fdb_L2Rib_MacIpTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NetworkInstance_Fdb_L2Rib_MacIpTable.
func (*NetworkInstance_Fdb_L2Rib_MacIpTable) ΛBelongingModule() string {
	return "openconfig-network-instance"
}
