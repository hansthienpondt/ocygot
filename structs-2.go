/*
Package ocygot is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.29.12/genutil/names.go
using the following YANG input files:
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/aft/openconfig-aft-network-instance.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/defined-sets/openconfig-defined-sets.yang
  - public/release/models/ethernet-segments/openconfig-ethernet-segments.yang
  - public/release/models/flex-algo/openconfig-flexalgo.yang
  - public/release/models/gribi/openconfig-gribi.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ethernet-ext.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/keychain/openconfig-keychain.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/macsec/openconfig-macsec.yang
  - public/release/models/mpls/openconfig-mpls.yang
  - public/release/models/multicast/openconfig-igmp.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/optical-transport/openconfig-optical-amplifier.yang
  - public/release/models/optical-transport/openconfig-terminal-device.yang
  - public/release/models/optical-transport/openconfig-transport-line-protection.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/ospf/openconfig-ospf-policy.yang
  - public/release/models/pcep/openconfig-pcep.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-routing-policy.yang
  - public/release/models/probes/openconfig-probes.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/relay-agent/openconfig-relay-agent.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/sampling/openconfig-sampling.yang
  - public/release/models/segment-routing/openconfig-segment-routing.yang
  - public/release/models/stp/openconfig-spanning-tree.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/telemetry/openconfig-telemetry.yang
  - public/release/models/vlan/openconfig-vlan.yang

Imported modules were sourced from:
  - public/...
*/
package ocygot

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Interface_RoutedVlan represents the /openconfig-interfaces/interfaces/interface/routed-vlan YANG schema element.
type Interface_RoutedVlan struct {
	ΛMetadata []ygot.Annotation               `path:"@" ygotAnnotation:"true"`
	Ipv4      *Interface_RoutedVlan_Ipv4      `path:"ipv4" module:"openconfig-if-ip"`
	ΛIpv4     []ygot.Annotation               `path:"@ipv4" ygotAnnotation:"true"`
	Ipv6      *Interface_RoutedVlan_Ipv6      `path:"ipv6" module:"openconfig-if-ip"`
	ΛIpv6     []ygot.Annotation               `path:"@ipv6" ygotAnnotation:"true"`
	Vlan      Interface_RoutedVlan_Vlan_Union `path:"config/vlan" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlan     []ygot.Annotation               `path:"config/@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv4() *Interface_RoutedVlan_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_RoutedVlan_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan) GetOrCreateIpv6() *Interface_RoutedVlan_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_RoutedVlan_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv4() *Interface_RoutedVlan_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_RoutedVlan. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan) GetIpv6() *Interface_RoutedVlan_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan retrieves the value of the leaf Vlan from the Interface_RoutedVlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan) GetVlan() Interface_RoutedVlan_Vlan_Union {
	if t == nil || t.Vlan == nil {
		return nil
	}
	return t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan.
func (*Interface_RoutedVlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_RoutedVlan_Ipv4 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4 YANG schema element.
type Interface_RoutedVlan_Ipv4 struct {
	ΛMetadata   []ygot.Annotation                              `path:"@" ygotAnnotation:"true"`
	Address     map[string]*Interface_RoutedVlan_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAddress    []ygot.Annotation                              `path:"addresses/@address" ygotAnnotation:"true"`
	Counters    *Interface_RoutedVlan_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCounters   []ygot.Annotation                              `path:"state/@counters" ygotAnnotation:"true"`
	DhcpClient  *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDhcpClient []ygot.Annotation                              `path:"config/@dhcp-client" ygotAnnotation:"true"`
	Enabled     *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled    []ygot.Annotation                              `path:"config/@enabled" ygotAnnotation:"true"`
	Mtu         *uint16                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMtu        []ygot.Annotation                              `path:"config/@mtu" ygotAnnotation:"true"`
	Neighbor    map[string]*Interface_RoutedVlan_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighbor   []ygot.Annotation                              `path:"neighbors/@neighbor" ygotAnnotation:"true"`
	ProxyArp    *Interface_RoutedVlan_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	ΛProxyArp   []ygot.Annotation                              `path:"@proxy-arp" ygotAnnotation:"true"`
	Unnumbered  *Interface_RoutedVlan_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
	ΛUnnumbered []ygot.Annotation                              `path:"@unnumbered" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetAddress(Ip string) *Interface_RoutedVlan_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv4_Address struct to the
// list Address of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendAddress(v *Interface_RoutedVlan_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv4_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv4. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4) AppendNeighbor(v *Interface_RoutedVlan_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_RoutedVlan_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetCounters() *Interface_RoutedVlan_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetProxyArp() *Interface_RoutedVlan_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4) GetUnnumbered() *Interface_RoutedVlan_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	t.ProxyArp.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4.
func (*Interface_RoutedVlan_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv4_Address struct {
	ΛMetadata     []ygot.Annotation                                      `path:"@" ygotAnnotation:"true"`
	Ip            *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp           []ygot.Annotation                                      `path:"config/@ip|@ip" ygotAnnotation:"true"`
	Origin        E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin       []ygot.Annotation                                      `path:"state/@origin" ygotAnnotation:"true"`
	PrefixLength  *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefixLength []ygot.Annotation                                      `path:"config/@prefix-length" ygotAnnotation:"true"`
	Type          E_IfIp_Ipv4AddressType                                 `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛType         []ygot.Annotation                                      `path:"config/@type" ygotAnnotation:"true"`
	VrrpGroup     map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVrrpGroup    []ygot.Annotation                                      `path:"vrrp/@vrrp-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv4_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetType retrieves the value of the leaf Type from the Interface_RoutedVlan_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address) GetType() E_IfIp_Ipv4AddressType {
	if t == nil || t.Type == 0 {
		return IfIp_Ipv4AddressType_PRIMARY
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = IfIp_Ipv4AddressType_PRIMARY
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address.
func (*Interface_RoutedVlan_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct {
	ΛMetadata              []ygot.Annotation                                              `path:"@" ygotAnnotation:"true"`
	AcceptMode             *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAcceptMode            []ygot.Annotation                                              `path:"config/@accept-mode" ygotAnnotation:"true"`
	AdvertisementInterval  *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAdvertisementInterval []ygot.Annotation                                              `path:"config/@advertisement-interval" ygotAnnotation:"true"`
	CurrentPriority        *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCurrentPriority       []ygot.Annotation                                              `path:"state/@current-priority" ygotAnnotation:"true"`
	InterfaceTracking      *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	ΛInterfaceTracking     []ygot.Annotation                                              `path:"@interface-tracking" ygotAnnotation:"true"`
	Preempt                *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreempt               []ygot.Annotation                                              `path:"config/@preempt" ygotAnnotation:"true"`
	PreemptDelay           *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreemptDelay          []ygot.Annotation                                              `path:"config/@preempt-delay" ygotAnnotation:"true"`
	Priority               *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriority              []ygot.Annotation                                              `path:"config/@priority" ygotAnnotation:"true"`
	VirtualAddress         []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualAddress        []ygot.Annotation                                              `path:"config/@virtual-address" ygotAnnotation:"true"`
	VirtualRouterId        *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛVirtualRouterId       []ygot.Annotation                                              `path:"config/@virtual-router-id|@virtual-router-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	ΛMetadata          []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	PriorityDecrement  *uint8            `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriorityDecrement []ygot.Annotation `path:"config/@priority-decrement" ygotAnnotation:"true"`
	TrackInterface     []string          `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛTrackInterface    []ygot.Annotation `path:"config/@track-interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv4_Counters struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InDiscardedPkts     *uint64           `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	ΛInDiscardedPkts    []ygot.Annotation `path:"@in-discarded-pkts" ygotAnnotation:"true"`
	InErrorPkts         *uint64           `path:"in-error-pkts" module:"openconfig-if-ip"`
	ΛInErrorPkts        []ygot.Annotation `path:"@in-error-pkts" ygotAnnotation:"true"`
	InForwardedOctets   *uint64           `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	ΛInForwardedOctets  []ygot.Annotation `path:"@in-forwarded-octets" ygotAnnotation:"true"`
	InForwardedPkts     *uint64           `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	ΛInForwardedPkts    []ygot.Annotation `path:"@in-forwarded-pkts" ygotAnnotation:"true"`
	InMulticastOctets   *uint64           `path:"in-multicast-octets" module:"openconfig-if-ip"`
	ΛInMulticastOctets  []ygot.Annotation `path:"@in-multicast-octets" ygotAnnotation:"true"`
	InMulticastPkts     *uint64           `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	ΛInMulticastPkts    []ygot.Annotation `path:"@in-multicast-pkts" ygotAnnotation:"true"`
	InOctets            *uint64           `path:"in-octets" module:"openconfig-if-ip"`
	ΛInOctets           []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts              *uint64           `path:"in-pkts" module:"openconfig-if-ip"`
	ΛInPkts             []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutDiscardedPkts    *uint64           `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	ΛOutDiscardedPkts   []ygot.Annotation `path:"@out-discarded-pkts" ygotAnnotation:"true"`
	OutErrorPkts        *uint64           `path:"out-error-pkts" module:"openconfig-if-ip"`
	ΛOutErrorPkts       []ygot.Annotation `path:"@out-error-pkts" ygotAnnotation:"true"`
	OutForwardedOctets  *uint64           `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	ΛOutForwardedOctets []ygot.Annotation `path:"@out-forwarded-octets" ygotAnnotation:"true"`
	OutForwardedPkts    *uint64           `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	ΛOutForwardedPkts   []ygot.Annotation `path:"@out-forwarded-pkts" ygotAnnotation:"true"`
	OutMulticastOctets  *uint64           `path:"out-multicast-octets" module:"openconfig-if-ip"`
	ΛOutMulticastOctets []ygot.Annotation `path:"@out-multicast-octets" ygotAnnotation:"true"`
	OutMulticastPkts    *uint64           `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	ΛOutMulticastPkts   []ygot.Annotation `path:"@out-multicast-pkts" ygotAnnotation:"true"`
	OutOctets           *uint64           `path:"out-octets" module:"openconfig-if-ip"`
	ΛOutOctets          []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts             *uint64           `path:"out-pkts" module:"openconfig-if-ip"`
	ΛOutPkts            []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Counters.
func (*Interface_RoutedVlan_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv4_Neighbor struct {
	ΛMetadata         []ygot.Annotation     `path:"@" ygotAnnotation:"true"`
	Ip                *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp               []ygot.Annotation     `path:"config/@ip|@ip" ygotAnnotation:"true"`
	LinkLayerAddress  *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLinkLayerAddress []ygot.Annotation     `path:"config/@link-layer-address" ygotAnnotation:"true"`
	Origin            E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin           []ygot.Annotation     `path:"state/@origin" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Neighbor.
func (*Interface_RoutedVlan_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/proxy-arp YANG schema element.
type Interface_RoutedVlan_Ipv4_ProxyArp struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Mode      E_ProxyArp_Mode   `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMode     []ygot.Annotation `path:"config/@mode" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_RoutedVlan_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) GetMode() E_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_ProxyArp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = ProxyArp_Mode_DISABLE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_ProxyArp.
func (*Interface_RoutedVlan_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered struct {
	ΛMetadata     []ygot.Annotation                                  `path:"@" ygotAnnotation:"true"`
	Enabled       *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled      []ygot.Annotation                                  `path:"config/@enabled" ygotAnnotation:"true"`
	InterfaceRef  *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
	ΛInterfaceRef []ygot.Annotation                                  `path:"@interface-ref" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered.
func (*Interface_RoutedVlan_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6 represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6 YANG schema element.
type Interface_RoutedVlan_Ipv6 struct {
	ΛMetadata               []ygot.Annotation                              `path:"@" ygotAnnotation:"true"`
	Address                 map[string]*Interface_RoutedVlan_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAddress                []ygot.Annotation                              `path:"addresses/@address" ygotAnnotation:"true"`
	Counters                *Interface_RoutedVlan_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCounters               []ygot.Annotation                              `path:"state/@counters" ygotAnnotation:"true"`
	DhcpClient              *bool                                          `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDhcpClient             []ygot.Annotation                              `path:"config/@dhcp-client" ygotAnnotation:"true"`
	DupAddrDetectTransmits  *uint32                                        `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDupAddrDetectTransmits []ygot.Annotation                              `path:"config/@dup-addr-detect-transmits" ygotAnnotation:"true"`
	Enabled                 *bool                                          `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled                []ygot.Annotation                              `path:"config/@enabled" ygotAnnotation:"true"`
	Mtu                     *uint32                                        `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMtu                    []ygot.Annotation                              `path:"config/@mtu" ygotAnnotation:"true"`
	Neighbor                map[string]*Interface_RoutedVlan_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighbor               []ygot.Annotation                              `path:"neighbors/@neighbor" ygotAnnotation:"true"`
	RouterAdvertisement     *Interface_RoutedVlan_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	ΛRouterAdvertisement    []ygot.Annotation                              `path:"@router-advertisement" ygotAnnotation:"true"`
	Unnumbered              *Interface_RoutedVlan_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
	ΛUnnumbered             []ygot.Annotation                              `path:"@unnumbered" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewAddress(Ip string) (*Interface_RoutedVlan_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_RoutedVlan_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetAddress(Ip string) *Interface_RoutedVlan_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_RoutedVlan_Ipv6_Address struct to the
// list Address of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendAddress(v *Interface_RoutedVlan_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_RoutedVlan_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_RoutedVlan_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6) NewNeighbor(Ip string) (*Interface_RoutedVlan_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_RoutedVlan_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_RoutedVlan_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_RoutedVlan_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetNeighbor(Ip string) *Interface_RoutedVlan_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_RoutedVlan_Ipv6_Neighbor struct to the
// list Neighbor of Interface_RoutedVlan_Ipv6. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6) AppendNeighbor(v *Interface_RoutedVlan_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_RoutedVlan_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_RoutedVlan_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_RoutedVlan_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6) GetOrCreateUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_RoutedVlan_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetCounters() *Interface_RoutedVlan_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetRouterAdvertisement() *Interface_RoutedVlan_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_RoutedVlan_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6) GetUnnumbered() *Interface_RoutedVlan_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_RoutedVlan_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.DupAddrDetectTransmits == nil {
		var v uint32 = 1
		t.DupAddrDetectTransmits = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6.
func (*Interface_RoutedVlan_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address YANG schema element.
type Interface_RoutedVlan_Ipv6_Address struct {
	ΛMetadata     []ygot.Annotation                                      `path:"@" ygotAnnotation:"true"`
	Ip            *string                                                `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp           []ygot.Annotation                                      `path:"config/@ip|@ip" ygotAnnotation:"true"`
	Origin        E_IfIp_IpAddressOrigin                                 `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin       []ygot.Annotation                                      `path:"state/@origin" ygotAnnotation:"true"`
	PrefixLength  *uint8                                                 `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefixLength []ygot.Annotation                                      `path:"config/@prefix-length" ygotAnnotation:"true"`
	Status        E_Address_Status                                       `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛStatus       []ygot.Annotation                                      `path:"state/@status" ygotAnnotation:"true"`
	Type          E_InetTypes_Ipv6AddressType                            `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛType         []ygot.Annotation                                      `path:"config/@type" ygotAnnotation:"true"`
	VrrpGroup     map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVrrpGroup    []ygot.Annotation                                      `path:"vrrp/@vrrp-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_RoutedVlan_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_RoutedVlan_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_RoutedVlan_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_RoutedVlan_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_RoutedVlan_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_Address) AppendVrrpGroup(v *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_RoutedVlan_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetStatus() E_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// GetType retrieves the value of the leaf Type from the Interface_RoutedVlan_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address) GetType() E_InetTypes_Ipv6AddressType {
	if t == nil || t.Type == 0 {
		return InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address.
func (*Interface_RoutedVlan_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct {
	ΛMetadata              []ygot.Annotation                                              `path:"@" ygotAnnotation:"true"`
	AcceptMode             *bool                                                          `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAcceptMode            []ygot.Annotation                                              `path:"config/@accept-mode" ygotAnnotation:"true"`
	AdvertisementInterval  *uint16                                                        `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAdvertisementInterval []ygot.Annotation                                              `path:"config/@advertisement-interval" ygotAnnotation:"true"`
	CurrentPriority        *uint8                                                         `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCurrentPriority       []ygot.Annotation                                              `path:"state/@current-priority" ygotAnnotation:"true"`
	InterfaceTracking      *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	ΛInterfaceTracking     []ygot.Annotation                                              `path:"@interface-tracking" ygotAnnotation:"true"`
	Preempt                *bool                                                          `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreempt               []ygot.Annotation                                              `path:"config/@preempt" ygotAnnotation:"true"`
	PreemptDelay           *uint16                                                        `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreemptDelay          []ygot.Annotation                                              `path:"config/@preempt-delay" ygotAnnotation:"true"`
	Priority               *uint8                                                         `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriority              []ygot.Annotation                                              `path:"config/@priority" ygotAnnotation:"true"`
	VirtualAddress         []string                                                       `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualAddress        []ygot.Annotation                                              `path:"config/@virtual-address" ygotAnnotation:"true"`
	VirtualLinkLocal       *string                                                        `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualLinkLocal      []ygot.Annotation                                              `path:"config/@virtual-link-local" ygotAnnotation:"true"`
	VirtualRouterId        *uint8                                                         `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛVirtualRouterId       []ygot.Annotation                                              `path:"config/@virtual-router-id|@virtual-router-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_RoutedVlan_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	ΛMetadata          []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	PriorityDecrement  *uint8            `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriorityDecrement []ygot.Annotation `path:"config/@priority-decrement" ygotAnnotation:"true"`
	TrackInterface     []string          `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛTrackInterface    []ygot.Annotation `path:"config/@track-interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_RoutedVlan_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/state/counters YANG schema element.
type Interface_RoutedVlan_Ipv6_Counters struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InDiscardedPkts     *uint64           `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	ΛInDiscardedPkts    []ygot.Annotation `path:"@in-discarded-pkts" ygotAnnotation:"true"`
	InErrorPkts         *uint64           `path:"in-error-pkts" module:"openconfig-if-ip"`
	ΛInErrorPkts        []ygot.Annotation `path:"@in-error-pkts" ygotAnnotation:"true"`
	InForwardedOctets   *uint64           `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	ΛInForwardedOctets  []ygot.Annotation `path:"@in-forwarded-octets" ygotAnnotation:"true"`
	InForwardedPkts     *uint64           `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	ΛInForwardedPkts    []ygot.Annotation `path:"@in-forwarded-pkts" ygotAnnotation:"true"`
	InMulticastOctets   *uint64           `path:"in-multicast-octets" module:"openconfig-if-ip"`
	ΛInMulticastOctets  []ygot.Annotation `path:"@in-multicast-octets" ygotAnnotation:"true"`
	InMulticastPkts     *uint64           `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	ΛInMulticastPkts    []ygot.Annotation `path:"@in-multicast-pkts" ygotAnnotation:"true"`
	InOctets            *uint64           `path:"in-octets" module:"openconfig-if-ip"`
	ΛInOctets           []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts              *uint64           `path:"in-pkts" module:"openconfig-if-ip"`
	ΛInPkts             []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutDiscardedPkts    *uint64           `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	ΛOutDiscardedPkts   []ygot.Annotation `path:"@out-discarded-pkts" ygotAnnotation:"true"`
	OutErrorPkts        *uint64           `path:"out-error-pkts" module:"openconfig-if-ip"`
	ΛOutErrorPkts       []ygot.Annotation `path:"@out-error-pkts" ygotAnnotation:"true"`
	OutForwardedOctets  *uint64           `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	ΛOutForwardedOctets []ygot.Annotation `path:"@out-forwarded-octets" ygotAnnotation:"true"`
	OutForwardedPkts    *uint64           `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	ΛOutForwardedPkts   []ygot.Annotation `path:"@out-forwarded-pkts" ygotAnnotation:"true"`
	OutMulticastOctets  *uint64           `path:"out-multicast-octets" module:"openconfig-if-ip"`
	ΛOutMulticastOctets []ygot.Annotation `path:"@out-multicast-octets" ygotAnnotation:"true"`
	OutMulticastPkts    *uint64           `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	ΛOutMulticastPkts   []ygot.Annotation `path:"@out-multicast-pkts" ygotAnnotation:"true"`
	OutOctets           *uint64           `path:"out-octets" module:"openconfig-if-ip"`
	ΛOutOctets          []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts             *uint64           `path:"out-pkts" module:"openconfig-if-ip"`
	ΛOutPkts            []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_RoutedVlan_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Counters.
func (*Interface_RoutedVlan_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/neighbors/neighbor YANG schema element.
type Interface_RoutedVlan_Ipv6_Neighbor struct {
	ΛMetadata         []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	Ip                *string                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp               []ygot.Annotation        `path:"config/@ip|@ip" ygotAnnotation:"true"`
	IsRouter          *bool                    `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛIsRouter         []ygot.Annotation        `path:"state/@is-router" ygotAnnotation:"true"`
	LinkLayerAddress  *string                  `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLinkLayerAddress []ygot.Annotation        `path:"config/@link-layer-address" ygotAnnotation:"true"`
	NeighborState     E_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighborState    []ygot.Annotation        `path:"state/@neighbor-state" ygotAnnotation:"true"`
	Origin            E_IfIp_NeighborOrigin    `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin           []ygot.Annotation        `path:"state/@origin" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetNeighborState() E_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_RoutedVlan_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Neighbor.
func (*Interface_RoutedVlan_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/router-advertisement YANG schema element.
type Interface_RoutedVlan_Ipv6_RouterAdvertisement struct {
	ΛMetadata    []ygot.Annotation                                                `path:"@" ygotAnnotation:"true"`
	Enable       *bool                                                            `path:"config/enable" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnable      []ygot.Annotation                                                `path:"config/@enable" ygotAnnotation:"true"`
	Interval     *uint32                                                          `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterval    []ygot.Annotation                                                `path:"config/@interval" ygotAnnotation:"true"`
	Lifetime     *uint32                                                          `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLifetime    []ygot.Annotation                                                `path:"config/@lifetime" ygotAnnotation:"true"`
	Managed      *bool                                                            `path:"config/managed" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛManaged     []ygot.Annotation                                                `path:"config/@managed" ygotAnnotation:"true"`
	Mode         E_RouterAdvertisement_Mode                                       `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMode        []ygot.Annotation                                                `path:"config/@mode" ygotAnnotation:"true"`
	OtherConfig  *bool                                                            `path:"config/other-config" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOtherConfig []ygot.Annotation                                                `path:"config/@other-config" ygotAnnotation:"true"`
	Prefix       map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix `path:"prefixes/prefix" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefix      []ygot.Annotation                                                `path:"prefixes/@prefix" ygotAnnotation:"true"`
	Suppress     *bool                                                            `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSuppress    []ygot.Annotation                                                `path:"config/@suppress" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// Interface_RoutedVlan_Ipv6_RouterAdvertisement struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) NewPrefix(Prefix string) (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the Interface_RoutedVlan_Ipv6_RouterAdvertisement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetOrCreatePrefix(Prefix string) *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetPrefix(Prefix string) *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver Interface_RoutedVlan_Ipv6_RouterAdvertisement. If there is no such element, the function
// is a no-op.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct to the
// list Prefix of Interface_RoutedVlan_Ipv6_RouterAdvertisement. If the key value(s) specified in
// the supplied Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix already exist in the list, an error is
// returned.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) AppendPrefix(v *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return true
	}
	return *t.Enable
}

// GetInterval retrieves the value of the leaf Interval from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetManaged retrieves the value of the leaf Managed from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Managed is set, it can
// safely use t.GetManaged() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Managed == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetManaged() bool {
	if t == nil || t.Managed == nil {
		return false
	}
	return *t.Managed
}

// GetMode retrieves the value of the leaf Mode from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetMode() E_RouterAdvertisement_Mode {
	if t == nil || t.Mode == 0 {
		return RouterAdvertisement_Mode_ALL
	}
	return t.Mode
}

// GetOtherConfig retrieves the value of the leaf OtherConfig from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfig is set, it can
// safely use t.GetOtherConfig() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfig == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetOtherConfig() bool {
	if t == nil || t.OtherConfig == nil {
		return false
	}
	return *t.OtherConfig
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = true
		t.Enable = &v
	}
	if t.Managed == nil {
		var v bool = false
		t.Managed = &v
	}
	if t.Mode == 0 {
		t.Mode = RouterAdvertisement_Mode_ALL
	}
	if t.OtherConfig == nil {
		var v bool = false
		t.OtherConfig = &v
	}
	if t.Suppress == nil {
		var v bool = false
		t.Suppress = &v
	}
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_RouterAdvertisement.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/router-advertisement/prefixes/prefix YANG schema element.
type Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct {
	ΛMetadata                 []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	DisableAdvertisement      *bool             `path:"config/disable-advertisement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDisableAdvertisement     []ygot.Annotation `path:"config/@disable-advertisement" ygotAnnotation:"true"`
	DisableAutoconfiguration  *bool             `path:"config/disable-autoconfiguration" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDisableAutoconfiguration []ygot.Annotation `path:"config/@disable-autoconfiguration" ygotAnnotation:"true"`
	EnableOnlink              *bool             `path:"config/enable-onlink" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnableOnlink             []ygot.Annotation `path:"config/@enable-onlink" ygotAnnotation:"true"`
	PreferredLifetime         *uint32           `path:"config/preferred-lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreferredLifetime        []ygot.Annotation `path:"config/@preferred-lifetime" ygotAnnotation:"true"`
	Prefix                    *string           `path:"config/prefix|prefix" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛPrefix                   []ygot.Annotation `path:"config/@prefix|@prefix" ygotAnnotation:"true"`
	ValidLifetime             *uint32           `path:"config/valid-lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛValidLifetime            []ygot.Annotation `path:"config/@valid-lifetime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) IsYANGGoStruct() {}

// GetDisableAdvertisement retrieves the value of the leaf DisableAdvertisement from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAdvertisement is set, it can
// safely use t.GetDisableAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAdvertisement == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetDisableAdvertisement() bool {
	if t == nil || t.DisableAdvertisement == nil {
		return false
	}
	return *t.DisableAdvertisement
}

// GetDisableAutoconfiguration retrieves the value of the leaf DisableAutoconfiguration from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAutoconfiguration is set, it can
// safely use t.GetDisableAutoconfiguration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAutoconfiguration == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetDisableAutoconfiguration() bool {
	if t == nil || t.DisableAutoconfiguration == nil {
		return false
	}
	return *t.DisableAutoconfiguration
}

// GetEnableOnlink retrieves the value of the leaf EnableOnlink from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableOnlink is set, it can
// safely use t.GetEnableOnlink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableOnlink == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetEnableOnlink() bool {
	if t == nil || t.EnableOnlink == nil {
		return false
	}
	return *t.EnableOnlink
}

// GetPreferredLifetime retrieves the value of the leaf PreferredLifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferredLifetime is set, it can
// safely use t.GetPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetPreferredLifetime() uint32 {
	if t == nil || t.PreferredLifetime == nil {
		return 0
	}
	return *t.PreferredLifetime
}

// GetPrefix retrieves the value of the leaf Prefix from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetValidLifetime retrieves the value of the leaf ValidLifetime from the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValidLifetime is set, it can
// safely use t.GetValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) GetValidLifetime() uint32 {
	if t == nil || t.ValidLifetime == nil {
		return 0
	}
	return *t.ValidLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix struct, which is a YANG list entry.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix.
func (*Interface_RoutedVlan_Ipv6_RouterAdvertisement_Prefix) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered struct {
	ΛMetadata     []ygot.Annotation                                  `path:"@" ygotAnnotation:"true"`
	Enabled       *bool                                              `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled      []ygot.Annotation                                  `path:"config/@enabled" ygotAnnotation:"true"`
	InterfaceRef  *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
	ΛInterfaceRef []ygot.Annotation                                  `path:"@interface-ref" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_RoutedVlan_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetInterfaceRef() *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_RoutedVlan_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered.
func (*Interface_RoutedVlan_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/routed-vlan/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_RoutedVlan_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Sonet represents the /openconfig-interfaces/interfaces/interface/sonet YANG schema element.
type Interface_Sonet struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Sonet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Sonet) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Sonet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Sonet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Sonet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Sonet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Sonet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Sonet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Sonet.
func (*Interface_Sonet) ΛBelongingModule() string {
	return "openconfig-transport-line-common"
}

// Interface_Subinterface represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface YANG schema element.
type Interface_Subinterface struct {
	ΛMetadata    []ygot.Annotation                `path:"@" ygotAnnotation:"true"`
	AdminStatus  E_Interface_AdminStatus          `path:"state/admin-status" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛAdminStatus []ygot.Annotation                `path:"state/@admin-status" ygotAnnotation:"true"`
	Counters     *Interface_Subinterface_Counters `path:"state/counters" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛCounters    []ygot.Annotation                `path:"state/@counters" ygotAnnotation:"true"`
	Cpu          *bool                            `path:"state/cpu" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛCpu         []ygot.Annotation                `path:"state/@cpu" ygotAnnotation:"true"`
	Description  *string                          `path:"config/description" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛDescription []ygot.Annotation                `path:"config/@description" ygotAnnotation:"true"`
	Enabled      *bool                            `path:"config/enabled" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛEnabled     []ygot.Annotation                `path:"config/@enabled" ygotAnnotation:"true"`
	Ifindex      *uint32                          `path:"state/ifindex" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛIfindex     []ygot.Annotation                `path:"state/@ifindex" ygotAnnotation:"true"`
	Index        *uint32                          `path:"config/index|index" module:"openconfig-interfaces/openconfig-interfaces|openconfig-interfaces"`
	ΛIndex       []ygot.Annotation                `path:"config/@index|@index" ygotAnnotation:"true"`
	Ipv4         *Interface_Subinterface_Ipv4     `path:"ipv4" module:"openconfig-if-ip"`
	ΛIpv4        []ygot.Annotation                `path:"@ipv4" ygotAnnotation:"true"`
	Ipv6         *Interface_Subinterface_Ipv6     `path:"ipv6" module:"openconfig-if-ip"`
	ΛIpv6        []ygot.Annotation                `path:"@ipv6" ygotAnnotation:"true"`
	LastChange   *uint64                          `path:"state/last-change" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛLastChange  []ygot.Annotation                `path:"state/@last-change" ygotAnnotation:"true"`
	Logical      *bool                            `path:"state/logical" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛLogical     []ygot.Annotation                `path:"state/@logical" ygotAnnotation:"true"`
	Management   *bool                            `path:"state/management" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛManagement  []ygot.Annotation                `path:"state/@management" ygotAnnotation:"true"`
	Name         *string                          `path:"state/name" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛName        []ygot.Annotation                `path:"state/@name" ygotAnnotation:"true"`
	OperStatus   E_Interface_OperStatus           `path:"state/oper-status" module:"openconfig-interfaces/openconfig-interfaces"`
	ΛOperStatus  []ygot.Annotation                `path:"state/@oper-status" ygotAnnotation:"true"`
	Vlan         *Interface_Subinterface_Vlan     `path:"vlan" module:"openconfig-vlan"`
	ΛVlan        []ygot.Annotation                `path:"@vlan" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateCounters() *Interface_Subinterface_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Counters{}
	return t.Counters
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv4() *Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateIpv6() *Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface) GetOrCreateVlan() *Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetCounters() *Interface_Subinterface_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv4() *Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetIpv6() *Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface) GetVlan() *Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetAdminStatus retrieves the value of the leaf AdminStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminStatus is set, it can
// safely use t.GetAdminStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetAdminStatus() E_Interface_AdminStatus {
	if t == nil || t.AdminStatus == 0 {
		return 0
	}
	return t.AdminStatus
}

// GetCpu retrieves the value of the leaf Cpu from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cpu is set, it can
// safely use t.GetCpu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cpu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetCpu() bool {
	if t == nil || t.Cpu == nil {
		return false
	}
	return *t.Cpu
}

// GetDescription retrieves the value of the leaf Description from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetIfindex retrieves the value of the leaf Ifindex from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ifindex is set, it can
// safely use t.GetIfindex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ifindex == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIfindex() uint32 {
	if t == nil || t.Ifindex == nil {
		return 0
	}
	return *t.Ifindex
}

// GetIndex retrieves the value of the leaf Index from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetLastChange retrieves the value of the leaf LastChange from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetLogical retrieves the value of the leaf Logical from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Logical is set, it can
// safely use t.GetLogical() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Logical == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetLogical() bool {
	if t == nil || t.Logical == nil {
		return false
	}
	return *t.Logical
}

// GetManagement retrieves the value of the leaf Management from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Management is set, it can
// safely use t.GetManagement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Management == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetManagement() bool {
	if t == nil || t.Management == nil {
		return false
	}
	return *t.Management
}

// GetName retrieves the value of the leaf Name from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface) GetOperStatus() E_Interface_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	if t.Index == nil {
		var v uint32 = 0
		t.Index = &v
	}
	t.Counters.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface struct, which is a YANG list entry.
func (t *Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface.
func (*Interface_Subinterface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/state/counters YANG schema element.
type Interface_Subinterface_Counters struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	CarrierTransitions  *uint64           `path:"carrier-transitions" module:"openconfig-interfaces"`
	ΛCarrierTransitions []ygot.Annotation `path:"@carrier-transitions" ygotAnnotation:"true"`
	InBroadcastPkts     *uint64           `path:"in-broadcast-pkts" module:"openconfig-interfaces"`
	ΛInBroadcastPkts    []ygot.Annotation `path:"@in-broadcast-pkts" ygotAnnotation:"true"`
	InDiscards          *uint64           `path:"in-discards" module:"openconfig-interfaces"`
	ΛInDiscards         []ygot.Annotation `path:"@in-discards" ygotAnnotation:"true"`
	InErrors            *uint64           `path:"in-errors" module:"openconfig-interfaces"`
	ΛInErrors           []ygot.Annotation `path:"@in-errors" ygotAnnotation:"true"`
	InFcsErrors         *uint64           `path:"in-fcs-errors" module:"openconfig-interfaces"`
	ΛInFcsErrors        []ygot.Annotation `path:"@in-fcs-errors" ygotAnnotation:"true"`
	InMulticastPkts     *uint64           `path:"in-multicast-pkts" module:"openconfig-interfaces"`
	ΛInMulticastPkts    []ygot.Annotation `path:"@in-multicast-pkts" ygotAnnotation:"true"`
	InOctets            *uint64           `path:"in-octets" module:"openconfig-interfaces"`
	ΛInOctets           []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts              *uint64           `path:"in-pkts" module:"openconfig-interfaces"`
	ΛInPkts             []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	InUnicastPkts       *uint64           `path:"in-unicast-pkts" module:"openconfig-interfaces"`
	ΛInUnicastPkts      []ygot.Annotation `path:"@in-unicast-pkts" ygotAnnotation:"true"`
	InUnknownProtos     *uint64           `path:"in-unknown-protos" module:"openconfig-interfaces"`
	ΛInUnknownProtos    []ygot.Annotation `path:"@in-unknown-protos" ygotAnnotation:"true"`
	LastClear           *uint64           `path:"last-clear" module:"openconfig-interfaces"`
	ΛLastClear          []ygot.Annotation `path:"@last-clear" ygotAnnotation:"true"`
	OutBroadcastPkts    *uint64           `path:"out-broadcast-pkts" module:"openconfig-interfaces"`
	ΛOutBroadcastPkts   []ygot.Annotation `path:"@out-broadcast-pkts" ygotAnnotation:"true"`
	OutDiscards         *uint64           `path:"out-discards" module:"openconfig-interfaces"`
	ΛOutDiscards        []ygot.Annotation `path:"@out-discards" ygotAnnotation:"true"`
	OutErrors           *uint64           `path:"out-errors" module:"openconfig-interfaces"`
	ΛOutErrors          []ygot.Annotation `path:"@out-errors" ygotAnnotation:"true"`
	OutMulticastPkts    *uint64           `path:"out-multicast-pkts" module:"openconfig-interfaces"`
	ΛOutMulticastPkts   []ygot.Annotation `path:"@out-multicast-pkts" ygotAnnotation:"true"`
	OutOctets           *uint64           `path:"out-octets" module:"openconfig-interfaces"`
	ΛOutOctets          []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts             *uint64           `path:"out-pkts" module:"openconfig-interfaces"`
	ΛOutPkts            []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
	OutUnicastPkts      *uint64           `path:"out-unicast-pkts" module:"openconfig-interfaces"`
	ΛOutUnicastPkts     []ygot.Annotation `path:"@out-unicast-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Counters) IsYANGGoStruct() {}

// GetCarrierTransitions retrieves the value of the leaf CarrierTransitions from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CarrierTransitions is set, it can
// safely use t.GetCarrierTransitions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CarrierTransitions == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetCarrierTransitions() uint64 {
	if t == nil || t.CarrierTransitions == nil {
		return 0
	}
	return *t.CarrierTransitions
}

// GetInBroadcastPkts retrieves the value of the leaf InBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBroadcastPkts is set, it can
// safely use t.GetInBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInBroadcastPkts() uint64 {
	if t == nil || t.InBroadcastPkts == nil {
		return 0
	}
	return *t.InBroadcastPkts
}

// GetInDiscards retrieves the value of the leaf InDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscards is set, it can
// safely use t.GetInDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInDiscards() uint64 {
	if t == nil || t.InDiscards == nil {
		return 0
	}
	return *t.InDiscards
}

// GetInErrors retrieves the value of the leaf InErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrors is set, it can
// safely use t.GetInErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInErrors() uint64 {
	if t == nil || t.InErrors == nil {
		return 0
	}
	return *t.InErrors
}

// GetInFcsErrors retrieves the value of the leaf InFcsErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFcsErrors is set, it can
// safely use t.GetInFcsErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFcsErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInFcsErrors() uint64 {
	if t == nil || t.InFcsErrors == nil {
		return 0
	}
	return *t.InFcsErrors
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetInUnicastPkts retrieves the value of the leaf InUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnicastPkts is set, it can
// safely use t.GetInUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnicastPkts() uint64 {
	if t == nil || t.InUnicastPkts == nil {
		return 0
	}
	return *t.InUnicastPkts
}

// GetInUnknownProtos retrieves the value of the leaf InUnknownProtos from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUnknownProtos is set, it can
// safely use t.GetInUnknownProtos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUnknownProtos == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetInUnknownProtos() uint64 {
	if t == nil || t.InUnknownProtos == nil {
		return 0
	}
	return *t.InUnknownProtos
}

// GetLastClear retrieves the value of the leaf LastClear from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastClear is set, it can
// safely use t.GetLastClear() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastClear == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetLastClear() uint64 {
	if t == nil || t.LastClear == nil {
		return 0
	}
	return *t.LastClear
}

// GetOutBroadcastPkts retrieves the value of the leaf OutBroadcastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBroadcastPkts is set, it can
// safely use t.GetOutBroadcastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBroadcastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutBroadcastPkts() uint64 {
	if t == nil || t.OutBroadcastPkts == nil {
		return 0
	}
	return *t.OutBroadcastPkts
}

// GetOutDiscards retrieves the value of the leaf OutDiscards from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscards is set, it can
// safely use t.GetOutDiscards() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscards == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutDiscards() uint64 {
	if t == nil || t.OutDiscards == nil {
		return 0
	}
	return *t.OutDiscards
}

// GetOutErrors retrieves the value of the leaf OutErrors from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrors is set, it can
// safely use t.GetOutErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrors == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutErrors() uint64 {
	if t == nil || t.OutErrors == nil {
		return 0
	}
	return *t.OutErrors
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// GetOutUnicastPkts retrieves the value of the leaf OutUnicastPkts from the Interface_Subinterface_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUnicastPkts is set, it can
// safely use t.GetOutUnicastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUnicastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Counters) GetOutUnicastPkts() uint64 {
	if t == nil || t.OutUnicastPkts == nil {
		return 0
	}
	return *t.OutUnicastPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Counters.
func (*Interface_Subinterface_Counters) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// Interface_Subinterface_Ipv4 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4 YANG schema element.
type Interface_Subinterface_Ipv4 struct {
	ΛMetadata   []ygot.Annotation                                `path:"@" ygotAnnotation:"true"`
	Address     map[string]*Interface_Subinterface_Ipv4_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAddress    []ygot.Annotation                                `path:"addresses/@address" ygotAnnotation:"true"`
	Counters    *Interface_Subinterface_Ipv4_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCounters   []ygot.Annotation                                `path:"state/@counters" ygotAnnotation:"true"`
	DhcpClient  *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDhcpClient []ygot.Annotation                                `path:"config/@dhcp-client" ygotAnnotation:"true"`
	Enabled     *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled    []ygot.Annotation                                `path:"config/@enabled" ygotAnnotation:"true"`
	Mtu         *uint16                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMtu        []ygot.Annotation                                `path:"config/@mtu" ygotAnnotation:"true"`
	Neighbor    map[string]*Interface_Subinterface_Ipv4_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighbor   []ygot.Annotation                                `path:"neighbors/@neighbor" ygotAnnotation:"true"`
	ProxyArp    *Interface_Subinterface_Ipv4_ProxyArp            `path:"proxy-arp" module:"openconfig-if-ip"`
	ΛProxyArp   []ygot.Annotation                                `path:"@proxy-arp" ygotAnnotation:"true"`
	Unnumbered  *Interface_Subinterface_Ipv4_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
	ΛUnnumbered []ygot.Annotation                                `path:"@unnumbered" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewAddress(Ip string) (*Interface_Subinterface_Ipv4_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv4_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetAddress(Ip string) *Interface_Subinterface_Ipv4_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv4_Address struct to the
// list Address of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendAddress(v *Interface_Subinterface_Ipv4_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv4_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv4_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4) GetNeighbor(Ip string) *Interface_Subinterface_Ipv4_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv4_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4) AppendNeighbor(v *Interface_Subinterface_Ipv4_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv4_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateCounters() *Interface_Subinterface_Ipv4_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv4_Counters{}
	return t.Counters
}

// GetOrCreateProxyArp retrieves the value of the ProxyArp field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t.ProxyArp != nil {
		return t.ProxyArp
	}
	t.ProxyArp = &Interface_Subinterface_Ipv4_ProxyArp{}
	return t.ProxyArp
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv4_Unnumbered{}
	return t.Unnumbered
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetCounters() *Interface_Subinterface_Ipv4_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetProxyArp returns the value of the ProxyArp struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field ProxyArp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetProxyArp() *Interface_Subinterface_Ipv4_ProxyArp {
	if t != nil && t.ProxyArp != nil {
		return t.ProxyArp
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv4. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4) GetUnnumbered() *Interface_Subinterface_Ipv4_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Counters.PopulateDefaults()
	t.ProxyArp.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4.
func (*Interface_Subinterface_Ipv4) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address YANG schema element.
type Interface_Subinterface_Ipv4_Address struct {
	ΛMetadata     []ygot.Annotation                                        `path:"@" ygotAnnotation:"true"`
	Ip            *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp           []ygot.Annotation                                        `path:"config/@ip|@ip" ygotAnnotation:"true"`
	Origin        E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin       []ygot.Annotation                                        `path:"state/@origin" ygotAnnotation:"true"`
	PrefixLength  *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefixLength []ygot.Annotation                                        `path:"config/@prefix-length" ygotAnnotation:"true"`
	Type          E_IfIp_Ipv4AddressType                                   `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛType         []ygot.Annotation                                        `path:"config/@type" ygotAnnotation:"true"`
	VrrpGroup     map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVrrpGroup    []ygot.Annotation                                        `path:"vrrp/@vrrp-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv4_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv4_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv4_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv4_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv4_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv4_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv4_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv4_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv4_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv4_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv4_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv4_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv4_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv4_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv4_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv4_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv4_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetType retrieves the value of the leaf Type from the Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address) GetType() E_IfIp_Ipv4AddressType {
	if t == nil || t.Type == 0 {
		return IfIp_Ipv4AddressType_PRIMARY
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = IfIp_Ipv4AddressType_PRIMARY
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address.
func (*Interface_Subinterface_Ipv4_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup struct {
	ΛMetadata              []ygot.Annotation                                                `path:"@" ygotAnnotation:"true"`
	AcceptMode             *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAcceptMode            []ygot.Annotation                                                `path:"config/@accept-mode" ygotAnnotation:"true"`
	AdvertisementInterval  *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAdvertisementInterval []ygot.Annotation                                                `path:"config/@advertisement-interval" ygotAnnotation:"true"`
	CurrentPriority        *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCurrentPriority       []ygot.Annotation                                                `path:"state/@current-priority" ygotAnnotation:"true"`
	InterfaceTracking      *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	ΛInterfaceTracking     []ygot.Annotation                                                `path:"@interface-tracking" ygotAnnotation:"true"`
	Preempt                *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreempt               []ygot.Annotation                                                `path:"config/@preempt" ygotAnnotation:"true"`
	PreemptDelay           *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreemptDelay          []ygot.Annotation                                                `path:"config/@preempt-delay" ygotAnnotation:"true"`
	Priority               *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriority              []ygot.Annotation                                                `path:"config/@priority" ygotAnnotation:"true"`
	VirtualAddress         []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualAddress        []ygot.Annotation                                                `path:"config/@virtual-address" ygotAnnotation:"true"`
	VirtualRouterId        *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛVirtualRouterId       []ygot.Annotation                                                `path:"config/@virtual-router-id|@virtual-router-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv4_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv4_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking struct {
	ΛMetadata          []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	PriorityDecrement  *uint8            `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriorityDecrement []ygot.Annotation `path:"config/@priority-decrement" ygotAnnotation:"true"`
	TrackInterface     []string          `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛTrackInterface    []ygot.Annotation `path:"config/@track-interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv4_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/state/counters YANG schema element.
type Interface_Subinterface_Ipv4_Counters struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InDiscardedPkts     *uint64           `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	ΛInDiscardedPkts    []ygot.Annotation `path:"@in-discarded-pkts" ygotAnnotation:"true"`
	InErrorPkts         *uint64           `path:"in-error-pkts" module:"openconfig-if-ip"`
	ΛInErrorPkts        []ygot.Annotation `path:"@in-error-pkts" ygotAnnotation:"true"`
	InForwardedOctets   *uint64           `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	ΛInForwardedOctets  []ygot.Annotation `path:"@in-forwarded-octets" ygotAnnotation:"true"`
	InForwardedPkts     *uint64           `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	ΛInForwardedPkts    []ygot.Annotation `path:"@in-forwarded-pkts" ygotAnnotation:"true"`
	InMulticastOctets   *uint64           `path:"in-multicast-octets" module:"openconfig-if-ip"`
	ΛInMulticastOctets  []ygot.Annotation `path:"@in-multicast-octets" ygotAnnotation:"true"`
	InMulticastPkts     *uint64           `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	ΛInMulticastPkts    []ygot.Annotation `path:"@in-multicast-pkts" ygotAnnotation:"true"`
	InOctets            *uint64           `path:"in-octets" module:"openconfig-if-ip"`
	ΛInOctets           []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts              *uint64           `path:"in-pkts" module:"openconfig-if-ip"`
	ΛInPkts             []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutDiscardedPkts    *uint64           `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	ΛOutDiscardedPkts   []ygot.Annotation `path:"@out-discarded-pkts" ygotAnnotation:"true"`
	OutErrorPkts        *uint64           `path:"out-error-pkts" module:"openconfig-if-ip"`
	ΛOutErrorPkts       []ygot.Annotation `path:"@out-error-pkts" ygotAnnotation:"true"`
	OutForwardedOctets  *uint64           `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	ΛOutForwardedOctets []ygot.Annotation `path:"@out-forwarded-octets" ygotAnnotation:"true"`
	OutForwardedPkts    *uint64           `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	ΛOutForwardedPkts   []ygot.Annotation `path:"@out-forwarded-pkts" ygotAnnotation:"true"`
	OutMulticastOctets  *uint64           `path:"out-multicast-octets" module:"openconfig-if-ip"`
	ΛOutMulticastOctets []ygot.Annotation `path:"@out-multicast-octets" ygotAnnotation:"true"`
	OutMulticastPkts    *uint64           `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	ΛOutMulticastPkts   []ygot.Annotation `path:"@out-multicast-pkts" ygotAnnotation:"true"`
	OutOctets           *uint64           `path:"out-octets" module:"openconfig-if-ip"`
	ΛOutOctets          []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts             *uint64           `path:"out-pkts" module:"openconfig-if-ip"`
	ΛOutPkts            []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv4_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Counters.
func (*Interface_Subinterface_Ipv4_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv4_Neighbor struct {
	ΛMetadata         []ygot.Annotation     `path:"@" ygotAnnotation:"true"`
	Ip                *string               `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp               []ygot.Annotation     `path:"config/@ip|@ip" ygotAnnotation:"true"`
	LinkLayerAddress  *string               `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLinkLayerAddress []ygot.Annotation     `path:"config/@link-layer-address" ygotAnnotation:"true"`
	Origin            E_IfIp_NeighborOrigin `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin           []ygot.Annotation     `path:"state/@origin" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv4_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv4_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Neighbor.
func (*Interface_Subinterface_Ipv4_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_ProxyArp represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/proxy-arp YANG schema element.
type Interface_Subinterface_Ipv4_ProxyArp struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Mode      E_ProxyArp_Mode   `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMode     []ygot.Annotation `path:"config/@mode" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_ProxyArp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_ProxyArp) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the Interface_Subinterface_Ipv4_ProxyArp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_ProxyArp) GetMode() E_ProxyArp_Mode {
	if t == nil || t.Mode == 0 {
		return ProxyArp_Mode_DISABLE
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_ProxyArp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_ProxyArp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = ProxyArp_Mode_DISABLE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_ProxyArp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_ProxyArp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_ProxyArp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_ProxyArp.
func (*Interface_Subinterface_Ipv4_ProxyArp) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered struct {
	ΛMetadata     []ygot.Annotation                                    `path:"@" ygotAnnotation:"true"`
	Enabled       *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled      []ygot.Annotation                                    `path:"config/@enabled" ygotAnnotation:"true"`
	InterfaceRef  *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
	ΛInterfaceRef []ygot.Annotation                                    `path:"@interface-ref" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv4_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv4_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered.
func (*Interface_Subinterface_Ipv4_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv4/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv4_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6 represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6 YANG schema element.
type Interface_Subinterface_Ipv6 struct {
	ΛMetadata               []ygot.Annotation                                `path:"@" ygotAnnotation:"true"`
	Address                 map[string]*Interface_Subinterface_Ipv6_Address  `path:"addresses/address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAddress                []ygot.Annotation                                `path:"addresses/@address" ygotAnnotation:"true"`
	Autoconf                *Interface_Subinterface_Ipv6_Autoconf            `path:"autoconf" module:"openconfig-if-ip-ext"`
	ΛAutoconf               []ygot.Annotation                                `path:"@autoconf" ygotAnnotation:"true"`
	Counters                *Interface_Subinterface_Ipv6_Counters            `path:"state/counters" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCounters               []ygot.Annotation                                `path:"state/@counters" ygotAnnotation:"true"`
	DhcpClient              *bool                                            `path:"config/dhcp-client" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDhcpClient             []ygot.Annotation                                `path:"config/@dhcp-client" ygotAnnotation:"true"`
	DupAddrDetectTransmits  *uint32                                          `path:"config/dup-addr-detect-transmits" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDupAddrDetectTransmits []ygot.Annotation                                `path:"config/@dup-addr-detect-transmits" ygotAnnotation:"true"`
	Enabled                 *bool                                            `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled                []ygot.Annotation                                `path:"config/@enabled" ygotAnnotation:"true"`
	Mtu                     *uint32                                          `path:"config/mtu" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMtu                    []ygot.Annotation                                `path:"config/@mtu" ygotAnnotation:"true"`
	Neighbor                map[string]*Interface_Subinterface_Ipv6_Neighbor `path:"neighbors/neighbor" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighbor               []ygot.Annotation                                `path:"neighbors/@neighbor" ygotAnnotation:"true"`
	RouterAdvertisement     *Interface_Subinterface_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"openconfig-if-ip"`
	ΛRouterAdvertisement    []ygot.Annotation                                `path:"@router-advertisement" ygotAnnotation:"true"`
	Unnumbered              *Interface_Subinterface_Ipv6_Unnumbered          `path:"unnumbered" module:"openconfig-if-ip"`
	ΛUnnumbered             []ygot.Annotation                                `path:"@unnumbered" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewAddress(Ip string) (*Interface_Subinterface_Ipv6_Address, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &Interface_Subinterface_Ipv6_Address{
		Ip: &Ip,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ip = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	key := Ip

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAddress(Ip string) *Interface_Subinterface_Ipv6_Address {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteAddress(Ip string) {
	key := Ip

	delete(t.Address, key)
}

// AppendAddress appends the supplied Interface_Subinterface_Ipv6_Address struct to the
// list Address of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendAddress(v *Interface_Subinterface_Ipv6_Address) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6) NewNeighbor(Ip string) (*Interface_Subinterface_Ipv6_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	key := Ip

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &Interface_Subinterface_Ipv6_Neighbor{
		Ip: &Ip,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ip = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6) GetOrCreateNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	key := Ip

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ip)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6) GetNeighbor(Ip string) *Interface_Subinterface_Ipv6_Neighbor {

	if t == nil {
		return nil
	}

	key := Ip

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6) DeleteNeighbor(Ip string) {
	key := Ip

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied Interface_Subinterface_Ipv6_Neighbor struct to the
// list Neighbor of Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Neighbor already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6) AppendNeighbor(v *Interface_Subinterface_Ipv6_Neighbor) error {
	if v.Ip == nil {
		return fmt.Errorf("invalid nil key received for Ip")
	}

	key := *v.Ip

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*Interface_Subinterface_Ipv6_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateAutoconf retrieves the value of the Autoconf field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t.Autoconf != nil {
		return t.Autoconf
	}
	t.Autoconf = &Interface_Subinterface_Ipv6_Autoconf{}
	return t.Autoconf
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateCounters() *Interface_Subinterface_Ipv6_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Interface_Subinterface_Ipv6_Counters{}
	return t.Counters
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetOrCreateUnnumbered retrieves the value of the Unnumbered field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6) GetOrCreateUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t.Unnumbered != nil {
		return t.Unnumbered
	}
	t.Unnumbered = &Interface_Subinterface_Ipv6_Unnumbered{}
	return t.Unnumbered
}

// GetAutoconf returns the value of the Autoconf struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Autoconf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetAutoconf() *Interface_Subinterface_Ipv6_Autoconf {
	if t != nil && t.Autoconf != nil {
		return t.Autoconf
	}
	return nil
}

// GetCounters returns the value of the Counters struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetCounters() *Interface_Subinterface_Ipv6_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetRouterAdvertisement() *Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// GetUnnumbered returns the value of the Unnumbered struct pointer
// from Interface_Subinterface_Ipv6. If the receiver or the field Unnumbered is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6) GetUnnumbered() *Interface_Subinterface_Ipv6_Unnumbered {
	if t != nil && t.Unnumbered != nil {
		return t.Unnumbered
	}
	return nil
}

// GetDhcpClient retrieves the value of the leaf DhcpClient from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhcpClient is set, it can
// safely use t.GetDhcpClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhcpClient == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDhcpClient() bool {
	if t == nil || t.DhcpClient == nil {
		return false
	}
	return *t.DhcpClient
}

// GetDupAddrDetectTransmits retrieves the value of the leaf DupAddrDetectTransmits from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DupAddrDetectTransmits is set, it can
// safely use t.GetDupAddrDetectTransmits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DupAddrDetectTransmits == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetDupAddrDetectTransmits() uint32 {
	if t == nil || t.DupAddrDetectTransmits == nil {
		return 1
	}
	return *t.DupAddrDetectTransmits
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// GetMtu retrieves the value of the leaf Mtu from the Interface_Subinterface_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhcpClient == nil {
		var v bool = false
		t.DhcpClient = &v
	}
	if t.DupAddrDetectTransmits == nil {
		var v uint32 = 1
		t.DupAddrDetectTransmits = &v
	}
	if t.Enabled == nil {
		var v bool = true
		t.Enabled = &v
	}
	t.Autoconf.PopulateDefaults()
	t.Counters.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	t.Unnumbered.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6.
func (*Interface_Subinterface_Ipv6) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address YANG schema element.
type Interface_Subinterface_Ipv6_Address struct {
	ΛMetadata     []ygot.Annotation                                        `path:"@" ygotAnnotation:"true"`
	Ip            *string                                                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp           []ygot.Annotation                                        `path:"config/@ip|@ip" ygotAnnotation:"true"`
	Origin        E_IfIp_IpAddressOrigin                                   `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin       []ygot.Annotation                                        `path:"state/@origin" ygotAnnotation:"true"`
	PrefixLength  *uint8                                                   `path:"config/prefix-length" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefixLength []ygot.Annotation                                        `path:"config/@prefix-length" ygotAnnotation:"true"`
	Status        E_Address_Status                                         `path:"state/status" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛStatus       []ygot.Annotation                                        `path:"state/@status" ygotAnnotation:"true"`
	Type          E_InetTypes_Ipv6AddressType                              `path:"config/type" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛType         []ygot.Annotation                                        `path:"config/@type" ygotAnnotation:"true"`
	VrrpGroup     map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup `path:"vrrp/vrrp-group" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVrrpGroup    []ygot.Annotation                                        `path:"vrrp/@vrrp-group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// Interface_Subinterface_Ipv6_Address struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_Address) NewVrrpGroup(VirtualRouterId uint8) (*Interface_Subinterface_Ipv6_Address_VrrpGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &Interface_Subinterface_Ipv6_Address_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the Interface_Subinterface_Ipv6_Address struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_Address) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_Address) GetOrCreateVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of Interface_Subinterface_Ipv6_Address. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_Address) GetVrrpGroup(VirtualRouterId uint8) *Interface_Subinterface_Ipv6_Address_VrrpGroup {

	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_Address. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_Address) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup struct to the
// list VrrpGroup of Interface_Subinterface_Ipv6_Address. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_Address_VrrpGroup already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_Address) AppendVrrpGroup(v *Interface_Subinterface_Ipv6_Address_VrrpGroup) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*Interface_Subinterface_Ipv6_Address_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetOrigin() E_IfIp_IpAddressOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetStatus retrieves the value of the leaf Status from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Status is set, it can
// safely use t.GetStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Status == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetStatus() E_Address_Status {
	if t == nil || t.Status == 0 {
		return 0
	}
	return t.Status
}

// GetType retrieves the value of the leaf Type from the Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address) GetType() E_InetTypes_Ipv6AddressType {
	if t == nil || t.Type == 0 {
		return InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = InetTypes_Ipv6AddressType_GLOBAL_UNICAST
	}
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address.
func (*Interface_Subinterface_Ipv6_Address) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup struct {
	ΛMetadata              []ygot.Annotation                                                `path:"@" ygotAnnotation:"true"`
	AcceptMode             *bool                                                            `path:"config/accept-mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAcceptMode            []ygot.Annotation                                                `path:"config/@accept-mode" ygotAnnotation:"true"`
	AdvertisementInterval  *uint16                                                          `path:"config/advertisement-interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛAdvertisementInterval []ygot.Annotation                                                `path:"config/@advertisement-interval" ygotAnnotation:"true"`
	CurrentPriority        *uint8                                                           `path:"state/current-priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛCurrentPriority       []ygot.Annotation                                                `path:"state/@current-priority" ygotAnnotation:"true"`
	InterfaceTracking      *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"openconfig-if-ip"`
	ΛInterfaceTracking     []ygot.Annotation                                                `path:"@interface-tracking" ygotAnnotation:"true"`
	Preempt                *bool                                                            `path:"config/preempt" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreempt               []ygot.Annotation                                                `path:"config/@preempt" ygotAnnotation:"true"`
	PreemptDelay           *uint16                                                          `path:"config/preempt-delay" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreemptDelay          []ygot.Annotation                                                `path:"config/@preempt-delay" ygotAnnotation:"true"`
	Priority               *uint8                                                           `path:"config/priority" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriority              []ygot.Annotation                                                `path:"config/@priority" ygotAnnotation:"true"`
	VirtualAddress         []string                                                         `path:"config/virtual-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualAddress        []ygot.Annotation                                                `path:"config/@virtual-address" ygotAnnotation:"true"`
	VirtualLinkLocal       *string                                                          `path:"config/virtual-link-local" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛVirtualLinkLocal      []ygot.Annotation                                                `path:"config/@virtual-link-local" ygotAnnotation:"true"`
	VirtualRouterId        *uint8                                                           `path:"config/virtual-router-id|virtual-router-id" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛVirtualRouterId       []ygot.Annotation                                                `path:"config/@virtual-router-id|@virtual-router-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetOrCreateInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from Interface_Subinterface_Ipv6_Address_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetInterfaceTracking() *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdvertisementInterval retrieves the value of the leaf AdvertisementInterval from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisementInterval is set, it can
// safely use t.GetAdvertisementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisementInterval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetAdvertisementInterval() uint16 {
	if t == nil || t.AdvertisementInterval == nil {
		return 100
	}
	return *t.AdvertisementInterval
}

// GetCurrentPriority retrieves the value of the leaf CurrentPriority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentPriority is set, it can
// safely use t.GetCurrentPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentPriority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetCurrentPriority() uint8 {
	if t == nil || t.CurrentPriority == nil {
		return 0
	}
	return *t.CurrentPriority
}

// GetPreempt retrieves the value of the leaf Preempt from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return true
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualLinkLocal retrieves the value of the leaf VirtualLinkLocal from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualLinkLocal is set, it can
// safely use t.GetVirtualLinkLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualLinkLocal == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualLinkLocal() string {
	if t == nil || t.VirtualLinkLocal == nil {
		return ""
	}
	return *t.VirtualLinkLocal
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the Interface_Subinterface_Ipv6_Address_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcceptMode == nil {
		var v bool = false
		t.AcceptMode = &v
	}
	if t.AdvertisementInterval == nil {
		var v uint16 = 100
		t.AdvertisementInterval = &v
	}
	if t.Preempt == nil {
		var v bool = true
		t.Preempt = &v
	}
	if t.PreemptDelay == nil {
		var v uint16 = 0
		t.PreemptDelay = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	t.InterfaceTracking.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Address_VrrpGroup struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking struct {
	ΛMetadata          []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	PriorityDecrement  *uint8            `path:"config/priority-decrement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPriorityDecrement []ygot.Annotation `path:"config/@priority-decrement" ygotAnnotation:"true"`
	TrackInterface     []string          `path:"config/track-interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛTrackInterface    []ygot.Annotation `path:"config/@track-interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// GetTrackInterface retrieves the value of the leaf TrackInterface from the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrackInterface is set, it can
// safely use t.GetTrackInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrackInterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) GetTrackInterface() []string {
	if t == nil || t.TrackInterface == nil {
		return nil
	}
	return t.TrackInterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PriorityDecrement == nil {
		var v uint8 = 0
		t.PriorityDecrement = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking.
func (*Interface_Subinterface_Ipv6_Address_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Autoconf represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/autoconf YANG schema element.
type Interface_Subinterface_Ipv6_Autoconf struct {
	ΛMetadata                   []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	CreateGlobalAddresses       *bool             `path:"config/create-global-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	ΛCreateGlobalAddresses      []ygot.Annotation `path:"config/@create-global-addresses" ygotAnnotation:"true"`
	CreateTemporaryAddresses    *bool             `path:"config/create-temporary-addresses" module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	ΛCreateTemporaryAddresses   []ygot.Annotation `path:"config/@create-temporary-addresses" ygotAnnotation:"true"`
	TemporaryPreferredLifetime  *uint32           `path:"config/temporary-preferred-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	ΛTemporaryPreferredLifetime []ygot.Annotation `path:"config/@temporary-preferred-lifetime" ygotAnnotation:"true"`
	TemporaryValidLifetime      *uint32           `path:"config/temporary-valid-lifetime" module:"openconfig-if-ip-ext/openconfig-if-ip-ext"`
	ΛTemporaryValidLifetime     []ygot.Annotation `path:"config/@temporary-valid-lifetime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Autoconf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Autoconf) IsYANGGoStruct() {}

// GetCreateGlobalAddresses retrieves the value of the leaf CreateGlobalAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateGlobalAddresses is set, it can
// safely use t.GetCreateGlobalAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateGlobalAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateGlobalAddresses() bool {
	if t == nil || t.CreateGlobalAddresses == nil {
		return true
	}
	return *t.CreateGlobalAddresses
}

// GetCreateTemporaryAddresses retrieves the value of the leaf CreateTemporaryAddresses from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CreateTemporaryAddresses is set, it can
// safely use t.GetCreateTemporaryAddresses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CreateTemporaryAddresses == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetCreateTemporaryAddresses() bool {
	if t == nil || t.CreateTemporaryAddresses == nil {
		return false
	}
	return *t.CreateTemporaryAddresses
}

// GetTemporaryPreferredLifetime retrieves the value of the leaf TemporaryPreferredLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryPreferredLifetime is set, it can
// safely use t.GetTemporaryPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryPreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryPreferredLifetime() uint32 {
	if t == nil || t.TemporaryPreferredLifetime == nil {
		return 86400
	}
	return *t.TemporaryPreferredLifetime
}

// GetTemporaryValidLifetime retrieves the value of the leaf TemporaryValidLifetime from the Interface_Subinterface_Ipv6_Autoconf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TemporaryValidLifetime is set, it can
// safely use t.GetTemporaryValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TemporaryValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Autoconf) GetTemporaryValidLifetime() uint32 {
	if t == nil || t.TemporaryValidLifetime == nil {
		return 604800
	}
	return *t.TemporaryValidLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Autoconf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Autoconf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CreateGlobalAddresses == nil {
		var v bool = true
		t.CreateGlobalAddresses = &v
	}
	if t.CreateTemporaryAddresses == nil {
		var v bool = false
		t.CreateTemporaryAddresses = &v
	}
	if t.TemporaryPreferredLifetime == nil {
		var v uint32 = 86400
		t.TemporaryPreferredLifetime = &v
	}
	if t.TemporaryValidLifetime == nil {
		var v uint32 = 604800
		t.TemporaryValidLifetime = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Autoconf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Autoconf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Autoconf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Autoconf.
func (*Interface_Subinterface_Ipv6_Autoconf) ΛBelongingModule() string {
	return "openconfig-if-ip-ext"
}

// Interface_Subinterface_Ipv6_Counters represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/state/counters YANG schema element.
type Interface_Subinterface_Ipv6_Counters struct {
	ΛMetadata           []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InDiscardedPkts     *uint64           `path:"in-discarded-pkts" module:"openconfig-if-ip"`
	ΛInDiscardedPkts    []ygot.Annotation `path:"@in-discarded-pkts" ygotAnnotation:"true"`
	InErrorPkts         *uint64           `path:"in-error-pkts" module:"openconfig-if-ip"`
	ΛInErrorPkts        []ygot.Annotation `path:"@in-error-pkts" ygotAnnotation:"true"`
	InForwardedOctets   *uint64           `path:"in-forwarded-octets" module:"openconfig-if-ip"`
	ΛInForwardedOctets  []ygot.Annotation `path:"@in-forwarded-octets" ygotAnnotation:"true"`
	InForwardedPkts     *uint64           `path:"in-forwarded-pkts" module:"openconfig-if-ip"`
	ΛInForwardedPkts    []ygot.Annotation `path:"@in-forwarded-pkts" ygotAnnotation:"true"`
	InMulticastOctets   *uint64           `path:"in-multicast-octets" module:"openconfig-if-ip"`
	ΛInMulticastOctets  []ygot.Annotation `path:"@in-multicast-octets" ygotAnnotation:"true"`
	InMulticastPkts     *uint64           `path:"in-multicast-pkts" module:"openconfig-if-ip"`
	ΛInMulticastPkts    []ygot.Annotation `path:"@in-multicast-pkts" ygotAnnotation:"true"`
	InOctets            *uint64           `path:"in-octets" module:"openconfig-if-ip"`
	ΛInOctets           []ygot.Annotation `path:"@in-octets" ygotAnnotation:"true"`
	InPkts              *uint64           `path:"in-pkts" module:"openconfig-if-ip"`
	ΛInPkts             []ygot.Annotation `path:"@in-pkts" ygotAnnotation:"true"`
	OutDiscardedPkts    *uint64           `path:"out-discarded-pkts" module:"openconfig-if-ip"`
	ΛOutDiscardedPkts   []ygot.Annotation `path:"@out-discarded-pkts" ygotAnnotation:"true"`
	OutErrorPkts        *uint64           `path:"out-error-pkts" module:"openconfig-if-ip"`
	ΛOutErrorPkts       []ygot.Annotation `path:"@out-error-pkts" ygotAnnotation:"true"`
	OutForwardedOctets  *uint64           `path:"out-forwarded-octets" module:"openconfig-if-ip"`
	ΛOutForwardedOctets []ygot.Annotation `path:"@out-forwarded-octets" ygotAnnotation:"true"`
	OutForwardedPkts    *uint64           `path:"out-forwarded-pkts" module:"openconfig-if-ip"`
	ΛOutForwardedPkts   []ygot.Annotation `path:"@out-forwarded-pkts" ygotAnnotation:"true"`
	OutMulticastOctets  *uint64           `path:"out-multicast-octets" module:"openconfig-if-ip"`
	ΛOutMulticastOctets []ygot.Annotation `path:"@out-multicast-octets" ygotAnnotation:"true"`
	OutMulticastPkts    *uint64           `path:"out-multicast-pkts" module:"openconfig-if-ip"`
	ΛOutMulticastPkts   []ygot.Annotation `path:"@out-multicast-pkts" ygotAnnotation:"true"`
	OutOctets           *uint64           `path:"out-octets" module:"openconfig-if-ip"`
	ΛOutOctets          []ygot.Annotation `path:"@out-octets" ygotAnnotation:"true"`
	OutPkts             *uint64           `path:"out-pkts" module:"openconfig-if-ip"`
	ΛOutPkts            []ygot.Annotation `path:"@out-pkts" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Counters) IsYANGGoStruct() {}

// GetInDiscardedPkts retrieves the value of the leaf InDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InDiscardedPkts is set, it can
// safely use t.GetInDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInDiscardedPkts() uint64 {
	if t == nil || t.InDiscardedPkts == nil {
		return 0
	}
	return *t.InDiscardedPkts
}

// GetInErrorPkts retrieves the value of the leaf InErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InErrorPkts is set, it can
// safely use t.GetInErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInErrorPkts() uint64 {
	if t == nil || t.InErrorPkts == nil {
		return 0
	}
	return *t.InErrorPkts
}

// GetInForwardedOctets retrieves the value of the leaf InForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedOctets is set, it can
// safely use t.GetInForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedOctets() uint64 {
	if t == nil || t.InForwardedOctets == nil {
		return 0
	}
	return *t.InForwardedOctets
}

// GetInForwardedPkts retrieves the value of the leaf InForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InForwardedPkts is set, it can
// safely use t.GetInForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInForwardedPkts() uint64 {
	if t == nil || t.InForwardedPkts == nil {
		return 0
	}
	return *t.InForwardedPkts
}

// GetInMulticastOctets retrieves the value of the leaf InMulticastOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastOctets is set, it can
// safely use t.GetInMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInMulticastOctets() uint64 {
	if t == nil || t.InMulticastOctets == nil {
		return 0
	}
	return *t.InMulticastOctets
}

// GetInMulticastPkts retrieves the value of the leaf InMulticastPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InMulticastPkts is set, it can
// safely use t.GetInMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInMulticastPkts() uint64 {
	if t == nil || t.InMulticastPkts == nil {
		return 0
	}
	return *t.InMulticastPkts
}

// GetInOctets retrieves the value of the leaf InOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutDiscardedPkts retrieves the value of the leaf OutDiscardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutDiscardedPkts is set, it can
// safely use t.GetOutDiscardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutDiscardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutDiscardedPkts() uint64 {
	if t == nil || t.OutDiscardedPkts == nil {
		return 0
	}
	return *t.OutDiscardedPkts
}

// GetOutErrorPkts retrieves the value of the leaf OutErrorPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutErrorPkts is set, it can
// safely use t.GetOutErrorPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutErrorPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutErrorPkts() uint64 {
	if t == nil || t.OutErrorPkts == nil {
		return 0
	}
	return *t.OutErrorPkts
}

// GetOutForwardedOctets retrieves the value of the leaf OutForwardedOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedOctets is set, it can
// safely use t.GetOutForwardedOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedOctets() uint64 {
	if t == nil || t.OutForwardedOctets == nil {
		return 0
	}
	return *t.OutForwardedOctets
}

// GetOutForwardedPkts retrieves the value of the leaf OutForwardedPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutForwardedPkts is set, it can
// safely use t.GetOutForwardedPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutForwardedPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutForwardedPkts() uint64 {
	if t == nil || t.OutForwardedPkts == nil {
		return 0
	}
	return *t.OutForwardedPkts
}

// GetOutMulticastOctets retrieves the value of the leaf OutMulticastOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastOctets is set, it can
// safely use t.GetOutMulticastOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutMulticastOctets() uint64 {
	if t == nil || t.OutMulticastOctets == nil {
		return 0
	}
	return *t.OutMulticastOctets
}

// GetOutMulticastPkts retrieves the value of the leaf OutMulticastPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutMulticastPkts is set, it can
// safely use t.GetOutMulticastPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutMulticastPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutMulticastPkts() uint64 {
	if t == nil || t.OutMulticastPkts == nil {
		return 0
	}
	return *t.OutMulticastPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Interface_Subinterface_Ipv6_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Counters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Counters.
func (*Interface_Subinterface_Ipv6_Counters) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Neighbor represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/neighbors/neighbor YANG schema element.
type Interface_Subinterface_Ipv6_Neighbor struct {
	ΛMetadata         []ygot.Annotation        `path:"@" ygotAnnotation:"true"`
	Ip                *string                  `path:"config/ip|ip" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛIp               []ygot.Annotation        `path:"config/@ip|@ip" ygotAnnotation:"true"`
	IsRouter          *bool                    `path:"state/is-router" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛIsRouter         []ygot.Annotation        `path:"state/@is-router" ygotAnnotation:"true"`
	LinkLayerAddress  *string                  `path:"config/link-layer-address" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLinkLayerAddress []ygot.Annotation        `path:"config/@link-layer-address" ygotAnnotation:"true"`
	NeighborState     E_Neighbor_NeighborState `path:"state/neighbor-state" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛNeighborState    []ygot.Annotation        `path:"state/@neighbor-state" ygotAnnotation:"true"`
	Origin            E_IfIp_NeighborOrigin    `path:"state/origin" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOrigin           []ygot.Annotation        `path:"state/@origin" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Neighbor) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetIsRouter retrieves the value of the leaf IsRouter from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsRouter is set, it can
// safely use t.GetIsRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsRouter == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetIsRouter() bool {
	if t == nil || t.IsRouter == nil {
		return false
	}
	return *t.IsRouter
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// GetNeighborState retrieves the value of the leaf NeighborState from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NeighborState is set, it can
// safely use t.GetNeighborState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NeighborState == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetNeighborState() E_Neighbor_NeighborState {
	if t == nil || t.NeighborState == 0 {
		return 0
	}
	return t.NeighborState
}

// GetOrigin retrieves the value of the leaf Origin from the Interface_Subinterface_Ipv6_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Neighbor) GetOrigin() E_IfIp_NeighborOrigin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_Neighbor struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ip == nil {
		return nil, fmt.Errorf("nil value for key Ip")
	}

	return map[string]interface{}{
		"ip": *t.Ip,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Neighbor.
func (*Interface_Subinterface_Ipv6_Neighbor) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement struct {
	ΛMetadata    []ygot.Annotation                                                  `path:"@" ygotAnnotation:"true"`
	Enable       *bool                                                              `path:"config/enable" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnable      []ygot.Annotation                                                  `path:"config/@enable" ygotAnnotation:"true"`
	Interval     *uint32                                                            `path:"config/interval" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterval    []ygot.Annotation                                                  `path:"config/@interval" ygotAnnotation:"true"`
	Lifetime     *uint32                                                            `path:"config/lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛLifetime    []ygot.Annotation                                                  `path:"config/@lifetime" ygotAnnotation:"true"`
	Managed      *bool                                                              `path:"config/managed" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛManaged     []ygot.Annotation                                                  `path:"config/@managed" ygotAnnotation:"true"`
	Mode         E_RouterAdvertisement_Mode                                         `path:"config/mode" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛMode        []ygot.Annotation                                                  `path:"config/@mode" ygotAnnotation:"true"`
	OtherConfig  *bool                                                              `path:"config/other-config" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛOtherConfig []ygot.Annotation                                                  `path:"config/@other-config" ygotAnnotation:"true"`
	Prefix       map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix `path:"prefixes/prefix" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPrefix      []ygot.Annotation                                                  `path:"prefixes/@prefix" ygotAnnotation:"true"`
	Suppress     *bool                                                              `path:"config/suppress" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSuppress    []ygot.Annotation                                                  `path:"config/@suppress" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// Interface_Subinterface_Ipv6_RouterAdvertisement struct. The keys of the list are populated from the input
// arguments.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) NewPrefix(Prefix string) (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the Interface_Subinterface_Ipv6_RouterAdvertisement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_RouterAdvertisement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetOrCreatePrefix(Prefix string) *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of Interface_Subinterface_Ipv6_RouterAdvertisement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetPrefix(Prefix string) *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver Interface_Subinterface_Ipv6_RouterAdvertisement. If there is no such element, the function
// is a no-op.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct to the
// list Prefix of Interface_Subinterface_Ipv6_RouterAdvertisement. If the key value(s) specified in
// the supplied Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix already exist in the list, an error is
// returned.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) AppendPrefix(v *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetEnable retrieves the value of the leaf Enable from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enable is set, it can
// safely use t.GetEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enable == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetEnable() bool {
	if t == nil || t.Enable == nil {
		return true
	}
	return *t.Enable
}

// GetInterval retrieves the value of the leaf Interval from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 0
	}
	return *t.Interval
}

// GetLifetime retrieves the value of the leaf Lifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lifetime is set, it can
// safely use t.GetLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetLifetime() uint32 {
	if t == nil || t.Lifetime == nil {
		return 0
	}
	return *t.Lifetime
}

// GetManaged retrieves the value of the leaf Managed from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Managed is set, it can
// safely use t.GetManaged() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Managed == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetManaged() bool {
	if t == nil || t.Managed == nil {
		return false
	}
	return *t.Managed
}

// GetMode retrieves the value of the leaf Mode from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetMode() E_RouterAdvertisement_Mode {
	if t == nil || t.Mode == 0 {
		return RouterAdvertisement_Mode_ALL
	}
	return t.Mode
}

// GetOtherConfig retrieves the value of the leaf OtherConfig from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfig is set, it can
// safely use t.GetOtherConfig() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfig == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetOtherConfig() bool {
	if t == nil || t.OtherConfig == nil {
		return false
	}
	return *t.OtherConfig
}

// GetSuppress retrieves the value of the leaf Suppress from the Interface_Subinterface_Ipv6_RouterAdvertisement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Suppress is set, it can
// safely use t.GetSuppress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Suppress == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) GetSuppress() bool {
	if t == nil || t.Suppress == nil {
		return false
	}
	return *t.Suppress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_RouterAdvertisement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enable == nil {
		var v bool = true
		t.Enable = &v
	}
	if t.Managed == nil {
		var v bool = false
		t.Managed = &v
	}
	if t.Mode == 0 {
		t.Mode = RouterAdvertisement_Mode_ALL
	}
	if t.OtherConfig == nil {
		var v bool = false
		t.OtherConfig = &v
	}
	if t.Suppress == nil {
		var v bool = false
		t.Suppress = &v
	}
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/prefixes/prefix YANG schema element.
type Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct {
	ΛMetadata                 []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	DisableAdvertisement      *bool             `path:"config/disable-advertisement" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDisableAdvertisement     []ygot.Annotation `path:"config/@disable-advertisement" ygotAnnotation:"true"`
	DisableAutoconfiguration  *bool             `path:"config/disable-autoconfiguration" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛDisableAutoconfiguration []ygot.Annotation `path:"config/@disable-autoconfiguration" ygotAnnotation:"true"`
	EnableOnlink              *bool             `path:"config/enable-onlink" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnableOnlink             []ygot.Annotation `path:"config/@enable-onlink" ygotAnnotation:"true"`
	PreferredLifetime         *uint32           `path:"config/preferred-lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛPreferredLifetime        []ygot.Annotation `path:"config/@preferred-lifetime" ygotAnnotation:"true"`
	Prefix                    *string           `path:"config/prefix|prefix" module:"openconfig-if-ip/openconfig-if-ip|openconfig-if-ip"`
	ΛPrefix                   []ygot.Annotation `path:"config/@prefix|@prefix" ygotAnnotation:"true"`
	ValidLifetime             *uint32           `path:"config/valid-lifetime" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛValidLifetime            []ygot.Annotation `path:"config/@valid-lifetime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) IsYANGGoStruct() {}

// GetDisableAdvertisement retrieves the value of the leaf DisableAdvertisement from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAdvertisement is set, it can
// safely use t.GetDisableAdvertisement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAdvertisement == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetDisableAdvertisement() bool {
	if t == nil || t.DisableAdvertisement == nil {
		return false
	}
	return *t.DisableAdvertisement
}

// GetDisableAutoconfiguration retrieves the value of the leaf DisableAutoconfiguration from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DisableAutoconfiguration is set, it can
// safely use t.GetDisableAutoconfiguration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DisableAutoconfiguration == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetDisableAutoconfiguration() bool {
	if t == nil || t.DisableAutoconfiguration == nil {
		return false
	}
	return *t.DisableAutoconfiguration
}

// GetEnableOnlink retrieves the value of the leaf EnableOnlink from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableOnlink is set, it can
// safely use t.GetEnableOnlink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableOnlink == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetEnableOnlink() bool {
	if t == nil || t.EnableOnlink == nil {
		return false
	}
	return *t.EnableOnlink
}

// GetPreferredLifetime retrieves the value of the leaf PreferredLifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferredLifetime is set, it can
// safely use t.GetPreferredLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferredLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetPreferredLifetime() uint32 {
	if t == nil || t.PreferredLifetime == nil {
		return 0
	}
	return *t.PreferredLifetime
}

// GetPrefix retrieves the value of the leaf Prefix from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetValidLifetime retrieves the value of the leaf ValidLifetime from the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ValidLifetime is set, it can
// safely use t.GetValidLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ValidLifetime == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) GetValidLifetime() uint32 {
	if t == nil || t.ValidLifetime == nil {
		return 0
	}
	return *t.ValidLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix struct, which is a YANG list entry.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix.
func (*Interface_Subinterface_Ipv6_RouterAdvertisement_Prefix) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered struct {
	ΛMetadata     []ygot.Annotation                                    `path:"@" ygotAnnotation:"true"`
	Enabled       *bool                                                `path:"config/enabled" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛEnabled      []ygot.Annotation                                    `path:"config/@enabled" ygotAnnotation:"true"`
	InterfaceRef  *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef `path:"interface-ref" module:"openconfig-if-ip"`
	ΛInterfaceRef []ygot.Annotation                                    `path:"@interface-ref" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered) IsYANGGoStruct() {}

// GetOrCreateInterfaceRef retrieves the value of the InterfaceRef field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetOrCreateInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	t.InterfaceRef = &Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef{}
	return t.InterfaceRef
}

// GetInterfaceRef returns the value of the InterfaceRef struct pointer
// from Interface_Subinterface_Ipv6_Unnumbered. If the receiver or the field InterfaceRef is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetInterfaceRef() *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef {
	if t != nil && t.InterfaceRef != nil {
		return t.InterfaceRef
	}
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the Interface_Subinterface_Ipv6_Unnumbered
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Enabled == nil {
		var v bool = false
		t.Enabled = &v
	}
	t.InterfaceRef.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered.
func (*Interface_Subinterface_Ipv6_Unnumbered) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/ipv6/unnumbered/interface-ref YANG schema element.
type Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Interface     *string           `path:"config/interface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛInterface    []ygot.Annotation `path:"config/@interface" ygotAnnotation:"true"`
	Subinterface  *uint32           `path:"config/subinterface" module:"openconfig-if-ip/openconfig-if-ip"`
	ΛSubinterface []ygot.Annotation `path:"config/@subinterface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetSubinterface retrieves the value of the leaf Subinterface from the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) GetSubinterface() uint32 {
	if t == nil || t.Subinterface == nil {
		return 0
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef.
func (*Interface_Subinterface_Ipv6_Unnumbered_InterfaceRef) ΛBelongingModule() string {
	return "openconfig-if-ip"
}

// Interface_Subinterface_Vlan represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan YANG schema element.
type Interface_Subinterface_Vlan struct {
	ΛMetadata       []ygot.Annotation                           `path:"@" ygotAnnotation:"true"`
	EgressMapping   *Interface_Subinterface_Vlan_EgressMapping  `path:"egress-mapping" module:"openconfig-vlan"`
	ΛEgressMapping  []ygot.Annotation                           `path:"@egress-mapping" ygotAnnotation:"true"`
	IngressMapping  *Interface_Subinterface_Vlan_IngressMapping `path:"ingress-mapping" module:"openconfig-vlan"`
	ΛIngressMapping []ygot.Annotation                           `path:"@ingress-mapping" ygotAnnotation:"true"`
	Match           *Interface_Subinterface_Vlan_Match          `path:"match" module:"openconfig-vlan"`
	ΛMatch          []ygot.Annotation                           `path:"@match" ygotAnnotation:"true"`
	VlanId          Interface_Subinterface_Vlan_VlanId_Union    `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanId         []ygot.Annotation                           `path:"config/@vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan) IsYANGGoStruct() {}

// GetOrCreateEgressMapping retrieves the value of the EgressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t.EgressMapping != nil {
		return t.EgressMapping
	}
	t.EgressMapping = &Interface_Subinterface_Vlan_EgressMapping{}
	return t.EgressMapping
}

// GetOrCreateIngressMapping retrieves the value of the IngressMapping field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t.IngressMapping != nil {
		return t.IngressMapping
	}
	t.IngressMapping = &Interface_Subinterface_Vlan_IngressMapping{}
	return t.IngressMapping
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan) GetOrCreateMatch() *Interface_Subinterface_Vlan_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &Interface_Subinterface_Vlan_Match{}
	return t.Match
}

// GetEgressMapping returns the value of the EgressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field EgressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetEgressMapping() *Interface_Subinterface_Vlan_EgressMapping {
	if t != nil && t.EgressMapping != nil {
		return t.EgressMapping
	}
	return nil
}

// GetIngressMapping returns the value of the IngressMapping struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field IngressMapping is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetIngressMapping() *Interface_Subinterface_Vlan_IngressMapping {
	if t != nil && t.IngressMapping != nil {
		return t.IngressMapping
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from Interface_Subinterface_Vlan. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan) GetMatch() *Interface_Subinterface_Vlan_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan) GetVlanId() Interface_Subinterface_Vlan_VlanId_Union {
	if t == nil || t.VlanId == nil {
		return nil
	}
	return t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EgressMapping.PopulateDefaults()
	t.IngressMapping.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan.
func (*Interface_Subinterface_Vlan) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_EgressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/egress-mapping YANG schema element.
type Interface_Subinterface_Vlan_EgressMapping struct {
	ΛMetadata        []ygot.Annotation           `path:"@" ygotAnnotation:"true"`
	Tpid             E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan"`
	ΛTpid            []ygot.Annotation           `path:"config/@tpid" ygotAnnotation:"true"`
	VlanId           *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanId          []ygot.Annotation           `path:"config/@vlan-id" ygotAnnotation:"true"`
	VlanStackAction  E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanStackAction []ygot.Annotation           `path:"config/@vlan-stack-action" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_EgressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_EgressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_EgressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_EgressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_EgressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_EgressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_EgressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_EgressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_EgressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_EgressMapping.
func (*Interface_Subinterface_Vlan_EgressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_IngressMapping represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/ingress-mapping YANG schema element.
type Interface_Subinterface_Vlan_IngressMapping struct {
	ΛMetadata        []ygot.Annotation           `path:"@" ygotAnnotation:"true"`
	Tpid             E_VlanTypes_TPID_TYPES      `path:"config/tpid" module:"openconfig-vlan/openconfig-vlan"`
	ΛTpid            []ygot.Annotation           `path:"config/@tpid" ygotAnnotation:"true"`
	VlanId           *uint16                     `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanId          []ygot.Annotation           `path:"config/@vlan-id" ygotAnnotation:"true"`
	VlanStackAction  E_VlanTypes_VlanStackAction `path:"config/vlan-stack-action" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanStackAction []ygot.Annotation           `path:"config/@vlan-stack-action" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_IngressMapping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_IngressMapping) IsYANGGoStruct() {}

// GetTpid retrieves the value of the leaf Tpid from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetTpid() E_VlanTypes_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// GetVlanStackAction retrieves the value of the leaf VlanStackAction from the Interface_Subinterface_Vlan_IngressMapping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanStackAction is set, it can
// safely use t.GetVlanStackAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanStackAction == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_IngressMapping) GetVlanStackAction() E_VlanTypes_VlanStackAction {
	if t == nil || t.VlanStackAction == 0 {
		return 0
	}
	return t.VlanStackAction
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_IngressMapping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_IngressMapping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_IngressMapping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_IngressMapping) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_IngressMapping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_IngressMapping.
func (*Interface_Subinterface_Vlan_IngressMapping) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match YANG schema element.
type Interface_Subinterface_Vlan_Match struct {
	ΛMetadata                    []ygot.Annotation                                              `path:"@" ygotAnnotation:"true"`
	DoubleTagged                 *Interface_Subinterface_Vlan_Match_DoubleTagged                `path:"double-tagged" module:"openconfig-vlan"`
	ΛDoubleTagged                []ygot.Annotation                                              `path:"@double-tagged" ygotAnnotation:"true"`
	DoubleTaggedInnerList        *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList       `path:"double-tagged-inner-list" module:"openconfig-vlan"`
	ΛDoubleTaggedInnerList       []ygot.Annotation                                              `path:"@double-tagged-inner-list" ygotAnnotation:"true"`
	DoubleTaggedInnerOuterRange  *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange `path:"double-tagged-inner-outer-range" module:"openconfig-vlan"`
	ΛDoubleTaggedInnerOuterRange []ygot.Annotation                                              `path:"@double-tagged-inner-outer-range" ygotAnnotation:"true"`
	DoubleTaggedInnerRange       *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange      `path:"double-tagged-inner-range" module:"openconfig-vlan"`
	ΛDoubleTaggedInnerRange      []ygot.Annotation                                              `path:"@double-tagged-inner-range" ygotAnnotation:"true"`
	DoubleTaggedOuterList        *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList       `path:"double-tagged-outer-list" module:"openconfig-vlan"`
	ΛDoubleTaggedOuterList       []ygot.Annotation                                              `path:"@double-tagged-outer-list" ygotAnnotation:"true"`
	DoubleTaggedOuterRange       *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange      `path:"double-tagged-outer-range" module:"openconfig-vlan"`
	ΛDoubleTaggedOuterRange      []ygot.Annotation                                              `path:"@double-tagged-outer-range" ygotAnnotation:"true"`
	SingleTagged                 *Interface_Subinterface_Vlan_Match_SingleTagged                `path:"single-tagged" module:"openconfig-vlan"`
	ΛSingleTagged                []ygot.Annotation                                              `path:"@single-tagged" ygotAnnotation:"true"`
	SingleTaggedList             *Interface_Subinterface_Vlan_Match_SingleTaggedList            `path:"single-tagged-list" module:"openconfig-vlan"`
	ΛSingleTaggedList            []ygot.Annotation                                              `path:"@single-tagged-list" ygotAnnotation:"true"`
	SingleTaggedRange            *Interface_Subinterface_Vlan_Match_SingleTaggedRange           `path:"single-tagged-range" module:"openconfig-vlan"`
	ΛSingleTaggedRange           []ygot.Annotation                                              `path:"@single-tagged-range" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match) IsYANGGoStruct() {}

// GetOrCreateDoubleTagged retrieves the value of the DoubleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	t.DoubleTagged = &Interface_Subinterface_Vlan_Match_DoubleTagged{}
	return t.DoubleTagged
}

// GetOrCreateDoubleTaggedInnerList retrieves the value of the DoubleTaggedInnerList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	t.DoubleTaggedInnerList = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList{}
	return t.DoubleTaggedInnerList
}

// GetOrCreateDoubleTaggedInnerOuterRange retrieves the value of the DoubleTaggedInnerOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	t.DoubleTaggedInnerOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange{}
	return t.DoubleTaggedInnerOuterRange
}

// GetOrCreateDoubleTaggedInnerRange retrieves the value of the DoubleTaggedInnerRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	t.DoubleTaggedInnerRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange{}
	return t.DoubleTaggedInnerRange
}

// GetOrCreateDoubleTaggedOuterList retrieves the value of the DoubleTaggedOuterList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	t.DoubleTaggedOuterList = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList{}
	return t.DoubleTaggedOuterList
}

// GetOrCreateDoubleTaggedOuterRange retrieves the value of the DoubleTaggedOuterRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	t.DoubleTaggedOuterRange = &Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange{}
	return t.DoubleTaggedOuterRange
}

// GetOrCreateSingleTagged retrieves the value of the SingleTagged field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t.SingleTagged != nil {
		return t.SingleTagged
	}
	t.SingleTagged = &Interface_Subinterface_Vlan_Match_SingleTagged{}
	return t.SingleTagged
}

// GetOrCreateSingleTaggedList retrieves the value of the SingleTaggedList field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	t.SingleTaggedList = &Interface_Subinterface_Vlan_Match_SingleTaggedList{}
	return t.SingleTaggedList
}

// GetOrCreateSingleTaggedRange retrieves the value of the SingleTaggedRange field
// or returns the existing field if it already exists.
func (t *Interface_Subinterface_Vlan_Match) GetOrCreateSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	t.SingleTaggedRange = &Interface_Subinterface_Vlan_Match_SingleTaggedRange{}
	return t.SingleTaggedRange
}

// GetDoubleTagged returns the value of the DoubleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTagged() *Interface_Subinterface_Vlan_Match_DoubleTagged {
	if t != nil && t.DoubleTagged != nil {
		return t.DoubleTagged
	}
	return nil
}

// GetDoubleTaggedInnerList returns the value of the DoubleTaggedInnerList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerList() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList {
	if t != nil && t.DoubleTaggedInnerList != nil {
		return t.DoubleTaggedInnerList
	}
	return nil
}

// GetDoubleTaggedInnerOuterRange returns the value of the DoubleTaggedInnerOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange {
	if t != nil && t.DoubleTaggedInnerOuterRange != nil {
		return t.DoubleTaggedInnerOuterRange
	}
	return nil
}

// GetDoubleTaggedInnerRange returns the value of the DoubleTaggedInnerRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedInnerRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedInnerRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange {
	if t != nil && t.DoubleTaggedInnerRange != nil {
		return t.DoubleTaggedInnerRange
	}
	return nil
}

// GetDoubleTaggedOuterList returns the value of the DoubleTaggedOuterList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterList() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList {
	if t != nil && t.DoubleTaggedOuterList != nil {
		return t.DoubleTaggedOuterList
	}
	return nil
}

// GetDoubleTaggedOuterRange returns the value of the DoubleTaggedOuterRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field DoubleTaggedOuterRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetDoubleTaggedOuterRange() *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange {
	if t != nil && t.DoubleTaggedOuterRange != nil {
		return t.DoubleTaggedOuterRange
	}
	return nil
}

// GetSingleTagged returns the value of the SingleTagged struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTagged is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTagged() *Interface_Subinterface_Vlan_Match_SingleTagged {
	if t != nil && t.SingleTagged != nil {
		return t.SingleTagged
	}
	return nil
}

// GetSingleTaggedList returns the value of the SingleTaggedList struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedList() *Interface_Subinterface_Vlan_Match_SingleTaggedList {
	if t != nil && t.SingleTaggedList != nil {
		return t.SingleTaggedList
	}
	return nil
}

// GetSingleTaggedRange returns the value of the SingleTaggedRange struct pointer
// from Interface_Subinterface_Vlan_Match. If the receiver or the field SingleTaggedRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Interface_Subinterface_Vlan_Match) GetSingleTaggedRange() *Interface_Subinterface_Vlan_Match_SingleTaggedRange {
	if t != nil && t.SingleTaggedRange != nil {
		return t.SingleTaggedRange
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DoubleTagged.PopulateDefaults()
	t.DoubleTaggedInnerList.PopulateDefaults()
	t.DoubleTaggedInnerOuterRange.PopulateDefaults()
	t.DoubleTaggedInnerRange.PopulateDefaults()
	t.DoubleTaggedOuterList.PopulateDefaults()
	t.DoubleTaggedOuterRange.PopulateDefaults()
	t.SingleTagged.PopulateDefaults()
	t.SingleTaggedList.PopulateDefaults()
	t.SingleTaggedRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match.
func (*Interface_Subinterface_Vlan_Match) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTagged struct {
	ΛMetadata    []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerVlanId  *uint16           `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerVlanId []ygot.Annotation `path:"config/@inner-vlan-id" ygotAnnotation:"true"`
	OuterVlanId  *uint16           `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterVlanId []ygot.Annotation `path:"config/@outer-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTagged.
func (*Interface_Subinterface_Vlan_Match_DoubleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerVlanIds  []uint16          `path:"config/inner-vlan-ids" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerVlanIds []ygot.Annotation `path:"config/@inner-vlan-ids" ygotAnnotation:"true"`
	OuterVlanId   *uint16           `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterVlanId  []ygot.Annotation `path:"config/@outer-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) IsYANGGoStruct() {}

// GetInnerVlanIds retrieves the value of the leaf InnerVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanIds is set, it can
// safely use t.GetInnerVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetInnerVlanIds() []uint16 {
	if t == nil || t.InnerVlanIds == nil {
		return nil
	}
	return t.InnerVlanIds
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) GetOuterVlanId() uint16 {
	if t == nil || t.OuterVlanId == nil {
		return 0
	}
	return *t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange struct {
	ΛMetadata        []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerHighVlanId  *uint16           `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerHighVlanId []ygot.Annotation `path:"config/@inner-high-vlan-id" ygotAnnotation:"true"`
	InnerLowVlanId   *uint16           `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerLowVlanId  []ygot.Annotation `path:"config/@inner-low-vlan-id" ygotAnnotation:"true"`
	OuterHighVlanId  *uint16           `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterHighVlanId []ygot.Annotation `path:"config/@outer-high-vlan-id" ygotAnnotation:"true"`
	OuterLowVlanId   *uint16           `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterLowVlanId  []ygot.Annotation `path:"config/@outer-low-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-inner-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange struct {
	ΛMetadata        []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerHighVlanId  *uint16           `path:"config/inner-high-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerHighVlanId []ygot.Annotation `path:"config/@inner-high-vlan-id" ygotAnnotation:"true"`
	InnerLowVlanId   *uint16           `path:"config/inner-low-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerLowVlanId  []ygot.Annotation `path:"config/@inner-low-vlan-id" ygotAnnotation:"true"`
	OuterVlanId      []uint16          `path:"config/outer-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterVlanId     []ygot.Annotation `path:"config/@outer-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) IsYANGGoStruct() {}

// GetInnerHighVlanId retrieves the value of the leaf InnerHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerHighVlanId is set, it can
// safely use t.GetInnerHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerHighVlanId() uint16 {
	if t == nil || t.InnerHighVlanId == nil {
		return 0
	}
	return *t.InnerHighVlanId
}

// GetInnerLowVlanId retrieves the value of the leaf InnerLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerLowVlanId is set, it can
// safely use t.GetInnerLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetInnerLowVlanId() uint16 {
	if t == nil || t.InnerLowVlanId == nil {
		return 0
	}
	return *t.InnerLowVlanId
}

// GetOuterVlanId retrieves the value of the leaf OuterVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanId is set, it can
// safely use t.GetOuterVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) GetOuterVlanId() []uint16 {
	if t == nil || t.OuterVlanId == nil {
		return nil
	}
	return t.OuterVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedInnerRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-list YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList struct {
	ΛMetadata     []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerVlanId   *uint16           `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerVlanId  []ygot.Annotation `path:"config/@inner-vlan-id" ygotAnnotation:"true"`
	OuterVlanIds  []uint16          `path:"config/outer-vlan-ids" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterVlanIds []ygot.Annotation `path:"config/@outer-vlan-ids" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterVlanIds retrieves the value of the leaf OuterVlanIds from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterVlanIds is set, it can
// safely use t.GetOuterVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterVlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) GetOuterVlanIds() []uint16 {
	if t == nil || t.OuterVlanIds == nil {
		return nil
	}
	return t.OuterVlanIds
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/double-tagged-outer-range YANG schema element.
type Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange struct {
	ΛMetadata        []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	InnerVlanId      *uint16           `path:"config/inner-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛInnerVlanId     []ygot.Annotation `path:"config/@inner-vlan-id" ygotAnnotation:"true"`
	OuterHighVlanId  *uint16           `path:"config/outer-high-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterHighVlanId []ygot.Annotation `path:"config/@outer-high-vlan-id" ygotAnnotation:"true"`
	OuterLowVlanId   *uint16           `path:"config/outer-low-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛOuterLowVlanId  []ygot.Annotation `path:"config/@outer-low-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) IsYANGGoStruct() {}

// GetInnerVlanId retrieves the value of the leaf InnerVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerVlanId is set, it can
// safely use t.GetInnerVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetInnerVlanId() uint16 {
	if t == nil || t.InnerVlanId == nil {
		return 0
	}
	return *t.InnerVlanId
}

// GetOuterHighVlanId retrieves the value of the leaf OuterHighVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterHighVlanId is set, it can
// safely use t.GetOuterHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterHighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterHighVlanId() uint16 {
	if t == nil || t.OuterHighVlanId == nil {
		return 0
	}
	return *t.OuterHighVlanId
}

// GetOuterLowVlanId retrieves the value of the leaf OuterLowVlanId from the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterLowVlanId is set, it can
// safely use t.GetOuterLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterLowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) GetOuterLowVlanId() uint16 {
	if t == nil || t.OuterLowVlanId == nil {
		return 0
	}
	return *t.OuterLowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange.
func (*Interface_Subinterface_Vlan_Match_DoubleTaggedOuterRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTagged represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTagged struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	VlanId    *uint16           `path:"config/vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanId   []ygot.Annotation `path:"config/@vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTagged implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) IsYANGGoStruct() {}

// GetVlanId retrieves the value of the leaf VlanId from the Interface_Subinterface_Vlan_Match_SingleTagged
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanId is set, it can
// safely use t.GetVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) GetVlanId() uint16 {
	if t == nil || t.VlanId == nil {
		return 0
	}
	return *t.VlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTagged
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTagged.
func (*Interface_Subinterface_Vlan_Match_SingleTagged) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedList represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-list YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedList struct {
	ΛMetadata []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	VlanIds   []uint16          `path:"config/vlan-ids" module:"openconfig-vlan/openconfig-vlan"`
	ΛVlanIds  []ygot.Annotation `path:"config/@vlan-ids" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) IsYANGGoStruct() {}

// GetVlanIds retrieves the value of the leaf VlanIds from the Interface_Subinterface_Vlan_Match_SingleTaggedList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanIds is set, it can
// safely use t.GetVlanIds() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanIds == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) GetVlanIds() []uint16 {
	if t == nil || t.VlanIds == nil {
		return nil
	}
	return t.VlanIds
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedList.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedList) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Interface_Subinterface_Vlan_Match_SingleTaggedRange represents the /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/match/single-tagged-range YANG schema element.
type Interface_Subinterface_Vlan_Match_SingleTaggedRange struct {
	ΛMetadata   []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	HighVlanId  *uint16           `path:"config/high-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛHighVlanId []ygot.Annotation `path:"config/@high-vlan-id" ygotAnnotation:"true"`
	LowVlanId   *uint16           `path:"config/low-vlan-id" module:"openconfig-vlan/openconfig-vlan"`
	ΛLowVlanId  []ygot.Annotation `path:"config/@low-vlan-id" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Interface_Subinterface_Vlan_Match_SingleTaggedRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) IsYANGGoStruct() {}

// GetHighVlanId retrieves the value of the leaf HighVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighVlanId is set, it can
// safely use t.GetHighVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetHighVlanId() uint16 {
	if t == nil || t.HighVlanId == nil {
		return 0
	}
	return *t.HighVlanId
}

// GetLowVlanId retrieves the value of the leaf LowVlanId from the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowVlanId is set, it can
// safely use t.GetLowVlanId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowVlanId == nil' before retrieving the leaf's value.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) GetLowVlanId() uint16 {
	if t == nil || t.LowVlanId == nil {
		return 0
	}
	return *t.LowVlanId
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Subinterface_Vlan_Match_SingleTaggedRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Subinterface_Vlan_Match_SingleTaggedRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Subinterface_Vlan_Match_SingleTaggedRange.
func (*Interface_Subinterface_Vlan_Match_SingleTaggedRange) ΛBelongingModule() string {
	return "openconfig-vlan"
}

// Keychain represents the /openconfig-keychain/keychains/keychain YANG schema element.
type Keychain struct {
	ΛMetadata  []ygot.Annotation                          `path:"@" ygotAnnotation:"true"`
	Key        map[Keychain_Key_KeyId_Union]*Keychain_Key `path:"keys/key" module:"openconfig-keychain/openconfig-keychain"`
	ΛKey       []ygot.Annotation                          `path:"keys/@key" ygotAnnotation:"true"`
	Name       *string                                    `path:"config/name|name" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	ΛName      []ygot.Annotation                          `path:"config/@name|@name" ygotAnnotation:"true"`
	Tolerance  Keychain_Tolerance_Union                   `path:"config/tolerance" module:"openconfig-keychain/openconfig-keychain"`
	ΛTolerance []ygot.Annotation                          `path:"config/@tolerance" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Keychain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain) IsYANGGoStruct() {}

// NewKey creates a new entry in the Key list of the
// Keychain struct. The keys of the list are populated from the input
// arguments.
func (t *Keychain) NewKey(KeyId Keychain_Key_KeyId_Union) (*Keychain_Key, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[Keychain_Key_KeyId_Union]*Keychain_Key)
	}

	key := KeyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Key[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Key", key)
	}

	t.Key[key] = &Keychain_Key{
		KeyId: KeyId,
	}

	return t.Key[key], nil
}

// RenameKey renames an entry in the list Key within
// the Keychain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Keychain) RenameKey(oldK, newK Keychain_Key_KeyId_Union) error {
	if _, ok := t.Key[newK]; ok {
		return fmt.Errorf("key %v already exists in Key", newK)
	}

	e, ok := t.Key[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Key", oldK)
	}
	e.KeyId = newK

	t.Key[newK] = e
	delete(t.Key, oldK)
	return nil
}

// GetOrCreateKey retrieves the value with the specified keys from
// the receiver Keychain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Keychain) GetOrCreateKey(KeyId Keychain_Key_KeyId_Union) *Keychain_Key {

	key := KeyId

	if v, ok := t.Key[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKey(KeyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKey got unexpected error: %v", err))
	}
	return v
}

// GetKey retrieves the value with the specified key from
// the Key map field of Keychain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Keychain) GetKey(KeyId Keychain_Key_KeyId_Union) *Keychain_Key {

	if t == nil {
		return nil
	}

	key := KeyId

	if lm, ok := t.Key[key]; ok {
		return lm
	}
	return nil
}

// DeleteKey deletes the value with the specified keys from
// the receiver Keychain. If there is no such element, the function
// is a no-op.
func (t *Keychain) DeleteKey(KeyId Keychain_Key_KeyId_Union) {
	key := KeyId

	delete(t.Key, key)
}

// AppendKey appends the supplied Keychain_Key struct to the
// list Key of Keychain. If the key value(s) specified in
// the supplied Keychain_Key already exist in the list, an error is
// returned.
func (t *Keychain) AppendKey(v *Keychain_Key) error {
	key := v.KeyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[Keychain_Key_KeyId_Union]*Keychain_Key)
	}

	if _, ok := t.Key[key]; ok {
		return fmt.Errorf("duplicate key for list Key %v", key)
	}

	t.Key[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Keychain) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTolerance retrieves the value of the leaf Tolerance from the Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *Keychain) GetTolerance() Keychain_Tolerance_Union {
	if t == nil || t.Tolerance == nil {
		return nil
	}
	return t.Tolerance
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Key {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Keychain struct, which is a YANG list entry.
func (t *Keychain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain.
func (*Keychain) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key represents the /openconfig-keychain/keychains/keychain/keys/key YANG schema element.
type Keychain_Key struct {
	ΛMetadata        []ygot.Annotation             `path:"@" ygotAnnotation:"true"`
	CryptoAlgorithm  E_KeychainTypes_CRYPTO_TYPE   `path:"config/crypto-algorithm" module:"openconfig-keychain/openconfig-keychain"`
	ΛCryptoAlgorithm []ygot.Annotation             `path:"config/@crypto-algorithm" ygotAnnotation:"true"`
	KeyId            Keychain_Key_KeyId_Union      `path:"config/key-id|key-id" module:"openconfig-keychain/openconfig-keychain|openconfig-keychain"`
	ΛKeyId           []ygot.Annotation             `path:"config/@key-id|@key-id" ygotAnnotation:"true"`
	ReceiveLifetime  *Keychain_Key_ReceiveLifetime `path:"receive-lifetime" module:"openconfig-keychain"`
	ΛReceiveLifetime []ygot.Annotation             `path:"@receive-lifetime" ygotAnnotation:"true"`
	SecretKey        *string                       `path:"config/secret-key" module:"openconfig-keychain/openconfig-keychain"`
	ΛSecretKey       []ygot.Annotation             `path:"config/@secret-key" ygotAnnotation:"true"`
	SendLifetime     *Keychain_Key_SendLifetime    `path:"send-lifetime" module:"openconfig-keychain"`
	ΛSendLifetime    []ygot.Annotation             `path:"@send-lifetime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Keychain_Key implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key) IsYANGGoStruct() {}

// GetOrCreateReceiveLifetime retrieves the value of the ReceiveLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	t.ReceiveLifetime = &Keychain_Key_ReceiveLifetime{}
	return t.ReceiveLifetime
}

// GetOrCreateSendLifetime retrieves the value of the SendLifetime field
// or returns the existing field if it already exists.
func (t *Keychain_Key) GetOrCreateSendLifetime() *Keychain_Key_SendLifetime {
	if t.SendLifetime != nil {
		return t.SendLifetime
	}
	t.SendLifetime = &Keychain_Key_SendLifetime{}
	return t.SendLifetime
}

// GetReceiveLifetime returns the value of the ReceiveLifetime struct pointer
// from Keychain_Key. If the receiver or the field ReceiveLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetReceiveLifetime() *Keychain_Key_ReceiveLifetime {
	if t != nil && t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	return nil
}

// GetSendLifetime returns the value of the SendLifetime struct pointer
// from Keychain_Key. If the receiver or the field SendLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Keychain_Key) GetSendLifetime() *Keychain_Key_SendLifetime {
	if t != nil && t.SendLifetime != nil {
		return t.SendLifetime
	}
	return nil
}

// GetCryptoAlgorithm retrieves the value of the leaf CryptoAlgorithm from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CryptoAlgorithm is set, it can
// safely use t.GetCryptoAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CryptoAlgorithm == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetCryptoAlgorithm() E_KeychainTypes_CRYPTO_TYPE {
	if t == nil || t.CryptoAlgorithm == 0 {
		return 0
	}
	return t.CryptoAlgorithm
}

// GetKeyId retrieves the value of the leaf KeyId from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyId is set, it can
// safely use t.GetKeyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyId == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetKeyId() Keychain_Key_KeyId_Union {
	if t == nil || t.KeyId == nil {
		return nil
	}
	return t.KeyId
}

// GetSecretKey retrieves the value of the leaf SecretKey from the Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecretKey is set, it can
// safely use t.GetSecretKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecretKey == nil' before retrieving the leaf's value.
func (t *Keychain_Key) GetSecretKey() string {
	if t == nil || t.SecretKey == nil {
		return ""
	}
	return *t.SecretKey
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ReceiveLifetime.PopulateDefaults()
	t.SendLifetime.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Keychain_Key struct, which is a YANG list entry.
func (t *Keychain_Key) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"key-id": t.KeyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key.
func (*Keychain_Key) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_ReceiveLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/receive-lifetime YANG schema element.
type Keychain_Key_ReceiveLifetime struct {
	ΛMetadata  []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	EndTime    *uint64           `path:"config/end-time" module:"openconfig-keychain/openconfig-keychain"`
	ΛEndTime   []ygot.Annotation `path:"config/@end-time" ygotAnnotation:"true"`
	StartTime  *uint64           `path:"config/start-time" module:"openconfig-keychain/openconfig-keychain"`
	ΛStartTime []ygot.Annotation `path:"config/@start-time" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Keychain_Key_ReceiveLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_ReceiveLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_ReceiveLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_ReceiveLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_ReceiveLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_ReceiveLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_ReceiveLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_ReceiveLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_ReceiveLifetime.
func (*Keychain_Key_ReceiveLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Keychain_Key_SendLifetime represents the /openconfig-keychain/keychains/keychain/keys/key/send-lifetime YANG schema element.
type Keychain_Key_SendLifetime struct {
	ΛMetadata       []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	EndTime         *uint64           `path:"config/end-time" module:"openconfig-keychain/openconfig-keychain"`
	ΛEndTime        []ygot.Annotation `path:"config/@end-time" ygotAnnotation:"true"`
	SendAndReceive  *bool             `path:"config/send-and-receive" module:"openconfig-keychain/openconfig-keychain"`
	ΛSendAndReceive []ygot.Annotation `path:"config/@send-and-receive" ygotAnnotation:"true"`
	StartTime       *uint64           `path:"config/start-time" module:"openconfig-keychain/openconfig-keychain"`
	ΛStartTime      []ygot.Annotation `path:"config/@start-time" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Keychain_Key_SendLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Keychain_Key_SendLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetEndTime() uint64 {
	if t == nil || t.EndTime == nil {
		return 0
	}
	return *t.EndTime
}

// GetSendAndReceive retrieves the value of the leaf SendAndReceive from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendAndReceive is set, it can
// safely use t.GetSendAndReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendAndReceive == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetSendAndReceive() bool {
	if t == nil || t.SendAndReceive == nil {
		return true
	}
	return *t.SendAndReceive
}

// GetStartTime retrieves the value of the leaf StartTime from the Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *Keychain_Key_SendLifetime) GetStartTime() uint64 {
	if t == nil || t.StartTime == nil {
		return 0
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the Keychain_Key_SendLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Keychain_Key_SendLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SendAndReceive == nil {
		var v bool = true
		t.SendAndReceive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Keychain_Key_SendLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Keychain_Key_SendLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Keychain_Key_SendLifetime) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Keychain_Key_SendLifetime.
func (*Keychain_Key_SendLifetime) ΛBelongingModule() string {
	return "openconfig-keychain"
}

// Lacp represents the /openconfig-lacp/lacp YANG schema element.
type Lacp struct {
	ΛMetadata       []ygot.Annotation          `path:"@" ygotAnnotation:"true"`
	Interface       map[string]*Lacp_Interface `path:"interfaces/interface" module:"openconfig-lacp/openconfig-lacp"`
	ΛInterface      []ygot.Annotation          `path:"interfaces/@interface" ygotAnnotation:"true"`
	SystemPriority  *uint16                    `path:"config/system-priority" module:"openconfig-lacp/openconfig-lacp"`
	ΛSystemPriority []ygot.Annotation          `path:"config/@system-priority" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewInterface(Name string) (*Lacp_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Lacp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Lacp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateInterface(Name string) *Lacp_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetInterface(Name string) *Lacp_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Lacp_Interface struct to the
// list Interface of Lacp. If the key value(s) specified in
// the supplied Lacp_Interface already exist in the list, an error is
// returned.
func (t *Lacp) AppendInterface(v *Lacp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Lacp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp.
func (*Lacp) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface represents the /openconfig-lacp/lacp/interfaces/interface YANG schema element.
type Lacp_Interface struct {
	ΛMetadata       []ygot.Annotation                 `path:"@" ygotAnnotation:"true"`
	Interval        E_Lacp_LacpPeriodType             `path:"config/interval" module:"openconfig-lacp/openconfig-lacp"`
	ΛInterval       []ygot.Annotation                 `path:"config/@interval" ygotAnnotation:"true"`
	LacpMode        E_Lacp_LacpActivityType           `path:"config/lacp-mode" module:"openconfig-lacp/openconfig-lacp"`
	ΛLacpMode       []ygot.Annotation                 `path:"config/@lacp-mode" ygotAnnotation:"true"`
	Member          map[string]*Lacp_Interface_Member `path:"members/member" module:"openconfig-lacp/openconfig-lacp"`
	ΛMember         []ygot.Annotation                 `path:"members/@member" ygotAnnotation:"true"`
	Name            *string                           `path:"config/name|name" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	ΛName           []ygot.Annotation                 `path:"config/@name|@name" ygotAnnotation:"true"`
	SystemIdMac     *string                           `path:"config/system-id-mac" module:"openconfig-lacp/openconfig-lacp"`
	ΛSystemIdMac    []ygot.Annotation                 `path:"config/@system-id-mac" ygotAnnotation:"true"`
	SystemPriority  *uint16                           `path:"config/system-priority" module:"openconfig-lacp/openconfig-lacp"`
	ΛSystemPriority []ygot.Annotation                 `path:"config/@system-priority" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lacp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface) IsYANGGoStruct() {}

// NewMember creates a new entry in the Member list of the
// Lacp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp_Interface) NewMember(Interface string) (*Lacp_Interface_Member, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &Lacp_Interface_Member{
		Interface: &Interface,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the Lacp_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Lacp_Interface) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.Interface = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver Lacp_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp_Interface) GetOrCreateMember(Interface string) *Lacp_Interface_Member {

	key := Interface

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of Lacp_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp_Interface) GetMember(Interface string) *Lacp_Interface_Member {

	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.Member[key]; ok {
		return lm
	}
	return nil
}

// DeleteMember deletes the value with the specified keys from
// the receiver Lacp_Interface. If there is no such element, the function
// is a no-op.
func (t *Lacp_Interface) DeleteMember(Interface string) {
	key := Interface

	delete(t.Member, key)
}

// AppendMember appends the supplied Lacp_Interface_Member struct to the
// list Member of Lacp_Interface. If the key value(s) specified in
// the supplied Lacp_Interface_Member already exist in the list, an error is
// returned.
func (t *Lacp_Interface) AppendMember(v *Lacp_Interface_Member) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*Lacp_Interface_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// GetInterval retrieves the value of the leaf Interval from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetInterval() E_Lacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return Lacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetLacpMode() E_Lacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return Lacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetName retrieves the value of the leaf Name from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the Lacp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *Lacp_Interface) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == 0 {
		t.Interval = Lacp_LacpPeriodType_SLOW
	}
	if t.LacpMode == 0 {
		t.LacpMode = Lacp_LacpActivityType_ACTIVE
	}
	for _, e := range t.Member {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Lacp_Interface struct, which is a YANG list entry.
func (t *Lacp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface.
func (*Lacp_Interface) ΛBelongingModule() string {
	return "openconfig-lacp"
}

// Lacp_Interface_Member represents the /openconfig-lacp/lacp/interfaces/interface/members/member YANG schema element.
type Lacp_Interface_Member struct {
	ΛMetadata        []ygot.Annotation               `path:"@" ygotAnnotation:"true"`
	Activity         E_Lacp_LacpActivityType         `path:"state/activity" module:"openconfig-lacp/openconfig-lacp"`
	ΛActivity        []ygot.Annotation               `path:"state/@activity" ygotAnnotation:"true"`
	Aggregatable     *bool                           `path:"state/aggregatable" module:"openconfig-lacp/openconfig-lacp"`
	ΛAggregatable    []ygot.Annotation               `path:"state/@aggregatable" ygotAnnotation:"true"`
	Collecting       *bool                           `path:"state/collecting" module:"openconfig-lacp/openconfig-lacp"`
	ΛCollecting      []ygot.Annotation               `path:"state/@collecting" ygotAnnotation:"true"`
	Counters         *Lacp_Interface_Member_Counters `path:"state/counters" module:"openconfig-lacp/openconfig-lacp"`
	ΛCounters        []ygot.Annotation               `path:"state/@counters" ygotAnnotation:"true"`
	Distributing     *bool                           `path:"state/distributing" module:"openconfig-lacp/openconfig-lacp"`
	ΛDistributing    []ygot.Annotation               `path:"state/@distributing" ygotAnnotation:"true"`
	Interface        *string                         `path:"state/interface|interface" module:"openconfig-lacp/openconfig-lacp|openconfig-lacp"`
	ΛInterface       []ygot.Annotation               `path:"state/@interface|@interface" ygotAnnotation:"true"`
	LastChange       *uint64                         `path:"state/last-change" module:"openconfig-lacp/openconfig-lacp"`
	ΛLastChange      []ygot.Annotation               `path:"state/@last-change" ygotAnnotation:"true"`
	OperKey          *uint16                         `path:"state/oper-key" module:"openconfig-lacp/openconfig-lacp"`
	ΛOperKey         []ygot.Annotation               `path:"state/@oper-key" ygotAnnotation:"true"`
	PartnerId        *string                         `path:"state/partner-id" module:"openconfig-lacp/openconfig-lacp"`
	ΛPartnerId       []ygot.Annotation               `path:"state/@partner-id" ygotAnnotation:"true"`
	PartnerKey       *uint16                         `path:"state/partner-key" module:"openconfig-lacp/openconfig-lacp"`
	ΛPartnerKey      []ygot.Annotation               `path:"state/@partner-key" ygotAnnotation:"true"`
	PartnerPortNum   *uint16                         `path:"state/partner-port-num" module:"openconfig-lacp/openconfig-lacp"`
	ΛPartnerPortNum  []ygot.Annotation               `path:"state/@partner-port-num" ygotAnnotation:"true"`
	PortNum          *uint16                         `path:"state/port-num" module:"openconfig-lacp/openconfig-lacp"`
	ΛPortNum         []ygot.Annotation               `path:"state/@port-num" ygotAnnotation:"true"`
	Synchronization  E_Lacp_LacpSynchronizationType  `path:"state/synchronization" module:"openconfig-lacp/openconfig-lacp"`
	ΛSynchronization []ygot.Annotation               `path:"state/@synchronization" ygotAnnotation:"true"`
	SystemId         *string                         `path:"state/system-id" module:"openconfig-lacp/openconfig-lacp"`
	ΛSystemId        []ygot.Annotation               `path:"state/@system-id" ygotAnnotation:"true"`
	Timeout          E_Lacp_LacpTimeoutType          `path:"state/timeout" module:"openconfig-lacp/openconfig-lacp"`
	ΛTimeout         []ygot.Annotation               `path:"state/@timeout" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Lacp_Interface_Member implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_Interface_Member) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_Interface_Member) GetOrCreateCounters() *Lacp_Interface_Member_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_Interface_Member_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_Interface_Member. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_Interface_Member) GetCounters() *Lacp_Interface_Member_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetActivity retrieves the value of the leaf Activity from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Activity is set, it can
// safely use t.GetActivity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Activity == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetActivity() E_Lacp_LacpActivityType {
	if t == nil || t.Activity == 0 {
		return 0
	}
	return t.Activity
}

// GetAggregatable retrieves the value of the leaf Aggregatable from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aggregatable is set, it can
// safely use t.GetAggregatable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aggregatable == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetAggregatable() bool {
	if t == nil || t.Aggregatable == nil {
		return false
	}
	return *t.Aggregatable
}

// GetCollecting retrieves the value of the leaf Collecting from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Collecting is set, it can
// safely use t.GetCollecting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Collecting == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetCollecting() bool {
	if t == nil || t.Collecting == nil {
		return false
	}
	return *t.Collecting
}

// GetDistributing retrieves the value of the leaf Distributing from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Distributing is set, it can
// safely use t.GetDistributing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Distributing == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetDistributing() bool {
	if t == nil || t.Distributing == nil {
		return false
	}
	return *t.Distributing
}

// GetInterface retrieves the value of the leaf Interface from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLastChange retrieves the value of the leaf LastChange from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LastChange is set, it can
// safely use t.GetLastChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LastChange == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetLastChange() uint64 {
	if t == nil || t.LastChange == nil {
		return 0
	}
	return *t.LastChange
}

// GetOperKey retrieves the value of the leaf OperKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperKey is set, it can
// safely use t.GetOperKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetOperKey() uint16 {
	if t == nil || t.OperKey == nil {
		return 0
	}
	return *t.OperKey
}

// GetPartnerId retrieves the value of the leaf PartnerId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerId is set, it can
// safely use t.GetPartnerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerId() string {
	if t == nil || t.PartnerId == nil {
		return ""
	}
	return *t.PartnerId
}

// GetPartnerKey retrieves the value of the leaf PartnerKey from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerKey is set, it can
// safely use t.GetPartnerKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerKey == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerKey() uint16 {
	if t == nil || t.PartnerKey == nil {
		return 0
	}
	return *t.PartnerKey
}

// GetPartnerPortNum retrieves the value of the leaf PartnerPortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortNum is set, it can
// safely use t.GetPartnerPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPartnerPortNum() uint16 {
	if t == nil || t.PartnerPortNum == nil {
		return 0
	}
	return *t.PartnerPortNum
}

// GetPortNum retrieves the value of the leaf PortNum from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNum is set, it can
// safely use t.GetPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNum == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetPortNum() uint16 {
	if t == nil || t.PortNum == nil {
		return 0
	}
	return *t.PortNum
}

// GetSynchronization retrieves the value of the leaf Synchronization from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Synchronization is set, it can
// safely use t.GetSynchronization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Synchronization == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSynchronization() E_Lacp_LacpSynchronizationType {
	if t == nil || t.Synchronization == 0 {
		return 0
	}
	return t.Synchronization
}

// GetSystemId retrieves the value of the leaf SystemId from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTimeout retrieves the value of the leaf Timeout from the Lacp_Interface_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *Lacp_Interface_Member) GetTimeout() E_Lacp_LacpTimeoutType {
	if t == nil || t.Timeout == 0 {
		return 0
	}
	return t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_Interface_Member
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_Interface_Member) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Lacp_Interface_Member struct, which is a YANG list entry.
func (t *Lacp_Interface_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_Interface_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_Interface_Member) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_Interface_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_Interface_Member.
func (*Lacp_Interface_Member) ΛBelongingModule() string {
	return "openconfig-lacp"
}
